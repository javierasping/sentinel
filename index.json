[{"categories":null,"contents":" El objetivo de este post es comparar los distintos software de VPNs mas utilizados viendo cual es mas rápido , para ello nos apoyaremos en test de velocidad utilizando iperf3 .\n[!NOTE]\nLa comparativa parte de los post de esta sección en los que montamos cada tipo de VPN .\nVelocidad sin VPN Voy a comenzar comparando las velocidades de estos 2 sistemas , utilizando iperf3 . Para ello he quitado el router cisco ya que lo tenia configurado con interfaces FastEthernet y lo he cambiado por un router Linux con interfaces GigabitEthernet .\nVoy a lanzar un iperf3 utilizando las direcciones publicas para que el trafico no utilice ninguna VPN :\njaviercruces@servidor2:~$ iperf3 -c 90.0.0.2 -i 1 -t 30 Connecting to host 90.0.0.2, port 5201 [ 5] local 100.0.0.2 port 32858 connected to 90.0.0.2 port 5201 [ ID] Interval Transfer Bitrate Retr Cwnd [ 5] 0.00-1.00 sec 110 MBytes 919 Mbits/sec 897 188 KBytes [ 5] 1.00-2.00 sec 102 MBytes 859 Mbits/sec 712 120 KBytes [ 5] 2.00-3.00 sec 111 MBytes 931 Mbits/sec 735 83.4 KBytes [ 5] 3.00-4.00 sec 112 MBytes 944 Mbits/sec 600 173 KBytes [ 5] 4.00-5.00 sec 109 MBytes 913 Mbits/sec 1018 126 KBytes [ 5] 5.00-6.00 sec 115 MBytes 961 Mbits/sec 889 113 KBytes [ 5] 6.00-7.00 sec 113 MBytes 947 Mbits/sec 549 90.5 KBytes [ 5] 7.00-8.00 sec 116 MBytes 976 Mbits/sec 964 198 KBytes [ 5] 8.00-9.00 sec 114 MBytes 956 Mbits/sec 591 76.4 KBytes [ 5] 9.00-10.00 sec 108 MBytes 908 Mbits/sec 736 120 KBytes [ 5] 10.00-11.00 sec 105 MBytes 881 Mbits/sec 689 126 KBytes [ 5] 11.00-12.00 sec 106 MBytes 893 Mbits/sec 745 124 KBytes [ 5] 12.00-13.00 sec 118 MBytes 990 Mbits/sec 847 93.3 KBytes [ 5] 13.00-14.00 sec 122 MBytes 1.03 Gbits/sec 899 94.7 KBytes [ 5] 14.00-15.00 sec 125 MBytes 1.05 Gbits/sec 1014 73.5 KBytes [ 5] 15.00-16.00 sec 125 MBytes 1.05 Gbits/sec 973 113 KBytes [ 5] 16.00-17.00 sec 109 MBytes 915 Mbits/sec 934 86.3 KBytes [ 5] 17.00-18.00 sec 101 MBytes 844 Mbits/sec 629 115 KBytes [ 5] 18.00-19.00 sec 105 MBytes 881 Mbits/sec 652 122 KBytes [ 5] 19.00-20.00 sec 116 MBytes 971 Mbits/sec 826 96.2 KBytes [ 5] 20.00-21.00 sec 115 MBytes 962 Mbits/sec 820 99.0 KBytes [ 5] 21.00-22.00 sec 128 MBytes 1.08 Gbits/sec 1193 99.0 KBytes [ 5] 22.00-23.00 sec 130 MBytes 1.09 Gbits/sec 1027 110 KBytes [ 5] 23.00-24.00 sec 123 MBytes 1.03 Gbits/sec 855 116 KBytes [ 5] 24.00-25.00 sec 122 MBytes 1.03 Gbits/sec 714 126 KBytes [ 5] 25.00-26.00 sec 120 MBytes 1.01 Gbits/sec 861 119 KBytes [ 5] 26.00-27.00 sec 129 MBytes 1.08 Gbits/sec 768 112 KBytes [ 5] 27.00-28.00 sec 125 MBytes 1.05 Gbits/sec 976 140 KBytes [ 5] 28.00-29.00 sec 116 MBytes 972 Mbits/sec 943 140 KBytes [ 5] 29.00-30.00 sec 119 MBytes 996 Mbits/sec 755 116 KBytes - - - - - - - - - - - - - - - - - - - - - - - - - [ ID] Interval Transfer Bitrate Retr [ 5] 0.00-30.00 sec 3.39 GBytes 970 Mbits/sec 24811 sender [ 5] 0.00-30.00 sec 3.39 GBytes 970 Mbits/sec receiver La velocidad media de la red ha sido de 970 Mbits/sec , sin usar ninguna VPN .\nVelocidad de Wireguard Vemos a medir la velocidad de Wireguard :\njaviercruces@cliente3:~$ iperf3 -c 192.168.0.2 -i 1 -t 30 Connecting to host 192.168.0.2, port 5201 [ 5] local 192.168.1.2 port 39096 connected to 192.168.0.2 port 5201 [ ID] Interval Transfer Bitrate Retr Cwnd [ 5] 0.00-1.00 sec 57.5 MBytes 483 Mbits/sec 63 196 KBytes [ 5] 1.00-2.00 sec 56.4 MBytes 473 Mbits/sec 37 190 KBytes [ 5] 2.00-3.00 sec 58.2 MBytes 488 Mbits/sec 85 188 KBytes [ 5] 3.00-4.00 sec 57.1 MBytes 479 Mbits/sec 65 140 KBytes [ 5] 4.00-5.00 sec 57.8 MBytes 485 Mbits/sec 6 199 KBytes [ 5] 5.00-6.00 sec 59.7 MBytes 500 Mbits/sec 62 200 KBytes [ 5] 6.00-7.00 sec 59.0 MBytes 495 Mbits/sec 26 234 KBytes [ 5] 7.00-8.00 sec 57.8 MBytes 485 Mbits/sec 13 216 KBytes [ 5] 8.00-9.00 sec 58.6 MBytes 492 Mbits/sec 88 151 KBytes [ 5] 9.00-10.00 sec 58.1 MBytes 487 Mbits/sec 13 174 KBytes [ 5] 10.00-11.00 sec 57.9 MBytes 486 Mbits/sec 22 135 KBytes [ 5] 11.00-12.00 sec 57.1 MBytes 479 Mbits/sec 30 188 KBytes [ 5] 12.00-13.00 sec 57.3 MBytes 481 Mbits/sec 19 178 KBytes [ 5] 13.00-14.00 sec 57.1 MBytes 479 Mbits/sec 15 230 KBytes [ 5] 14.00-15.00 sec 56.5 MBytes 474 Mbits/sec 20 218 KBytes [ 5] 15.00-16.00 sec 57.4 MBytes 481 Mbits/sec 38 172 KBytes [ 5] 16.00-17.00 sec 55.9 MBytes 469 Mbits/sec 137 143 KBytes [ 5] 17.00-18.00 sec 57.0 MBytes 478 Mbits/sec 26 246 KBytes [ 5] 18.00-19.00 sec 56.6 MBytes 475 Mbits/sec 42 183 KBytes [ 5] 19.00-20.00 sec 56.2 MBytes 471 Mbits/sec 43 222 KBytes [ 5] 20.00-21.00 sec 56.5 MBytes 474 Mbits/sec 11 203 KBytes [ 5] 21.00-22.00 sec 56.4 MBytes 473 Mbits/sec 69 147 KBytes [ 5] 22.00-23.00 sec 54.1 MBytes 454 Mbits/sec 25 163 KBytes [ 5] 23.00-24.00 sec 55.9 MBytes 469 Mbits/sec 54 207 KBytes [ 5] 24.00-25.00 sec 57.5 MBytes 482 Mbits/sec 99 164 KBytes [ 5] 25.00-26.00 sec 56.5 MBytes 474 Mbits/sec 39 182 KBytes [ 5] 26.00-27.00 sec 56.7 MBytes 476 Mbits/sec 24 150 KBytes [ 5] 27.00-28.00 sec 56.3 MBytes 472 Mbits/sec 6 219 KBytes [ 5] 28.00-29.00 sec 57.0 MBytes 478 Mbits/sec 15 146 KBytes [ 5] 29.00-30.00 sec 56.0 MBytes 470 Mbits/sec 48 151 KBytes - - - - - - - - - - - - - - - - - - - - - - - - - [ ID] Interval Transfer Bitrate Retr [ 5] 0.00-30.00 sec 1.67 GBytes 479 Mbits/sec 1240 sender [ 5] 0.00-30.00 sec 1.67 GBytes 479 Mbits/sec receiver La velocidad media de wireguard ha sido de 479 Mbits/sec .\nVelocidad de OpenVPN Vamos a medir la velocidad de OpenVPN\njaviercruces@cliente3:~$ iperf3 -c 192.168.0.2 -i 1 -t 30 Connecting to host 192.168.0.2, port 5201 [ 5] local 192.168.1.2 port 43522 connected to 192.168.0.2 port 5201 [ ID] Interval Transfer Bitrate Retr Cwnd [ 5] 0.00-1.00 sec 25.1 MBytes 211 Mbits/sec 24 139 KBytes [ 5] 1.00-2.00 sec 24.8 MBytes 208 Mbits/sec 15 163 KBytes [ 5] 2.00-3.00 sec 23.7 MBytes 199 Mbits/sec 40 103 KBytes [ 5] 3.00-4.00 sec 24.6 MBytes 207 Mbits/sec 19 114 KBytes [ 5] 4.00-5.00 sec 24.2 MBytes 203 Mbits/sec 8 119 KBytes [ 5] 5.00-6.00 sec 24.3 MBytes 204 Mbits/sec 14 155 KBytes [ 5] 6.00-7.00 sec 24.2 MBytes 203 Mbits/sec 13 139 KBytes [ 5] 7.00-8.00 sec 24.5 MBytes 206 Mbits/sec 18 115 KBytes [ 5] 8.00-9.00 sec 24.0 MBytes 201 Mbits/sec 34 132 KBytes [ 5] 9.00-10.00 sec 24.3 MBytes 204 Mbits/sec 32 120 KBytes [ 5] 10.00-11.00 sec 24.5 MBytes 206 Mbits/sec 12 100 KBytes [ 5] 11.00-12.00 sec 24.4 MBytes 205 Mbits/sec 8 139 KBytes [ 5] 12.00-13.00 sec 23.9 MBytes 201 Mbits/sec 6 171 KBytes [ 5] 13.00-14.00 sec 24.1 MBytes 202 Mbits/sec 20 156 KBytes [ 5] 14.00-15.00 sec 24.0 MBytes 202 Mbits/sec 8 135 KBytes [ 5] 15.00-16.00 sec 23.5 MBytes 197 Mbits/sec 21 143 KBytes [ 5] 16.00-17.00 sec 24.0 MBytes 202 Mbits/sec 8 168 KBytes [ 5] 17.00-18.00 sec 24.6 MBytes 206 Mbits/sec 24 154 KBytes [ 5] 18.00-19.00 sec 23.8 MBytes 200 Mbits/sec 21 132 KBytes [ 5] 19.00-20.00 sec 24.3 MBytes 204 Mbits/sec 20 139 KBytes [ 5] 20.00-21.00 sec 24.6 MBytes 206 Mbits/sec 11 142 KBytes [ 5] 21.00-22.00 sec 23.0 MBytes 193 Mbits/sec 26 115 KBytes [ 5] 22.00-23.00 sec 24.6 MBytes 207 Mbits/sec 3 128 KBytes [ 5] 23.00-24.00 sec 24.0 MBytes 202 Mbits/sec 26 104 KBytes [ 5] 24.00-25.00 sec 24.3 MBytes 204 Mbits/sec 21 106 KBytes [ 5] 25.00-26.00 sec 24.3 MBytes 204 Mbits/sec 15 108 KBytes [ 5] 26.00-27.00 sec 23.8 MBytes 200 Mbits/sec 36 132 KBytes [ 5] 27.00-28.00 sec 22.9 MBytes 192 Mbits/sec 13 118 KBytes [ 5] 28.00-29.00 sec 23.7 MBytes 199 Mbits/sec 19 163 KBytes [ 5] 29.00-30.00 sec 24.2 MBytes 203 Mbits/sec 11 126 KBytes - - - - - - - - - - - - - - - - - - - - - - - - - [ ID] Interval Transfer Bitrate Retr [ 5] 0.00-30.00 sec 725 MBytes 203 Mbits/sec 546 sender [ 5] 0.00-30.00 sec 724 MBytes 202 Mbits/sec receiver La velocidad media ha sido 203 Mbits/sec .\nConclusiones Si comparamos los resultados, queda claro que en términos de velocidad, WireGuard ha demostrado ser la opción más eficiente, superando significativamente a OpenVPN , doblándolo en velocidad .\nWireGuard está diseñado para una velocidad rápida. Establece una conexión en 100 milisegundos, mientras que OpenVPN tarda 8 milisegundos. En algunas pruebas, WireGuard demostró ser un 58% más rápido que OpenVPN. En circunstancias ideales, su velocidad superó los 500 mbps.\nWireGuard es el protocolo más rápido debido a muchos factores. Estos incluyen:\nSu código ligero lo convierte intrínsecamente en el protocolo más rápido. WireGuard también admite el multithreading -procesar datos utilizando muchos núcleos de la CPU simultáneamente- y utiliza un método de cifrado más rápido. Además, WireGuard es bueno en el uso del ancho de banda disponible y opera completamente en el espacio del kernel. Para evitar la censura, OpenVPN es mejor que WireGuard. ¿Por qué? Porque el protocolo OpenVPN puede funcionar sobre las capas del Protocolo UPD y TCP.\nUDP es más rápido, mientras que TCP es fiable.TCP puede evitar la censura utilizando el puerto 443, el mismo puerto que utiliza HTTPS. Gracias a TCP, OpenVPN evita la censura de países estrictos como China y Rusia. En algunos casos, una inspección profunda avanzada puede detectar OpenVPN. Pero para estos casos, los expertos en seguridad recomiendan utilizar el Scramble dentro de la configuración avanzada del protocolo para añadir otra capa de protección al tráfico VPN.\nPor otro lado, WireGuard sólo utiliza la capa UDP para transportar datos. Y el propósito principal de UDP es transportar datos a gran velocidad, no eludir la censura. Esto hace que sea fácil de detectar. Además, es susceptible de inspección profunda de paquetes.\nOpenVPN es seguro si se configura adecuadamente. Este protocolo no tiene vulnerabilidades de seguridad conocidas, y su código ha sido auditado muchas veces. Además, tiene muchos cifrados y algoritmos de autenticación. Cuando se produce alguna vulnerabilidad de seguridad en el algoritmo, entonces OpenVPN puede configurar inmediatamente otra cosa.\nEn términos de casos de seguridad, WireGuard también se ha ganado una buena reputación. Es seguro y utiliza la última criptografía. Su código es corto y fácil de auditar. Además, WireGuard tiene un conjunto fijo de algoritmos y cifrados. Cuando se encuentra alguna vulnerabilidad, todos los puntos finales se actualizan a una nueva versión, lo que garantiza que nadie vuelva a utilizar código inseguro.\n","date":"March 28, 2024","hero":"/images/vpn/wire_ovpn.png","permalink":"https://www.javiercd.es/posts/vpn/comparativa_ovpn_wire/comparativa_ovpn_wire/","summary":"El objetivo de este post es comparar los distintos software de VPNs mas utilizados viendo cual es mas rápido , para ello nos apoyaremos en test de velocidad utilizando iperf3 .\n[!NOTE]\nLa comparativa parte de los post de esta sección en los que montamos cada tipo de VPN .\nVelocidad sin VPN Voy a comenzar comparando las velocidades de estos 2 sistemas , utilizando iperf3 . Para ello he quitado el router cisco ya que lo tenia configurado con interfaces FastEthernet y lo he cambiado por un router Linux con interfaces GigabitEthernet .","tags":["VPN","LINUX","DEBIAN","WIREGUARD","OPENVPN"],"title":"Comparativa entre OpenVPN y Wireguard"},{"categories":null,"contents":" Equivalencia de GUI a CLI Inicialmente, empecé la práctica utilizando la línea de comandos (CLI) sin embargo, encontré que resulta más cómodo realizarla desde la interfaz gráfica. Por eso, decidí establecer una equivalencia entre las diferentes acciones que he llevado a cabo durante la práctica y compararlas con su contraparte en la terminal.\n[!NOTE]\nEn este post hago un pequeño resumen de las equivalencias entre la GUI y la CLI de Fortinet que he utilizado en los 2 post de cortafuegos Fortinet.\nConfigurar una interfaz Como ya tenemos el cortafuegos configurado tenemos 2 opciones a la hora de ver la configuración de una determinada interfaz .\nVer la configuración de todas las interfaces :\nshow system interface O especificar una en concreto :\nshow system interface port1 Si observamos la configuración de las tres interfaces que he establecido durante la práctica, podemos notar que la sintaxis es muy sencilla. Prácticamente, incluso sin tener conocimientos previos sobre el tema, es fácil de comprender.\nFTG # show system interface config system interface edit \u0026#34;port1\u0026#34; set vdom \u0026#34;root\u0026#34; set ip 192.168.122.77 255.255.255.0 set allowaccess https http fgfm set type physical set alias \u0026#34;WAN\u0026#34; set lldp-reception enable set role wan set snmp-index 1 next edit \u0026#34;port2\u0026#34; set vdom \u0026#34;root\u0026#34; set ip 192.168.100.1 255.255.255.0 set allowaccess ping https ssh http fgfm set type physical set alias \u0026#34;LAN\u0026#34; set device-identification enable set lldp-transmission enable set monitor-bandwidth enable set role lan set snmp-index 2 next edit \u0026#34;port3\u0026#34; set vdom \u0026#34;root\u0026#34; set ip 192.168.200.1 255.255.255.0 set type physical set alias \u0026#34;DMZ\u0026#34; set device-identification enable set lldp-transmission enable set role lan set snmp-index 3 next Como puedes ver en la interfaz puerto 1 que es la que corresponde a la WAN , anteriormente desactive el acceso para configurarlo desde esta interfaz , pero por comodidad lo he dejado activado para usar el navegador de mi portátil .\nUna configuración que nos puede interesar es configurar una interfaz por DHCP , en mi caso lo haré en el puerto 4 :\n# Accedemos al modo de configuración FTG # config system interface # Seleccionamos la interfaz 4 FTG (interface) # edit \u0026#34;port4\u0026#34; # La ponemos en modo DHCP FTG (port4) # set mode dhcp # Salimos del modo de configuración FTG (port4) # end Ahora si listamos la configurar de la interfaz se habrá aplicado el cambio :\nFTG # show system interface port4 config system interface edit \u0026#34;port4\u0026#34; set vdom \u0026#34;root\u0026#34; set mode dhcp set type physical set snmp-index 4 next end En este punto, observamos que los comandos que hemos utilizado coinciden con los que el sistema muestra al listar la configuración.\nAhora, lo que nos interesa es conocer la dirección IP de nuestra interfaz. Si deseamos listar todas las direcciones IP asignadas, simplemente no especificamos el nombre de la interfaz. En mi caso, me interesa saber la dirección IP de la interfaz del puerto 4:\nFTG # get system interface physical port4 == [onboard] ==[port4] mode: dhcp ip: 192.168.122.121 255.255.255.0 ipv6: ::/0 status: up speed: 1000Mbps (Duplex: full) FEC: none FEC_cap: none Esto es lo básico que necesitamos para comenzar a configurar las interfaces . Te dejo un enlace a la documentación oficial donde explica todos los detalles .\nPolíticas Lo siguiente que hemos realizado en la practica es crear reglas desde la CLI , así que comenzare listando las reglas existentes , recuerda que en la versión de prueba tenemos un limite de 10 reglas simultaneas así que he eliminado algunas reglas durante la realización de la misma .\nPara hacer la salida mas legible vamos a ver una regla \u0026ldquo;normal\u0026rdquo; y otra de DNAT para compararlas :\nFTG # show firewall policy config firewall policy edit 1 set name \u0026#34;LAN_WAN_SSH\u0026#34; set uuid 57bba290-e881-51ee-3bbe-3ba5903773ed set srcintf \u0026#34;port2\u0026#34; set dstintf \u0026#34;port1\u0026#34; set action accept set srcaddr \u0026#34;all\u0026#34; set dstaddr \u0026#34;all\u0026#34; set schedule \u0026#34;always\u0026#34; set service \u0026#34;SSH\u0026#34; set nat enable next edit 5 set name \u0026#34;WAN_LAN_DNAT_SSH\u0026#34; set uuid bdd84292-e884-51ee-a5d3-20eabb2fd433 set srcintf \u0026#34;port1\u0026#34; set dstintf \u0026#34;port2\u0026#34; set action accept set srcaddr \u0026#34;all\u0026#34; set dstaddr \u0026#34;DNAT_SSH\u0026#34; set schedule \u0026#34;always\u0026#34; set service \u0026#34;SSH\u0026#34; set utm-status enable set ssl-ssh-profile \u0026#34;certificate-inspection\u0026#34; set ips-sensor \u0026#34;block_xmas\u0026#34; set nat enable next Vemos que la salida es bastante clara , si nos paramos a ver los parámetros comunes :\nname: Nombre que le queremos dar a la regla . UUID: Un identificador único que le asigna automáticamente el FW a cada regla . srcintf: Interfaz de origen (Por donde entra el trafico) dstintf: Interfaz de origen (Por donde entra el trafico) action: Que acción queremos que haga la regla accept | deny . srcaddr: Dirección de origen dstaddr: Dirección de destino schedule: Programación de la regla , por si es una regla temporal esta solo estará activa durante cierto tiempo . service: Nombre del servicio (Va asignado a un numero de puerto) nat: Si queremos que la regla haga SNAT . Esto seria la sintaxis básica de cada regla como ves entre una regla \u0026ldquo;normal\u0026rdquo; y una de DNAT lo único que cambia es la dirección del trafico y la IP de destino que en este dispositivo es una IP virtual .\nSi queremos borrar una regla , haremos lo siguiente :\n# Accedemos al modo de configuracion de las politicas de seguridad FTG # config firewall policy # Borraremos la regla segun el id de la misma FTG (policy) # delete 2 # Salimos de la configuracion FTG (policy) # end Para añadir una nueva regla, la sintaxis es similar a cuando listamos las reglas, pero necesitamos especificar un número de identificación (ID) al crearla. Es recomendable que sepas el número de la última regla que añadiste. Si no indicas un número, no se creará una nueva regla.\nFTG#config firewall policy FTG (policy) # edit 12 new entry \u0026#39;12\u0026#39; added FTG (12) # set name \u0026#34;LAN_WAN_DNS\u0026#34; FTG (12) # set srcintf \u0026#34;port2\u0026#34; FTG (12) # set dstintf \u0026#34;port1\u0026#34; FTG (12) # set action accept FTG (12) # set srcaddr \u0026#34;all\u0026#34; FTG (12) # set dstaddr \u0026#34;Google_DNS\u0026#34; FTG (12) # set schedule \u0026#34;always\u0026#34; FTG (12) # set service \u0026#34;DNS\u0026#34; FTG (12) # set nat enable FTG (12) # next FTG (policy) # end Hay muchísimas mas opciones que ignoro que no ha sido necesarias utilizarlas en la practica , te dejo un enlace a la documentación oficial donde detalla todas las distintas opciones .\nServicios Los servicios son unos objetos los cuales almacenan un numero o conjunto de puertos los cuales posteriormente utilizaras al crear reglas .Aunque estos dispositivos vienen con los servicios mas comunes de fabrica , muchas veces es necesario que creemos uno nuevo acorde a nuestras necesidades .\nAl igual que con los comandos anteriores de listar , podemos listar todos los servicios o uno en concreto :\nFTG # show firewall service custom config firewall service custom edit \u0026#34;DNS\u0026#34; set category \u0026#34;Network Services\u0026#34; set tcp-portrange 53 set udp-portrange 53 next edit \u0026#34;HTTP\u0026#34; set category \u0026#34;Web Access\u0026#34; set tcp-portrange 80 next edit \u0026#34;HTTPS\u0026#34; set category \u0026#34;Web Access\u0026#34; set tcp-portrange 443 next FTG # show firewall service custom SSH_2222 config firewall service custom edit \u0026#34;SSH_2222\u0026#34; set category \u0026#34;Remote Access\u0026#34; set tcp-portrange 2222 next end Para borrar un servicio , seguiremos los siguientes pasos :\n# Accedemos a la configuración de los servicios FTG # config firewall service custom # Borramos el servicio indicando el nombre FTG (custom) # delete SSH_2222 # Salimos del modo de configuración FTG (custom) # end Si queremos crearlo seguiremos los siguientes pasos :\n# Accedemos a la configuración de los servicios FTG # config firewall service custom # Le asignamos un nombre FTG (custom) # edit SSH_2222 # Opcionalmente lo añadimos a una categoria FTG (SSH_2222) # set category \u0026#34;Remote Access\u0026#34; # Indicamos los puertos que hace referencia al mismo FTG (SSH_2222) # set tcp-portrange 2222 # Guardamos y salimos del modo de confuguración FTG (SSH_2222) # next FTG (custom) # end Te dejo un enlace a la documentación oficial referente a los servicios donde explica con detalle todas las opciones de los mismos .\nIPs Virtuales Las IP Virtuales Estáticas (VIP) se utilizan para mapear direcciones IP externas a direcciones IP internas. Esto también se llama DNAT, donde el destino de un paquete se está enviando a una dirección diferente.\nLas VIP estáticas se utilizan comúnmente para mapear direcciones IP públicas a recursos detrás del FortiGate que utilizan direcciones IP privadas. Una VIP estática uno a uno es cuando se mapea todo el rango de puertos. Una VIP de reenvío de puertos es cuando el mapeo se configura en un puerto específico o rango de puertos.\nSi queremos listar las diferentes IPs virtuales que tenemos usaremos el siguiente comando , si solo queremos listar una en concreta indicaremos su nombre :\nFTG # show firewall vip config firewall vip edit \u0026#34;DNAT_POSTFIX\u0026#34; set uuid a343ec4a-e881-51ee-0ec1-ad73db3ff299 set service \u0026#34;SMTP\u0026#34; set extip 192.168.100.1 set mappedip \u0026#34;192.168.200.2\u0026#34; set extintf \u0026#34;port2\u0026#34; next edit \u0026#34;DNAT_SSH\u0026#34; set uuid a2b62344-e884-51ee-1a11-8946fda2bd91 set service \u0026#34;SSH_2222\u0026#34; set extip 192.168.122.77 set mappedip \u0026#34;192.168.100.2\u0026#34; set extintf \u0026#34;port1\u0026#34; set portforward enable set mappedport 22 next FTG # show firewall vip DNAT_HELA_WEB config firewall vip edit \u0026#34;DNAT_HELA_WEB\u0026#34; set uuid a417a8f8-edf6-51ee-f601-43829c174966 set service \u0026#34;HTTP\u0026#34; set extip 192.168.122.77 set mappedip \u0026#34;192.168.200.2\u0026#34; set extintf \u0026#34;port1\u0026#34; next end En el caso de que queramos eliminar una de estas IPs virtuales , seguiremos los siguientes pasos :\n# Accedemos al modo de configuración FTG # config firewall vip # Borramos la IP virtual indicando su nombre FTG (vip) # delete DNAT_HELA_WEB # Salimos del modo de configuración FTG (vip) # end Por otro lado para crear una de estas , como hemos realizado desde la GUI seguiremos los siguientes pasos :\n# Accedemos al modo de configuración FTG # config firewall vip # Le asignamos el nombre que deseemos FTG (vip) # edit DNAT_HELA_WEB # Indicamos opcionalmente sobre el servicio que sera usado esta IP virtual FTG (DNAT_HELA_WEB) # set service \u0026#34;HTTP\u0026#34; # Indicamos la Ip externa FTG (DNAT_HELA_WEB) # set extip 192.168.122.77 # Indicamos la Ip interna FTG (DNAT_HELA_WEB) # set mappedip \u0026#34;192.168.200.2\u0026#34; # Indicamos la interfaz externa FTG (DNAT_HELA_WEB) # set extintf \u0026#34;port1\u0026#34; # Guardamos y salimos FTG (DNAT_HELA_WEB) # next FTG (vip) # end Las IP virtuales tienen mas parámetros de configuración que no he utilizado en la practica , te dejo un enlace a la documentación oficial donde detalla toda la configuración que podemos acceder con las mismas .\nRutas estáticas Nuestro dispositivo necesita conocer hacia donde enviar el trafico , para esto existen las rutas estáticas .\nPara listar las rutas que tiene configurado nuestro cortafuegos , usaremos el siguiente comando :\nFTG # show router static config router static edit 1 set gateway 192.168.122.1 set device \u0026#34;port1\u0026#34; next end Al igual que hemos hecho anteriormente , si queremos eliminar esta ruta por defecto seguiremos los siguientes pasos :\nFTG # config router static FTG (static) # delete 1 FTG (static) # end Si queremos añadir una ruta , puedes utilizar este ejemplo :\nFTG # config router static FTG (static) # edit 1 # El siguiete salto o puerta de enlace FTG (1) # set gateway 192.168.122.1 # La interfaz por donde saldra el trafico FTG (1) # set device \u0026#34;port1\u0026#34; FTG (1) # next FTG (static) # end ","date":"March 28, 2024","hero":"/images/cortafuegos/fortinet.png","permalink":"https://www.javiercd.es/posts/cortafuegos/fortinet_cli/fortinet_cli/","summary":"Equivalencia de GUI a CLI Inicialmente, empecé la práctica utilizando la línea de comandos (CLI) sin embargo, encontré que resulta más cómodo realizarla desde la interfaz gráfica. Por eso, decidí establecer una equivalencia entre las diferentes acciones que he llevado a cabo durante la práctica y compararlas con su contraparte en la terminal.\n[!NOTE]\nEn este post hago un pequeño resumen de las equivalencias entre la GUI y la CLI de Fortinet que he utilizado en los 2 post de cortafuegos Fortinet.","tags":["FIREWALL","FORTINET"],"title":"Fortinet CLI"},{"categories":null,"contents":" Antes de comenzar la practica , el escenario que ves en la practica es lo mas parecido que puedo montar a la practica original . He utilizado la versión 7.0.9-1 de FortiGate , ya que las versiones superiores traen algunas restricciones . Puedes descargarte la imagen desde este link .\nPuesta en marcha del cortafuegos Los dispositivos FortiGate vienen configurados de fabrica con la IP 192.168.1.99/24 , como estoy desde GNS3 no es necesario que me conecte a esta interfaz con un dispositivo y cambie la configuración . Ya que puedo hacerlo desde la consola .\nPor defecto a través de ese puerto esta habilitada la administración por http , https , ssh y telnet .\nEn mi caso me conectare desde la consola , le cambiare el hostname y configurare el puerto 1 para que coja IP por DHCP .\nEl usuario por defecto es admin y la contraseña en blanco . Cuando iniciemos sesión por primera vez nos obligara a cambiarla :\nFortiGate-VM64-KVM login: admin Password: You are forced to change your password. Please input a new password. New Password: Confirm Password: Welcome! Lo primero que haré sera cambiarle el hostname , como ves es similar a cisco ya que tenemos un modo de configuración :\nFortiGate-VM64-KVM # conf sys global FortiGate-VM64-KVM (global) # set hostname FGT FortiGate-VM64-KVM (global) # end Ahora vamos a configurar el puerto 1 por DHCP para que así desde el cliente 2 lo pueda configurar sin tener que manualmente cambiar la IP del mismo . Ademas voy a configurar el acceso por http y https para poder configurarlo desde un navegador :\nFGT # show system interface port1 config system interface edit \u0026#34;port1\u0026#34; set vdom \u0026#34;root\u0026#34; set mode dhcp set allowaccess ping https ssh http fgfm set type physical set snmp-index 1 next end Ahora vamos a ver la IP que el DHCP le ha asignado con el siguiente comando :\nFGT # get system interface == [ port1 ] name: port1 mode: dhcp ip: 192.168.122.77 255.255.255.0 status: up netbios-forward: disable type: physical ring-rx: 0 ring-tx: 0 netflow-sampler: disable sflow-sampler: disable src-check: enable explicit-web-proxy: disable explicit-ftp-proxy: disable proxy-captive-portal: disable mtu-override: disable wccp: disable drop-overlapped-fragment: disable drop-fragment: disable Ahora desde cualquier maquina que tenga acceso a la red \u0026rsquo;externa\u0026rsquo; podremos conectarnos al FW :\nCuando te inicies sesión veras un panel con información general sobre el estado dispositivo :\nConfiguración de la red LAN Como has visto en la imagen de la topología, la red LAN está conectada al puerto 2. Por lo tanto, procederemos a configurarlo.\nVamos a dirigirnos a Network \u0026gt; Interfaces , selecciona el puerto 2 y pulsa en editar en la barra superior :\nUna vez dentro de la pantalla de configuración de la interfaz, puedes personalizar el puerto asignándole un alias. Además, para facilitar la gestión futura, le he asignado el rol LAN al puerto2, indicando que será utilizado para una red local. Posteriormente, he configurado la dirección IP del mismo, asignándole la 192.168.100.1/24. Además, he creado un objeto con esa IP, lo que facilitará la referencia a esta dirección IP en futuras configuraciones, eliminando la necesidad de recordar la IP .\nSigamos con la configuración de la interfaz. Desde la red LAN, donde estaremos la mayor parte del tiempo, permitiré el acceso vía HTTPS y SSH para configurar el FortiGate. También dejaré que respondan a los pings para asegurarme la conectividad con el mismo. Además, cada interfaz puede ser un servidor DHCP, así que le configurare uno para la LAN. Por último, activaré la opción para detectar dispositivos, así tendré control sobre quién se conecta a la red.\nUna vez configurado el acceso administrativo desde la LAN , voy a quitar el acceso administrativo desde la interfaz puerto 1 ya que esta seria Internet (WAN).\nAsí que le cambiare el ROL a WAN y le quitare el acceso administrativo :\nSi recuerdas anteriormente marcamos en la interfaz LAN la casilla Device connection , si queremos ver los dispositivos conectados a esta red accedemos a Security Fabric \u0026gt; Asset Identify Center :\nPara apartados posteriores , como voy a realizar la practica de cortafuegos de nodo , es interesante crear un objeto con ese host . Así no sera necesario que recuerde su IP :\nAunque no he mencionado nada anteriormente , la política por defecto de estos dispositivos es DROP en todas las direcciones :\nAhora vamos a crear una nueva política que permita el tráfico desde la LAN hacia Internet (WAN) en cualquier dirección. Esta política sería similar a las que tenemos en casa, donde podemos acceder a cualquier sitio web. Además, desde aquí podemos decir que haga SNAT, lo que nos permitirá navegar acceder a Internet. También podremos configurar hacia qué interfaz se realizará este SNAT.\nPara acabar con la configuración inicial , crearemos la ruta por defecto para salir a Internet . Para ello nos iremos a Network \u0026gt; Static Routes :\nUna vez aplicada esta política ya podremos comenzar a realizar la practica , ademas podemos acceder a Internet desde el cliente 1 :\nReglas del cortafuegos Para comenzar desactivare la política anterior , la editare y al final de esta le quitare el tic que la activa :\nQuedando así inactiva :\nLos equipos de la red local deben poder tener conexión al exterior. Para configurar el SNAT en dispositivos FortiGate , es un poco distinto ya que en cada regla que vayamos a permitir tendremos que marcar la casilla si queremos hacer NAT .\nAdemas podemos especificar todas las opciones posibles que se nos ocurra , en mi caso dejare este apartado sin activar y lo iré haciendo en las reglas siguientes . La imagen que ves a continuación es para indicarte donde se activaría . Ademas podemos indicar porque interfaz queremos que salga el trafico . Esto es útil si tenemos dos o mas salidas de Internet para hacer un balanceador de carga .\nUna vez aquí dentro de la configuración de la interfaz le decimos que la interfaz es de tipo NAT , ademas podemos indicarle que no haga PAT .\nPermitimos hacer ping desde la LAN a la máquina cortafuegos. En estos dispositivos no seria una regla como tal , si no que esta opción en concreto se indica desde la opción de acceso administrativo de la interfaz :\nUna vez aplicado , si nos vamos al cliente 1 podremos hacerle ping al cortafuegos :\nPermite realizar conexiones ssh desde los equipos de la LAN Crearemos la regla que permite el trafico SSH , aqui en el origen podemos poner o el cliente1 (creamos el objeto en la preparación del escenario) o directamente poner all en el origen :\nAunque actualmente en mi esquema solo tenga un cliente , ceñiendome al enunciado si quiero que TODOS los cliente de la red LAN puedan hacer ssh en origen tengo que permitir todos :\nComo te explique en el apartado a de la practica , en este tipos de dispositivo tenemos que indicarle si queremos que la regla sea de tipo NAT para que haga SNAT o no .\nUna vez aplicada la regla podremos conectarnos por ssh desde el cliente1:\nVamos a asegurarnos de que la regla tiene hits :\nPermite la navegación en la red LAN Para ello vamos a crear 2 reglas para la red LAN . Una que permita hacer consultas DNS y otra para permitir el trafico HTTPS y HTTP , ademas en ambas reglas sera necesario indicar que se haga NAT .\nComo te has fijado no he indicado el numero de puerto , si no que estos dispositivos tienen unos objetos llamados servicios en los cuales se almacenan los números de puerto de los mismos . Podemos crear los objetos que queramos y personalizar los existentes según nuestras necesidades .\nVamos a comprobar que podemos navegar en el cliente 1 :\nNi que decir tiene que por supuesto que podemos hacer un dig , con la regla actual lo podemos hacer a cualquier servidor DNS :\nVamos a comprobar que tenemos hits en las reglas :\nInstala un servidor de correos en la máquina de la LAN. Permite el acceso desde el exterior y desde el cortafuegos al servidor de correos. Para probarlo puedes ejecutar un telnet al puerto 25 tcp. Como actualmente tenemos permitido la navegación solo por https es fundamental que los repositorios de la maquina estén configurados podremos instalar paquetes en nuestro cliente , asi que vamos a instalar postfix :\nsudo apt update \u0026amp;\u0026amp; sudo apt install postfix -y Ahora vamos a configurar la primera regla de DNAT que vamos a tener en el escenario . Para ello tendremos que crear una IP virtual y decirle cual es la IP externa (WAN) y la IP donde vamos a hacer el DNAT (LAN) .\nAhora vamos a añadir la regla en nuestra política , en el destino de la regla indicaremos la IP virtual que acabamos de crear y indicamos el servicio SMTP que tiene configurado el puerto 25 TCP :\nY vamos a comprobar que desde un cliente externo , como es Cliente 2 podemos acceder a Cliente 1 :\nVamos a comprobar que la regla que acabamos de crear tiene hits :\nPermite hacer conexiones ssh desde exterior a la LAN Para realizar esto volveremos a hacer un DNAT , tendremos que volver a crear una nueva IP virtual ya que anteriormente especifique que esa IP solo se utilizaba para el protocolo SMTP . Así que voy a crear una nueva :\nUna vez creada la nueva IP virtual para el ssh , crearemos la regla de DNAT :\nVamos a probar nuestra nueva regla desde el cliente 2 :\nVamos a comprobar los hits de nuestra nueva regla :\nModifica la regla anterior, para que al acceder desde el exterior por ssh tengamos que conectar al puerto 2222, aunque el servidor ssh este configurado para acceder por el puerto 22. Para realizar esto tendremos que generar un nuevo servicio que este en el puerto 2222 :\nAhora vamos a modificar nuestra IP virtual modificando el servicio por el nuevo que hemos creado con el puerto 2222 y haremos un port forwarding al puerto 22 :\nUna vez hecho esto podremos acceder por ssh utilizando el puerto 2222 y que nos redirija al 22 . No es necesario que modifiquemos las reglas , solo con esto ya podremos acceder :\nVamos a comprobar los hits de las reglas , ademas en el apartado de Virtual IP también tenemos un contador de hits :\nPermite hacer consultas DNS desde la LAN sólo al servidor 8.8.8.8. Comprueba que no puedes hacer un dig @1.1.1.1. Para esto vamos a modificar la regla que permite las consultas DNS y vamos a indicar que el destino solo sea 8.8.8.8 .\nPrimero necesitaremos crear un nuevo objeto con la IP del servidor DNS de Google :\nAhora modificamos la regla y pondremos este objeto como destino :\nVamos a comprobar la modificación de la regla , para que solo podamos hacer consultas dns a 8.8.8.8 :\nPodemos comprobar que los hits han subido :\nPermite que los equipos de la LAN puedan navegar por internet, excepto a la página www.realbetisbalompie.es Estos cortafuegos de nueva generación traen una serie de servicios que nos filtran en el nivel de aplicación que nos permite detectar palabras clave para filtrar el contenido (drogas , pornografía , armas \u0026hellip; ) , en este cortafuegos el filtrar por palabras clave es un servicio de pago , hay que pagar una licencia . Ademas nos permite crear filtros para bloquear ciertas paginas web , que en este caso es gratuito.\nLo primero sera crear nuestra política de filtro_web :\nY añadimos en la misma un nuevo filtro por URL :\nAhora nos dirigimos a la regla que nos permite el trafico https y en seguridad le añadimos el filtro web que acabamos de crear :\nA la izquierda accederé desde el navegador de mi maquina física y puedo acceder a la pagina del maligno , sin embargo si accedo desde el cliente 1 el firewall no nos deja acceder :\nSi accedemos a FortiView Destinations podremos ver las paginas que ha bloqueado nuestro filtro :\n","date":"March 28, 2024","hero":"/images/cortafuegos/fortinet.png","permalink":"https://www.javiercd.es/posts/cortafuegos/fortinet_uno/fortinet_uno/","summary":"Antes de comenzar la practica , el escenario que ves en la practica es lo mas parecido que puedo montar a la practica original . He utilizado la versión 7.0.9-1 de FortiGate , ya que las versiones superiores traen algunas restricciones . Puedes descargarte la imagen desde este link .\nPuesta en marcha del cortafuegos Los dispositivos FortiGate vienen configurados de fabrica con la IP 192.168.1.99/24 , como estoy desde GNS3 no es necesario que me conecte a esta interfaz con un dispositivo y cambie la configuración .","tags":["FIREWALL","LINUX","DEBIAN","FORTINET"],"title":"Implementación de un cortafuegos perimetral con Fortinet I"},{"categories":null,"contents":" Ahora vamos a emular la práctica de cortafuegos II, pero en GNS3. Para ello, he transformado al cliente 1 en Odin, además he añadido a Thor y Loki como máquinas virtuales en lugar de contenedores en la red LAN. También he creado una nueva red llamada DMZ, en la cual estará la máquina Hela.\nDado que he transformado el escenario anterior en este nuevo, contamos con algunas reglas creadas anteriormente. Por lo tanto, eliminaré del enunciado aquellas que ya estén creadas, como la de hacer SSH a Odin desde el puerto 2222, pero con el servicio escuchando en el 22.\nAdemás, ahora vamos a hacer unas reservas DHCP para tener controladas las IP de las nuevas máquinas.\nAdemas como no cuento con los servicios montados en el antiguo escenario en Opsentack y para las reglas del enunciado montare lo mínimo para hacer que funcionen las reglas .\nA lo largo de esta practica te explicare que por como esta montado la topologia de la red , todos de la red LAN pueden comunicarse entre sin necesidad de pasar por el cortafuegos . Así que en algunos ejercicios omitiré la parte de hacer que Loki y Thor se comuniquen con Odin. Ademas no voy a montar el servidor DNS ni LDAP ya que las reglas de DNAT son bastante sencillas y a lo largo de la practica aparecen varios ejercicios de hacer DNAT entre las distintas redes . En lugar de esto voy a añadir VPN al final de la misma ya que lo veo mas interesante que repetir las mismas reglas cambiando el servicio .\nPreparación del escenario Lo primero que haré sera crear una nueva red en el puerto 3 , que corresponde a la red DMZ .\nComo veras en la imagen a continuación he seleccionado que el rol sea LAN , para que me permita tener un servidor DHCP en esa red . Como es una red en la que albergara los servicios no quiero que desde esta se pueda acceder a configurar el cortafuegos así que dejare la administración desactivada .\nAhora iré accediendo a los nuevos clientes y les cambiare el nombre de maquina y configurándolas por DHCP .\nMaquina Odin , esta era anteriormente la maquina cliente 1 , solo hay que cambiarle el FQDN y el hostname :\nosboxes@odin:~$ hostname -f odin.javiercd.gonzalonazareno.org osboxes@odin:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 192.168.100.2/24 brd 192.168.100.255 scope global dynamic noprefixroute ens3 valid_lft 604790sec preferred_lft 604790sec Maquina Thor :\ndebian@thor:~$ hostname -f thor.javiercd.gonzalonazareno.org debian@thor:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 192.168.100.4/24 brd 192.168.100.255 scope global dynamic ens3 valid_lft 604791sec preferred_lft 604791sec debian@thor:~$ Maquina Loki :\ndebian@loki:~$ hostname -f loki.javiercd.gonzalonazareno.org debian@loki:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 192.168.100.3/24 brd 192.168.100.255 scope global dynamic ens3 valid_lft 604724sec preferred_lft 604724sec Maquina Hela :\ndebian@hela:~$ hostname -f hela.javiercd.gonzalonazareno.org debian@hela:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 192.168.200.2/24 brd 192.168.200.255 scope global dynamic ens3 valid_lft 604795sec preferred_lft 604795sec Ahora vamos a hacer unas reservas en el servidor DHCP , accederemos a Dashborad \u0026gt; Networks \u0026gt; DHCP , una vez aquí le daremos clic derecho sobre cada cliente de los 4 que tenemos en el escenario y le crearemos una reserva :\nNos saldrá un menú similar a este para enlazar la dirección MAC a la IP :\nUna vez hagamos esto con nuestro clientes nos indicara que tenemos la reserva hecha :\nReglas del cortafuegos Vamos a comenzar a crear las reglas , como dije anteriormente partimos del escenario anterior , así que algunas reglas para el funcionamiento mínimo de la red están creadas .\nTe dejo una captura de como se quedaron las reglas , para que veas del estado en el que partimos :\nAlgunas de las siguiente reglas ya esta configurada del ejercicio anterior , como la siguiente regla \u0026ndash;\u0026gt; La máquina Odin tiene un servidor ssh escuchando por el puerto 22, pero al acceder desde el exterior habrá que conectar al puerto 2222\njaviercruces@HPOMEN15:~$ ssh osboxes@192.168.122.77 -p 2222 osboxes@192.168.122.77\u0026#39;s password: Welcome to Ubuntu 22.04 LTS (GNU/Linux 5.15.0-25-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 560 updates can be applied immediately. 339 of these updates are standard security updates. To see these additional updates run: apt list --upgradable Last login: Fri Mar 29 11:23:44 2024 from 192.168.100.1 osboxes@odin:~$ hostname -f odin.javiercd.gonzalonazareno.org A continuación veras que hay algunas reglas que he eliminado o modificado , ya que en el escenario actual no se pueden hacer , bien o por la topología o porque anteriormente la maquina Odin era el cortafuegos . En cualquier caso alguna he mantenido y he explicado algunas cosas adicionales .\nDesde Thor y Hela se debe permitir la conexión ssh por el puerto 22 a la máquina Odin. Esta regla no la podemos realizar ya que al tener un switch de por medio interconectando los dispositivos , el trafico no pasara por el cortafuegos por lo que no podremos aplicar reglas en el cortafuego para impedir el trafico local .\nVeras que aunque cree la regla , en el cortafuegos esta no se inmutara :\nVes que por ejemplo si me conecto desde loki o desde thor puedo llegar a odin :\ndebian@loki:~$ ssh osboxes@192.168.100.2 osboxes@192.168.100.2\u0026#39;s password: Welcome to Ubuntu 22.04 LTS (GNU/Linux 5.15.0-25-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 560 updates can be applied immediately. 339 of these updates are standard security updates. To see these additional updates run: apt list --upgradable Last login: Fri Mar 29 11:42:43 2024 from 192.168.100.3 osboxes@odin:~$ Pero no llego por la regla que he creado si no por la propia topologia de la red , la regla no tiene hits :\nTodo el trafico se encarga de redirigirlo el swicht .\nA la máquina Odin se le puede hacer ping desde la DMZ, pero desde la LAN se le debe rechazar la conexión (REJECT) y desde el exterior se rechazará de manera silenciosa. Para permitir que desde la red DMZ podamos hacer ping hacia Odin crearemos la siguiente regla :\nVamos a comprobar que desde la DMZ podemos hacer el ping a Odin :\ndebian@hela:~$ ping 192.168.100.2 -c 1 PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data. 64 bytes from 192.168.100.2: icmp_seq=1 ttl=63 time=2.38 ms --- 192.168.100.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 2.379/2.379/2.379/0.000 ms Como vemos la regla esta funcionando , así que vamos a comprobar los hits :\nPor el mismo motivo que en el ejercicio anterior , desde la red LAN no podemos limitar el ping hacia Odin ya que no pasa por el cortafuegos si no por el switch .\nAlgo parecido nos pasara desde la WAN , al ser un ping dirigido a la IP de la interfaz este se desactiva desde la configuración de la misma , siempre se rechaza de manera silenciosa pero no da opción a elegirlo :\nUna vez eliminado\njaviercruces@HPOMEN15:~$ ping 192.168.122.77 -c 1 PING 192.168.122.77 (192.168.122.77) 56(84) bytes of data. --- 192.168.122.77 ping statistics --- 1 packets transmitted, 0 received, 100% packet loss, time 0ms La máquina Odin puede hacer ping a la LAN, la DMZ y al exterior. La maquina Odin por la propia topologia puede hacerle ping a todas las maquinas de la LAN ya que el trafico hacia esta red pasa por el swicht .\nPara que pueda hacer ping hacia la DMZ y a la WAN vamos a crear dos reglas :\nLa regla para la WAN :\nLa regla para la DMZ :\n# LAN --\u0026gt; WAN osboxes@odin:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=114 time=10.1 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 10.088/10.088/10.088/0.000 ms # LAN --\u0026gt; DMZ osboxes@odin:~$ ping 192.168.200.2 -c 1 PING 192.168.200.2 (192.168.200.2) 56(84) bytes of data. 64 bytes from 192.168.200.2: icmp_seq=1 ttl=63 time=0.804 ms --- 192.168.200.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.804/0.804/0.804/0.000 ms # LAN --\u0026gt; LAN (No interviene el cortafuegos) osboxes@odin:~$ ping 192.168.100.3 -c 1 PING 192.168.100.3 (192.168.100.3) 56(84) bytes of data. 64 bytes from 192.168.100.3: icmp_seq=1 ttl=64 time=0.503 ms --- 192.168.100.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.503/0.503/0.503/0.000 ms Vamos a comprobar los hits de las dos reglas que acabamos de crear :\nDesde la máquina Hela se puede hacer ping y conexión ssh a las máquinas de la LAN. Para lograr esto creare la siguiente regla . Podríamos separarla en 2 reglas independientes para tener los contadores por separado , pero en este caso no es importante distinguir el trafico .\nVamos a comprobar la regla , haciendo un ping a las distintas maquinas de la red LAN , ya que anteriormente había una regla para permitir todos los pings hacia Odin :\n# HELA --\u0026gt; ODIN debian@hela:~$ ping 192.168.100.2 -c 1 PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data. 64 bytes from 192.168.100.2: icmp_seq=1 ttl=63 time=1.10 ms --- 192.168.100.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.101/1.101/1.101/0.000 ms # HELA --\u0026gt; LOKI debian@hela:~$ ping 192.168.100.3 -c 1 PING 192.168.100.3 (192.168.100.3) 56(84) bytes of data. 64 bytes from 192.168.100.3: icmp_seq=1 ttl=63 time=1.73 ms --- 192.168.100.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.730/1.730/1.730/0.000 ms # HELA --\u0026gt; THOR debian@hela:~$ ping 192.168.100.4 -c 1 PING 192.168.100.4 (192.168.100.4) 56(84) bytes of data. 64 bytes from 192.168.100.4: icmp_seq=1 ttl=63 time=0.998 ms --- 192.168.100.4 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.998/0.998/0.998/0.000 ms Ahora vamos a comprobar que podemos conectarnos por ssh desde Hela a la LAN :\ndebian@hela:~$ ssh osboxes@192.168.100.2 \u0026#39;hostname -f\u0026#39; osboxes@192.168.100.2\u0026#39;s password: odin.javiercd.gonzalonazareno.org debian@hela:~$ ssh 192.168.100.3 \u0026#39;hostname -f\u0026#39; debian@192.168.100.3\u0026#39;s password: loki.javiercd.gonzalonazareno.org debian@hela:~$ ssh 192.168.100.4 \u0026#39;hostname -f\u0026#39; debian@192.168.100.4\u0026#39;s password: thor.javiercd.gonzalonazareno.org La regla funciona correctamente , vamos a comprobar que ha subido los hits :\nDesde cualquier máquina de la LAN se puede conectar por ssh a la máquina Hela. Para ello vamos a crear la siguiente regla :\nAhora vamos a comprobar la regla que acabamos de crear :\nosboxes@odin:~$ ssh debian@192.168.200.2 \u0026#39;hostname -f\u0026#39; debian@192.168.200.2\u0026#39;s password: hela.javiercd.gonzalonazareno.org debian@loki:~$ ssh 192.168.200.2 \u0026#39;hostname -f\u0026#39; debian@192.168.200.2\u0026#39;s password: hela.javiercd.gonzalonazareno.org debian@thor:~$ ssh 192.168.200.2 \u0026#39;hostname -f\u0026#39; debian@192.168.200.2\u0026#39;s password: hela.javiercd.gonzalonazareno.org Vamos a comprobar que los hits de la regla han subido :\nConfigura la máquina Odin para que las máquinas de LAN y DMZ puedan acceder al exterior. El SNAT en este dispositivo podemos elegir activarlo por cada regla y no en general . Si te has fijado a lo largo de la practica en todas las reglas que implica dar un salto de interfaz he marcado la casilla NAT :\nPor lo que este apartado se va a ir realizando a lo largo de la practica conforme creemos las reglas .\nLas máquinas de la LAN pueden hacer ping al exterior y navegar. Vamos a tener que crear 3 reglas :\nPermitir el trafico HTTP/HTTPS Permitir las consultas DNS Permitir hacer ping De estas tres reglas las dos primeras están creadas con anterioridad :\nPor lo que solo nos queda añadir la regla del ping , que seria la siguiente :\nComo tengo una versión de prueba puedo tener como máximo 10 entradas , así que voy a eliminar la que solo deja hacer ping al exterior a Odin .\nVamos a comprobar las reglas , desde un cliente de la red LAN:\nosboxes@odin:~$ dig @8.8.8.8 www.javiercd.es ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.1-1ubuntu1-Ubuntu \u0026lt;\u0026lt;\u0026gt;\u0026gt; @8.8.8.8 www.javiercd.es ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 25764 ;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;www.javiercd.es.\tIN\tA ;; ANSWER SECTION: www.javiercd.es.\t3600\tIN\tCNAME\tjavierasping.github.io. javierasping.github.io.\t3600\tIN\tA\t185.199.108.153 javierasping.github.io.\t3600\tIN\tA\t185.199.109.153 javierasping.github.io.\t3600\tIN\tA\t185.199.110.153 javierasping.github.io.\t3600\tIN\tA\t185.199.111.153 ;; Query time: 60 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP) ;; WHEN: Fri Mar 29 13:44:50 EDT 2024 ;; MSG SIZE rcvd: 144 osboxes@odin:~$ ping -c 1 www.javiercd.es PING javierasping.github.io (185.199.108.153) 56(84) bytes of data. 64 bytes from cdn-185-199-108-153.github.com (185.199.108.153): icmp_seq=1 ttl=55 time=11.1 ms --- javierasping.github.io ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 11.111/11.111/11.111/0.000 ms osboxes@odin:~$ curl -I https://www.javiercd.es/ HTTP/2 200 server: GitHub.com content-type: text/html; charset=utf-8 last-modified: Mon, 11 Mar 2024 23:21:37 GMT access-control-allow-origin: * strict-transport-security: max-age=31556952 etag: \u0026#34;65ef9201-6878\u0026#34; expires: Fri, 29 Mar 2024 17:56:01 GMT cache-control: max-age=600 x-proxy-cache: MISS x-github-request-id: AE88:3308D5:438AA74:448F970:6606FE58 accept-ranges: bytes date: Fri, 29 Mar 2024 17:46:01 GMT via: 1.1 varnish age: 0 x-served-by: cache-mad2200143-MAD x-cache: MISS x-cache-hits: 0 x-timer: S1711734362.862201,VS0,VE134 vary: Accept-Encoding x-fastly-request-id: 16b6048f2b032ef4b4293c52f0ae36d19b0e0da0 content-length: 26744 Así quedarían nuestras tres reglas , veremos que tenemos hits en las mismas :\nLa máquina Hela puede navegar. Instala un servidor web, un servidor ftp y un servidor de correos si no los tienes aún. Para realizar esto es necesario tener permitido el DNS y la navegación . Para ello he creado la siguiente regla :\nLa he creado en una sola regla para ahorrar en el numero de las mismas , he borrado las que permitía el ping desde DMZ a LAN de ejercicios anteriores .\ndebian@hela:~$ sudo apt install proftpd postfix apache2 -y Configura la máquina Odin para que los servicios web y ftp sean accesibles desde el exterior. Para hacer el DNAT deberemos de crear 2 IPs virtuales , como hicimos en cortafuegos I .\nUna para cada servicio que queramos hacer un DNAT . Para el servidor web :\nY para el servidor FTP :\nAhora vamos a crear la propia regla de DNAT para el servidor web , en la cual como destino indicamos la IP virtual que acabamos de crear :\nVeremos que si accedemos a la IP del cortafuegos de la WAN accederemos al apache de Hela :\nTambién crearemos la regla DNAT para el servidor FTP :\nVamos a comprobar el acceso al servidor ftp :\njaviercruces@HPOMEN15:~$ ftp debian@192.168.122.77 Connected to 192.168.122.77. 220 ProFTPD Server (Debian) [::ffff:192.168.200.2] 331 Password required for debian Password: 230 User debian logged in Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; Si comprobamos los hits de las reglas veremos que en ambas ha subido :\nEl servidor web y el servidor ftp deben ser accesibles desde la LAN y desde el exterior. Para realizar este ejercicio deberemos de volver a generar las 2 IPs virtuales pero ahora indicaremos la IP de la tarjeta LAN del firewall .\nPara el DNAT del servidor web :\nRepetiremos lo mismo para el servicio FTP , cambiando el servicio :\nAhora crearemos las 2 reglas de DNAT para permitir el acceso desde la LAN .\nPara el servidor web :\nPara el servidor FTP:\nVamos a comprobar que podemos acceder a ambos servicios :\nosboxes@odin:~$ curl -I http://192.168.100.1 HTTP/1.1 200 OK Date: Fri, 29 Mar 2024 18:31:59 GMT Server: Apache/2.4.57 (Debian) Last-Modified: Fri, 29 Mar 2024 17:53:38 GMT ETag: \u0026#34;29cd-614d051d4d640\u0026#34; Accept-Ranges: bytes Content-Length: 10701 Vary: Accept-Encoding Content-Type: text/html osboxes@odin:~$ ftp debian@192.168.100.1 Connected to 192.168.100.1. 220 ProFTPD Server (Debian) [::ffff:192.168.200.2] 331 Password required for debian Password: 230 User debian logged in Remote system type is UNIX. Using binary mode to transfer files. Vamos a comprobar que han subido los hits en las reglas :\nEl servidor de correos sólo debe ser accesible desde la LAN. Volvemos a repetir los mismos pasos , le crearemos una IP virtual para poder hacer la regla de DNAT :\nAhora vamos a crear la regla de DNAT :\nY comprobaremos que desde un PC de la LAN haciendo un telnet llegamos al servidor de correos :\nosboxes@odin:~$ telnet 192.168.100.1 25 Trying 192.168.100.1... Connected to 192.168.100.1. Escape character is \u0026#39;^]\u0026#39;. 220 hela.javiercd.gonzalonazareno.org ESMTP Postfix (Debian/GNU) quit 221 2.0.0 Bye Connection closed by foreign host. Veremos que el hit de la regla ha subido :\nEn la máquina Loki instala un servidor Postgres si no lo tiene aún. A este servidor se puede acceder desde la DMZ, pero no desde el exterior. Volveremos a repetir el proceso de crear una nueva IP virtual para este servicio . Ademas en este caso he tenido que crear el servicio ya que no existía .\nVamos a crear la regla de DNAT :\nVamos a comprobar que tenemos acceso al servidor pgsql desde la red DMZ :\ndebian@hela:~$ psql -h 192.168.200.1 -U postgres -W Password: psql (15.6 (Debian 15.6-0+deb12u1)) SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, compression: off) Type \u0026#34;help\u0026#34; for help. postgres=# \\q Comprobaremos que la regla tiene hits :\nEvita ataques DoS por ICMP Flood, limitando a 4 el número de peticiones por segundo desde una misma IP. Dentro del apartado de políticas y objetos , encontramos un apartado para crear políticas para DoS . En mi caso he creado una con los valores recomendados que da el fabricante . Y he cambiado el limite de ICMP Flood a 4 paquetes por segundo .\nVamos a comprobar que nos bloquea el trafico si excedemos ese limite . Con este comando estamos enviando 3 paquetes por segundo que es inferior al limite establecido asi que no cortara ningún paquete :\ndebian@loki:~$ sudo hping3 --icmp -i u333333 -V 192.168.100.1 --- 192.168.100.1 hping statistic --- 124 packets transmitted, 124 packets received, 0% packet loss round-trip min/avg/max = 0.7/5.3/9.9 ms Si aumentamos los de paquetes por segundos , bloqueara todos los paquetes que superen a 4 por segundo , por eso deja pasar los 4 primeros de cada segundo :\ndebian@loki:~$ sudo hping3 --icmp -i u200000 -V 192.168.100.1 --- 192.168.100.1 hping statistic --- 44 packets transmitted, 10 packets received, 78% packet loss round-trip min/avg/max = 4.6/5.5/6.5 ms El cortafuegos ha registrado como una anomalía el trafico que ha tirado :\nEvita ataques DoS por SYN Flood. Con el filtro que hemos activado en el ejercicio anterior tenemos limitada las peticiones TCP a 2000 por minuto desde la misma IP para evitar este tipo de ataque . Vemos que el filtro elimina las peticiones maliciosas y no deja que el ataque tenga efecto :\ndebian@loki:~$ sudo hping3 --flood --rand-source -V 192.168.100.1 using ens3, addr: 192.168.100.3, MTU: 1500 HPING 192.168.100.1 (ens3 192.168.100.1): NO FLAGS are set, 40 headers + 0 data bytes hping in flood mode, no replies will be shown ^C --- 192.168.100.1 hping statistic --- 930716 packets transmitted, 0 packets received, 100% packet loss round-trip min/avg/max = 0.0/0.0/0.0 ms Evita que realicen escaneos de puertos a Odin. En lugar de hacerlo a Odin por la propia topologia vamos a hacerlo para evitar escaneos desde la WAN .\nPara ello nos abrimos una terminal y lo que vamos a hacer es crear una firma de IPS para evitar los paquetes con una determinada bandera que usa un escaneo determinado . En este caso vamos a evitar el escaneo de NMAP XMAS .\nFTG # config ips custom FTG (custom) # edit \u0026#34;Block_xmas\u0026#34; new entry \u0026#39;Block_xmas\u0026#39; added FTG (Block_xmas) # set signature \u0026#34;F-SBID(--name \u0026#39;Block_xmas\u0026#39;; --protocol tcp; --flow from_client; --tcp_flags *FUP; )\u0026#34; FTG (Block_xmas) # set action block FTG (Block_xmas) # end Una vez configurado nos aparecera la regla que hemos creado en IPs signatures :\nAhora vamos a crear una regla IPS para asociarla con esta politica de firmas :\nAñadiremos en IPS signatures and filters , el nuevo filtro que hemos creado anteriormente :\nA continuación en las reglas de DNAT donde queramos controlar que no sepan que puertos tenemos abiertos , asignaremos la nueva política IPS :\nEn mi caso vamos a probarlo para la regla DNAT de ssh :\nSi lanzo el NMAP desde mi host que esta en la red WAN , vemos que el puerto 2222 que es el que esta regla tiene abierto no lo detecta :\njaviercruces@HPOMEN15:~$ sudo nmap -sX 192.168.122.77 Starting Nmap 7.93 ( https://nmap.org ) at 2024-03-30 19:05 CET Nmap scan report for 192.168.122.77 Host is up (0.00059s latency). All 1000 scanned ports on 192.168.122.77 are in ignored states. Not shown: 1000 open|filtered tcp ports (no-response) MAC Address: 0C:18:45:93:00:00 (Unknown) Nmap done: 1 IP address (1 host up) scanned in 21.28 seconds Y el propio cortafuegos nos avisara de que ha habido un escaneo de puertos que ha bloqueado , para ver esto dirígete a Log \u0026amp; Report \u0026gt; Intrusion prevention :\nPodemos seleccionarlo para ver mas detalles del mismo :\n","date":"March 28, 2024","hero":"/images/cortafuegos/fortinet.png","permalink":"https://www.javiercd.es/posts/cortafuegos/fortinet_dos/fortinet_dos/","summary":"Ahora vamos a emular la práctica de cortafuegos II, pero en GNS3. Para ello, he transformado al cliente 1 en Odin, además he añadido a Thor y Loki como máquinas virtuales en lugar de contenedores en la red LAN. También he creado una nueva red llamada DMZ, en la cual estará la máquina Hela.\nDado que he transformado el escenario anterior en este nuevo, contamos con algunas reglas creadas anteriormente.","tags":["FIREWALL","LINUX","DEBIAN","FORTINET"],"title":"Implementación de un cortafuegos perimetral con Fortinet II"},{"categories":null,"contents":" En este post sobre un escenario con maquinas Debian , aplicaremos reglas con Nftables para conrtrolar el trafico que entra y sale en nuestra red , intentando imitar un escenario.\n[!NOTE]\nPara desplegar el escenario para realizar estos ejercicios necesitaras desplegar el fichero .yaml que encontraras en el enlace del párrafo siguiente . Este se encargara de desplegar 2 maquinas una que hará de cortafuegos y otra que simulara un cliente que estará conectado a la primera maquina para simular una red local .\nRealiza con NFTABLES el ejercicio de la página https://fp.josedomingo.org/seguridadgs/u03/perimetral_iptables.html documentando las pruebas de funcionamiento realizadas.\nPreparación del escenario Lo primero que haremos es activar el bit de forwarding. Para ello, editaremos el archivo /etc/sysctl.conf utilizando el siguiente comando :\njaviercruces@router-fw:~$ sudo nano /etc/sysctl.conf # Descomentamos la linea net.ipv4.ip_forward=1 A continuación, aplicaremos los cambios utilizando el siguiente comando:\njaviercruces@router-fw:~$ sudo sysctl -p net.ipv4.ip_forward = 1 Ahora añadiremos la tabla filter :\njaviercruces@router-fw:~$ sudo nft add table inet filter Podemos ver las tablas creadas :\njaviercruces@router-fw:~$ sudo nft list tables table inet filter Crear las cadenas para la entrada y salida :\n# Cadena de \u0026#34;entrada\u0026#34; javiercruces@router-fw:~$ sudo nft add chain inet filter input { type filter hook input priority 0 \\; counter \\; policy accept \\; } # Cadena de \u0026#34;salida\u0026#34; javiercruces@router-fw:~$ sudo nft add chain inet filter output { type filter hook output priority 0 \\; counter \\; policy accept \\; } # Cadena forward , peticiones que atraviesen : javiercruces@router-fw:~$ sudo nft add chain inet filter forward { type filter hook forward priority 0 \\; counter \\; policy drop \\; } Ahora comprobaremos que se han creado estas tres cadenas :\njaviercruces@router-fw:~$ sudo nft list chains table inet filter { chain input { type filter hook input priority filter; policy accept; } chain output { type filter hook output priority filter; policy accept; } chain forward { type filter hook forward priority filter; policy accept; } } Reglas del cortafuegos Permitir ssh hacia el cortafuegos Ahora vamos a permitir el ssh hacia la maquina router-fw :\njaviercruces@router-fw:~$ sudo nft add rule inet filter input iif ens3 tcp dport 22 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter output oif ens3 tcp sport 22 ct state established counter accept Política por defecto DROP Ahora vamos a poner la política por defecto DROP:\njaviercruces@router-fw:~$ sudo nft chain inet filter input { policy drop \\; } javiercruces@router-fw:~$ sudo nft chain inet filter output { policy drop \\; } javiercruces@router-fw:~$ sudo nft chain inet filter forward { policy drop \\; } Comprobaremos que con la nueva política podemos conectarnos por ssh y no hemos perdido la conexión , viendo que tenemos hits en las reglas .\njaviercruces@router-fw:~$ sudo nft list ruleset table inet filter { chain input { type filter hook input priority filter; policy drop; counter packets 174 bytes 11824 iif \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 129 bytes 8252 accept } chain output { type filter hook output priority filter; policy drop; counter packets 169 bytes 31232 oif \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 85 bytes 22632 accept } } SNAT Hacemos SNAT para que los equipos de la LAN puedan acceder al exterior.\nPara ello sera necesario que creemos la tabla NAT y sus cadenas . Como podemos observar hemos indicado menos prioridad en la cadena postrouting (mientras menor sea el número, mayor es su prioridad) para que las reglas de dicha cadena se ejecuten después de las reglas de prerouting.\n# Creamos la tabla NAT javiercruces@router-fw:~$ sudo nft add table nat # Cadena para el DNAT javiercruces@router-fw:~$ sudo nft add chain nat prerouting { type nat hook prerouting priority 0 \\; } # Cadena para el SNAT javiercruces@router-fw:~$ sudo nft add chain nat postrouting { type nat hook postrouting priority 100 \\; } Ahora vamos a permitir hacer SNAT a la red LAN :\njaviercruces@router-fw:~$ sudo nft add rule ip nat postrouting oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 counter masquerade Permitimos el ssh desde el cortafuego a la LAN javiercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept Ahora que podemos conectarnos por ssh a nuestra maquina LAN , vamos a comprobar las 2 reglas anteriores . Conectarnos por ssh y el SNAT :\njaviercruces@router-fw:~$ ssh debian@192.168.100.10 Linux lan 6.1.0-12-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.52-1 (2023-09-07) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Tue Feb 27 18:31:10 2024 from 192.168.100.2 debian@lan:~$ ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. ^C --- 1.1.1.1 ping statistics --- 2 packets transmitted, 0 received, 100% packet loss, time 1002ms Veremos que podemos conectarnos por ssh , sin embargo el ping no esta permitido pero lo he realizado para que la regla de SNAT tenga hits.\nVamos a ver que las reglas tienen hits :\njaviercruces@router-fw:~$ sudo nft list ruleset table inet filter { chain input { type filter hook input priority filter; policy drop; counter packets 621 bytes 63636 iif \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 493 bytes 41948 accept iifname \u0026#34;ens4\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 81 bytes 17628 accept } chain output { type filter hook output priority filter; policy drop; counter packets 1231 bytes 141120 oif \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 349 bytes 68222 accept oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 103 bytes 17420 accept } chain forward { type filter hook forward priority filter; policy drop; counter packets 4 bytes 336 } } table ip nat { chain prerouting { type nat hook prerouting priority filter; policy accept; } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 counter packets 1 bytes 84 masquerade } } Como podemos ver el SNAT tiene hits , así que la regla esta funcionando , pero como no dejamos que atraviese el firewall estas no saldrán .\nPermitimos tráfico para la interfaz loopback Añadimos las reglas , para permitir el trafico hacia la interfaz loopback :\njaviercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;lo\u0026#34; counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;lo\u0026#34; counter accept Comprobamos que tenemos conectividad :\njaviercruces@router-fw:~$ ping 127.0.0.1 PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data. 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.205 ms Vamos a ver los hits de la regla :\njaviercruces@router-fw:~$ sudo nft list ruleset | grep lo iifname \u0026#34;lo\u0026#34; counter packets 2 bytes 168 accept oifname \u0026#34;lo\u0026#34; counter packets 2 bytes 168 accept Peticiones y respuestas protocolo ICMP Vamos a permitir a la maquina router-fw aceptar peticiones ICMP y que envié la respuesta :\njaviercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; icmp type echo-request counter accept Le hago ping desde mi maquina :\njaviercruces@HPOMEN15:~/Documentos/2ºASIR/SAD/cortafuegos1$ ping 172.22.201.120 -c 1 PING 172.22.201.120 (172.22.201.120) 56(84) bytes of data. 64 bytes from 172.22.201.120: icmp_seq=1 ttl=61 time=85.4 ms --- 172.22.201.120 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 85.403/85.403/85.403/0.000 ms Permitir hacer ping desde la LAN Vamos a permitir que se pueda hacer ping desde la LAN :\njaviercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 icmp type echo-request counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 icmp type echo-reply counter accept Vamos a comprobarlo :\ndebian@lan:~$ ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. 64 bytes from 1.1.1.1: icmp_seq=1 ttl=50 time=40.8 ms 64 bytes from 1.1.1.1: icmp_seq=2 ttl=50 time=40.8 ms ^C --- 1.1.1.1 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 40.821/40.834/40.848/0.013 ms Vamos a ver los hits de la regla , ademas con esta podemos comprobar la regla del SNAT :\njaviercruces@router-fw:~$ sudo nft list ruleset table inet filter { chain input { type filter hook input priority filter; policy drop; counter packets 2637 bytes 213636 iif \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 2346 bytes 172928 accept iifname \u0026#34;ens4\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 225 bytes 32812 accept iifname \u0026#34;lo\u0026#34; counter packets 2 bytes 168 accept iifname \u0026#34;ens3\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept } chain output { type filter hook output priority filter; policy drop; counter packets 4656 bytes 697080 oif \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 1618 bytes 477018 accept oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 291 bytes 30252 accept oifname \u0026#34;lo\u0026#34; counter packets 2 bytes 168 accept oifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter packets 1 bytes 84 accept } chain forward { type filter hook forward priority filter; policy drop; counter packets 31 bytes 2604 iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 icmp type echo-request counter packets 12 bytes 1008 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 icmp type echo-reply counter packets 2 bytes 168 accept } } table ip nat { chain prerouting { type nat hook prerouting priority filter; policy accept; } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 counter packets 4 bytes 336 masquerade } } Consultas y respuestas DNS desde la LAN javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 udp sport 53 ct state established counter accept Vamos a hacer una consulta utilizando el comando host , ya que no dispongo otra herramienta instalada para hacer consultas dns :\ndebian@lan:~$ host www.javiercd.es www.javiercd.es is an alias for javierasping.github.io. javierasping.github.io has address 185.199.111.153 javierasping.github.io has address 185.199.108.153 javierasping.github.io has address 185.199.109.153 javierasping.github.io has address 185.199.110.153 javierasping.github.io has IPv6 address 2606:50c0:8000::153 javierasping.github.io has IPv6 address 2606:50c0:8001::153 javierasping.github.io has IPv6 address 2606:50c0:8003::153 javierasping.github.io has IPv6 address 2606:50c0:8002::153 Vamos a consultar los hits de las reglas :\njaviercruces@router-fw:~$ sudo nft list ruleset iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ct state established,new counter packets 10 bytes 643 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 udp sport 53 ct state established counter packets 10 bytes 2644 accept Permitimos la navegación web desde la LAN javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport { 80,443} ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport { 80,443} ct state established counter accept Para verificar este punto, necesitaremos modificar el archivo /etc/nsswitch.conf, el cual determina la prioridad de la resolución DNS. Realizaremos esta modificación para priorizar la consulta DNS al servicio de DNS de systemd, el cual está incluido en Debian y Ubuntu. Esto permitirá que las consultas se realicen primero en la propia máquina y, en caso necesario, serán enviadas al servidor DNS configurado ya que en este escenario las aplicaciones no nos resuelven si no realizamos esta modificación .\ndebian@lan:~$ sudo nano /etc/nsswitch.conf hosts: files dns resolve [!UNAVAIL=return] Ademas cambiaremos el servidor dns de la maquina y en lugar de ser nosotros , pondremos el del instituto :\ndebian@lan:~$ sudo cat /etc/resolv.conf nameserver 172.22.0.1 Una vez aplicados los cambios vamos a pedir una web por el nombre de dominio , así comprobaremos el funcionamiento de los dos puntos anteriores . Pediré solo las cabeceras para que la salida sea mas legible , un código 200 seria correcto . En la parte de http nos da una redirección ya que el servidor te redirige a https :\ndebian@lan:~$ curl -I https://www.javiercd.es/ HTTP/2 200 server: GitHub.com content-type: text/html; charset=utf-8 last-modified: Sun, 25 Feb 2024 23:03:49 GMT access-control-allow-origin: * strict-transport-security: max-age=31556952 etag: \u0026#34;65dbc755-675b\u0026#34; expires: Wed, 28 Feb 2024 10:10:17 GMT cache-control: max-age=600 x-proxy-cache: MISS x-github-request-id: 5CD4:0E10:CBDBE5:CFBAEA:65DF0430 accept-ranges: bytes date: Wed, 28 Feb 2024 10:00:17 GMT via: 1.1 varnish age: 0 x-served-by: cache-mad2200123-MAD x-cache: MISS x-cache-hits: 0 x-timer: S1709114417.014922,VS0,VE167 vary: Accept-Encoding x-fastly-request-id: e15d291bbff90bf9de58991f0f6477e4398c415d content-length: 26459 debian@lan:~$ curl -I http://www.javiercd.es/ HTTP/1.1 301 Moved Permanently Content-Length: 162 Server: GitHub.com Content-Type: text/html Location: https://www.javiercd.es/ X-GitHub-Request-Id: 9870:0E7F:37400AD:3848DF5:65DF0425 Accept-Ranges: bytes Date: Wed, 28 Feb 2024 10:00:27 GMT Age: 21 X-Served-By: cache-mad2200100-MAD X-Cache: HIT X-Cache-Hits: 1 X-Timer: S1709114427.468002,VS0,VE1 Vary: Accept-Encoding X-Fastly-Request-ID: e321e34041a049f6f7c99e0693be994990da6da3 X-Cache: MISS from f0 X-Cache-Lookup: HIT from f0:3128 Via: 1.1 varnish, 1.1 f0 (squid/4.6) Connection: close Permitimos el acceso a nuestro servidor web de la LAN desde el exterior Como ya tenemos resolución dns y navegación web , podremos actualizar nuestros repositorios y instalar paquetes :\ndebian@lan:~$ sudo apt update -y \u0026amp;\u0026amp; sudo apt install apache2 -y Una vez instalado apache vamos a realizar la regla de DNAT :\njaviercruces@router-fw:~$ sudo nft add rule ip nat prerouting iifname \u0026#34;ens3\u0026#34; tcp dport 80 counter dnat to 192.168.100.10 Ahora tenemos que permitir en la cadena forward el trafico para permitir el DNAT . Las peticiones al servidor web y las respuestas\njaviercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 80 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 80 ct state established counter accept Ahora vamos a comprobar que podemos acceder al servidor web :\njaviercruces@HPOMEN15:~/Documentos/2ºASIR/SAD/cortafuegos1$ curl -I 172.22.201.120 HTTP/1.1 200 OK Date: Wed, 28 Feb 2024 10:24:26 GMT Server: Apache/2.4.57 (Debian) Last-Modified: Wed, 28 Feb 2024 10:17:20 GMT ETag: \u0026#34;29cd-6126e72b03120\u0026#34; Accept-Ranges: bytes Content-Length: 10701 Vary: Accept-Encoding Content-Type: text/html Desde un navegador :\nPor ultimo vamos a comprobar que las reglas involucradas tienen hits y te dejo el listado completo para que veas las reglas hasta este punto :\njaviercruces@router-fw:~$ sudo nft list ruleset table inet filter { chain input { type filter hook input priority filter; policy drop; counter packets 20313 bytes 2212299 iif \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 11896 bytes 827728 accept iifname \u0026#34;ens4\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 8093 bytes 1321072 accept iifname \u0026#34;lo\u0026#34; counter packets 92 bytes 17660 accept iifname \u0026#34;ens3\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept } chain output { type filter hook output priority filter; policy drop; counter packets 69191 bytes 6011531 oif \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 8461 bytes 1953220 accept oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 9482 bytes 623484 accept oifname \u0026#34;lo\u0026#34; counter packets 92 bytes 17660 accept oifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter packets 1 bytes 84 accept } chain forward { type filter hook forward priority filter; policy drop; counter packets 42155 bytes 145465374 iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 icmp type echo-request counter packets 32 bytes 2688 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 icmp type echo-reply counter packets 18 bytes 1512 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ct state established,new counter packets 273 bytes 17860 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 udp sport 53 ct state established counter packets 273 bytes 52163 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport { 80, 443 } ct state established,new counter packets 33973 bytes 1794576 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport { 80, 443 } ct state established counter packets 7119 bytes 143533481 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 80 ct state established,new counter packets 47 bytes 3905 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 80 ct state established counter packets 32 bytes 24161 accept } } table ip nat { chain prerouting { type nat hook prerouting priority filter; policy accept; iifname \u0026#34;ens3\u0026#34; tcp dport 80 counter packets 4 bytes 240 dnat to 192.168.100.10 } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 counter packets 547 bytes 38852 masquerade } } Ejercicios adicionales Debes añadir después las reglas necesarias para que se permitan las siguientes operaciones:\nPermite poder hacer conexiones ssh al exterior desde la máquina cortafuegos. javiercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; tcp dport 22 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter accept Vamos a conectarnos por ssh desde la maquina cortafuegos a otra para comprobar esto :\njaviercruces@router-fw:~$ ssh 172.22.200.47 Linux odin.javiercd.gonzalonazareno.org 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Wed Feb 28 10:35:56 2024 from 172.22.201.120 javiercruces@odin:~$ Vamos a comprobar los hits en las reglas :\njaviercruces@router-fw:~$ sudo nft list ruleset iifname \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 66 bytes 18624 accept oifname \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 89 bytes 16572 accept Permite hacer consultas DNS desde la máquina cortafuegos sólo al servidor 8.8.8.8. Comprueba que no puedes hacer un dig @1.1.1.1. Vamos a añadir esta regla :\njaviercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 8.8.8.8 udp dport 53 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 8.8.8.8 udp sport 53 ct state established counter accept Ahora vamos a comprobar que a traves de la 1.1.1.1 no podemos resolver nombres pero con la 8.8.8.8 si :\njaviercruces@router-fw:~$ dig @1.1.1.1 www.javiercd.es ;; communications error to 1.1.1.1#53: timed out ;; communications error to 1.1.1.1#53: timed out ;; communications error to 1.1.1.1#53: timed out ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.24-1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; @1.1.1.1 www.javiercd.es ; (1 server found) ;; global options: +cmd ;; no servers could be reached javiercruces@router-fw:~$ dig @8.8.8.8 www.javiercd.es ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.24-1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; @8.8.8.8 www.javiercd.es ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 4046 ;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;www.javiercd.es.\tIN\tA ;; ANSWER SECTION: www.javiercd.es.\t3600\tIN\tCNAME\tjavierasping.github.io. javierasping.github.io.\t3600\tIN\tA\t185.199.108.153 javierasping.github.io.\t3600\tIN\tA\t185.199.109.153 javierasping.github.io.\t3600\tIN\tA\t185.199.110.153 javierasping.github.io.\t3600\tIN\tA\t185.199.111.153 ;; Query time: 68 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP) ;; WHEN: Wed Feb 28 11:09:05 UTC 2024 ;; MSG SIZE rcvd: 144 Vamos a ver los hits de las reglas :\njaviercruces@router-fw:~$ sudo nft list ruleset iifname \u0026#34;ens3\u0026#34; ip saddr 8.8.8.8 udp sport 53 ct state established counter packets 314 bytes 36448 accept oifname \u0026#34;ens3\u0026#34; ip daddr 8.8.8.8 udp dport 53 ct state established,new counter packets 314 bytes 21912 accept Permite que la máquina cortafuegos pueda navegar por https. Vamos a añadir la regla :\njaviercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip protocol tcp tcp dport 443 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip protocol tcp tcp sport 443 ct state established counter accept Vamos a comprobar que pidiendo las cabeceras , que es similar a navegar podemos ver un código 200 en https :\njaviercruces@router-fw:~$ curl -I https://www.javiercd.es/ HTTP/2 200 server: GitHub.com content-type: text/html; charset=utf-8 last-modified: Sun, 25 Feb 2024 23:03:49 GMT access-control-allow-origin: * strict-transport-security: max-age=31556952 etag: \u0026#34;65dbc755-675b\u0026#34; expires: Wed, 28 Feb 2024 10:10:17 GMT cache-control: max-age=600 x-proxy-cache: MISS x-github-request-id: 5CD4:0E10:CBDBE5:CFBAEA:65DF0430 accept-ranges: bytes date: Wed, 28 Feb 2024 11:10:32 GMT via: 1.1 varnish age: 0 x-served-by: cache-mad22033-MAD x-cache: HIT x-cache-hits: 1 x-timer: S1709118632.338441,VS0,VE131 vary: Accept-Encoding x-fastly-request-id: 01056938385ca0e465882fa75fd0b19d0973df62 content-length: 26459 Los equipos de la red local deben poder tener conexión al exterior. SNAT realizado anteriormente\nPermitimos el ssh desde el cortafuegos a la LAN Permitido por regla anterior\nPermitimos hacer ping desde la LAN a la máquina cortafuegos. javiercruces@router-fw:~$ sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; icmp type echo-request counter accept Realizamos el ping desde LAN al cortafuegos\ndebian@lan:~$ ping 192.168.100.2 PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data. 64 bytes from 192.168.100.2: icmp_seq=1 ttl=64 time=1.09 ms 64 bytes from 192.168.100.2: icmp_seq=2 ttl=64 time=1.75 ms ^C --- 192.168.100.2 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 1.091/1.419/1.748/0.328 ms Veremos los hits para esta regla en concreto :\njaviercruces@router-fw:~$ sudo nft list ruleset iifname \u0026#34;ens4\u0026#34; icmp type echo-request counter packets 2 bytes 168 accept oifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter packets 2 bytes 168 accept Permite realizar conexiones ssh desde los equipos de la LAN Vamos a hacer las reglas :\njaviercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport 22 ct state established counter accept Vamos a conectarnos por ssh a una maquina fuera de la lan :\ndebian@lan:~$ ssh javiercruces@172.22.200.47 Linux odin.javiercd.gonzalonazareno.org 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Wed Feb 28 10:36:26 2024 from 172.22.201.120 javiercruces@odin:~$ Vamos a ver los hits de estas reglas :\njaviercruces@router-fw:~$ sudo nft -a list table inet filter iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 10 bytes 3312 accept # handle 44 iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 7 bytes 3088 accept # handle 45 Instala un servidor de correos en la máquina de la LAN. Permite el acceso desde el exterior y desde el cortafuegos al servidor de correos. Para probarlo puedes ejecutar un telnet al puerto 25 tcp. Con estas reglas permitimos conectarnos desde fuera de la red al servidor de correos :\njaviercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 25 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 25 ct state established counter accept # Regla DNAT puerto 25 javiercruces@router-fw:~$ sudo nft add rule ip nat prerouting iifname \u0026#34;ens3\u0026#34; tcp dport 25 counter dnat to 192.168.100.10 Vamos a comprobarlo :\njaviercruces@HPOMEN15:~/Documentos/2ºASIR/SAD/cortafuegos1$ telnet 172.22.201.120 25 Trying 172.22.201.120... Connected to 172.22.201.120. Escape character is \u0026#39;^]\u0026#39;. 220 lan.openstacklocal ESMTP Postfix (Debian/GNU) Connection closed by foreign host. Vamos a ver los hits en las reglas :\njaviercruces@router-fw:~$ sudo nft list ruleset # Reglas para permitir el trafico iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 25 ct state established,new counter packets 10 bytes 544 accept # handle 46 iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 25 ct state established counter packets 9 bytes 613 accept # Regla DNAT iifname \u0026#34;ens3\u0026#34; tcp dport 25 counter packets 1 bytes 60 dnat to 192.168.100.10 Permite hacer conexiones ssh desde exterior a la LAN Para ello voy a hacer un DNAT al puerto 2222 y a permitir ese trafico\n# Reglas para permitir el trafico del DNAT javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 2222 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 2222 ct state established counter accept # Regla DNAT puerto 2222 para ssh sudo nft add rule ip nat prerouting iifname \u0026#34;ens3\u0026#34; tcp dport 2222 counter dnat to 192.168.100.10 He cambiado el puerto del servicio ssh de lan al 2222 , voy a conectarme desde fuera a la LAN por ssh :\njaviercruces@HPOMEN15:~/Documentos/2ºASIR/SAD/cortafuegos1$ ssh -p 2222 debian@172.22.201.120 Linux lan 6.1.0-12-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.52-1 (2023-09-07) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Wed Feb 28 14:12:18 2024 from 192.168.100.2 debian@lan:~$ Vamos a comprobar los hits de las reglas :\n# Reglas para permitir el ssh 2222 desde fuera hacia la LAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 2222 ct state established,new counter packets 54 bytes 9784 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 2222 ct state established counter packets 44 bytes 10494 accept # Regla DNAT iifname \u0026#34;ens3\u0026#34; tcp dport 2222 counter packets 5 bytes 300 dnat to 192.168.100.10 Modifica la regla anterior, para que al acceder desde el exterior por ssh tengamos que conectar al puerto 2222, aunque el servidor ssh este configurado para acceder por el puerto 22. Para esto vamos a eliminar las 3 reglas anteriores y añadiremos las siguientes :\n# Permitimos el trafico que ahora \u0026#34;cambiamos\u0026#34; el puerto con la regla DNAT de 2222 a 22 javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept javiercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept # Regla DNAT javiercruces@router-fw:~$ sudo nft add rule ip nat prerouting iifname \u0026#34;ens3\u0026#34; tcp dport 2222 counter dnat to 192.168.100.10 Ahora vamos a comprobar que podemos conectarnos desde el exterior a la LAN aunque ahora hemos cambiado el servidor ssh de LAN para que escuche en el puerto 22 :\njaviercruces@router-fw:~$ sudo nft list ruleset iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 34 bytes 7868 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 32 bytes 9066 accept iifname \u0026#34;ens3\u0026#34; tcp dport 2222 counter packets 7 bytes 420 dnat to 192.168.100.10:22 Permite hacer consultas DNS desde la LAN sólo al servidor 8.8.8.8. Comprueba que no puedes hacer un dig @1.1.1.1. Vamos a borrar la regla anterior que permite las consultas DNS :\njaviercruces@router-fw:~$ sudo nft -a list table inet filter iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ct state established,new counter packets 285 bytes 17036 accept # handle 35 javiercruces@router-fw:~$ sudo nft delete rule inet filter forward handle 35 Añadimos la regla nueva para permitir solo consultas al 8.8.8.8 :\njaviercruces@router-fw:~$ sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ip daddr 8.8.8.8 counter accept Vamos a comprobarlo :\ndebian@lan:~$ dig @1.1.1.1 www.javiercd.es ;; communications error to 1.1.1.1#53: timed out ;; communications error to 1.1.1.1#53: timed out ;; communications error to 1.1.1.1#53: timed out ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.24-1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; @1.1.1.1 www.javiercd.es ; (1 server found) ;; global options: +cmd ;; no servers could be reached debian@lan:~$ dig @8.8.8.8 www.javiercd.es ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.24-1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; @8.8.8.8 www.javiercd.es ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 59302 ;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;www.javiercd.es.\tIN\tA ;; ANSWER SECTION: www.javiercd.es.\t3600\tIN\tCNAME\tjavierasping.github.io. javierasping.github.io.\t3600\tIN\tA\t185.199.108.153 javierasping.github.io.\t3600\tIN\tA\t185.199.109.153 javierasping.github.io.\t3600\tIN\tA\t185.199.110.153 javierasping.github.io.\t3600\tIN\tA\t185.199.111.153 ;; Query time: 72 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP) ;; WHEN: Wed Feb 28 14:44:29 UTC 2024 ;; MSG SIZE rcvd: 144 Vamos a ver los hits de las reglas :\njaviercruces@router-fw:~$ sudo nft -a list table inet filter iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ip daddr 8.8.8.8 counter packets 3 bytes 218 accept # handle 53 Permite que los equipos de la LAN puedan navegar por internet, excepto a la página www.realbetisbalompie.es Tenemos un problema y es que nftables solo filtra hasta el nivel de transporte , es decir por puerto . Así que no podemos leer el dominio ya que este viaja en una cabecera del nivel de aplicación .\nPara prohibirlo , tendremos que bloquear esa IP en su totalidad para un determinado puerto , en mi caso van a ser el 80 y 443.\nVamos a averiguar las IPS del dominio que queremos bloquear :\njaviercruces@router-fw:~$ dig +short www.realbetisbalompie.es realbetisbalompie.es. 51.255.76.196 La añadiremos al principio de la cadena en lugar de add añadimos la palabra insert :\njaviercruces@router-fw:~$ sudo nft insert rule inet filter forward ip daddr 51.255.76.196 tcp dport {80, 443} iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; counter drop Y ahora no podremos navegar en la pagina del maligno :\ndebian@lan:~$ curl -I https://www.realbetisbalompie.es/ curl: (28) Failed to connect to www.realbetisbalompie.es port 443 after 129885 ms: Couldn\u0026#39;t connect to server Vamos a ver los hits de la regla que nos protege del mal :\njaviercruces@router-fw:~$ sudo nft list ruleset ip daddr 51.255.76.196 tcp dport { 80, 443 } iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; counter packets 7 bytes 420 drop Hacer las reglas persistentes Vamos a guardar las reglas con :\nrott@router-fw:/home/javiercruces# nft list ruleset \u0026gt; /etc/nftables.conf Si las queremos restaurar :\njaviercruces@router-fw:~$ sudo nft -f /etc/nftables.conf Para hacer que al reiniciar las reglas se restauren solas :\n# Creamos la unidad de systemd javiercruces@router-fw:~$ sudo cat /etc/systemd/system/nftables-persistent.service [Unit] Description=Cargar reglas de nftables al iniciar el sistema [Service] Type=oneshot ExecStart=/usr/sbin/nft -f /etc/nftables/nftables.rules [Install] WantedBy=multi-user.target # Activa el servicio para que al reiniciar se apliquen los cambios javiercruces@router-fw:~$ sudo systemctl enable nftables-persistent.service Reglas al final del ejercicio Te dejo la lista de las reglas en el estado del ultimo ejercicio :\njaviercruces@router-fw:~$ sudo nft list ruleset table inet filter { chain input { type filter hook input priority filter; policy drop; counter packets 34414 bytes 6500685 iif \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 21235 bytes 1526616 accept iifname \u0026#34;ens4\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 11648 bytes 1793088 accept iifname \u0026#34;lo\u0026#34; counter packets 92 bytes 17660 accept iifname \u0026#34;ens3\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept iifname \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 66 bytes 18624 accept iifname \u0026#34;ens3\u0026#34; ip protocol tcp tcp sport 443 ct state established counter packets 519 bytes 3016033 accept iifname \u0026#34;ens3\u0026#34; ip saddr 8.8.8.8 udp sport 53 ct state established counter packets 557 bytes 68077 accept iifname \u0026#34;ens4\u0026#34; icmp type echo-request counter packets 2 bytes 168 accept } chain output { type filter hook output priority filter; policy drop; counter packets 86303 bytes 8331992 oif \u0026#34;ens3\u0026#34; tcp sport 22 ct state established counter packets 15004 bytes 3534878 accept oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 14125 bytes 950568 accept oifname \u0026#34;lo\u0026#34; counter packets 92 bytes 17660 accept oifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter packets 1 bytes 84 accept oifname \u0026#34;ens3\u0026#34; tcp dport 22 ct state established,new counter packets 89 bytes 16572 accept oifname \u0026#34;ens3\u0026#34; ip daddr 8.8.8.8 udp dport 53 ct state established,new counter packets 557 bytes 36254 accept oifname \u0026#34;ens3\u0026#34; ip protocol tcp tcp dport 443 ct state established,new counter packets 367 bytes 25011 accept oifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter packets 2 bytes 168 accept } chain forward { type filter hook forward priority filter; policy drop; ip daddr 51.255.76.196 tcp dport { 80, 443 } iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; counter packets 7 bytes 420 drop counter packets 45573 bytes 149083811 iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 icmp type echo-request counter packets 32 bytes 2688 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 icmp type echo-reply counter packets 18 bytes 1512 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 udp sport 53 ct state established counter packets 664 bytes 101857 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport { 80, 443 } ct state established,new counter packets 34813 bytes 1843071 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport { 80, 443 } ct state established counter packets 7583 bytes 146852066 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 80 ct state established,new counter packets 47 bytes 3905 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 80 ct state established counter packets 32 bytes 24161 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip protocol tcp ip saddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 72 bytes 18540 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol tcp ip daddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 56 bytes 17296 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 25 ct state established,new counter packets 10 bytes 544 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 25 ct state established counter packets 9 bytes 613 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip daddr 192.168.100.0/24 tcp dport 22 ct state established,new counter packets 90 bytes 17200 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter packets 77 bytes 19296 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 udp dport 53 ip daddr 8.8.8.8 counter packets 81 bytes 5250 accept } } table ip nat { chain prerouting { type nat hook prerouting priority filter; policy accept; iifname \u0026#34;ens3\u0026#34; tcp dport 80 counter packets 4 bytes 240 dnat to 192.168.100.10 iifname \u0026#34;ens3\u0026#34; tcp dport 25 counter packets 1 bytes 60 dnat to 192.168.100.10 iifname \u0026#34;ens3\u0026#34; tcp dport 2222 counter packets 8 bytes 480 dnat to 192.168.100.10:22 } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.100.0/24 counter packets 916 bytes 61536 masquerade } } ","date":"March 28, 2024","hero":"/images/cortafuegos/nftables.png","permalink":"https://www.javiercd.es/posts/cortafuegos/nftables_uno/cortafuegos_uno/","summary":"En este post sobre un escenario con maquinas Debian , aplicaremos reglas con Nftables para conrtrolar el trafico que entra y sale en nuestra red , intentando imitar un escenario.\n[!NOTE]\nPara desplegar el escenario para realizar estos ejercicios necesitaras desplegar el fichero .yaml que encontraras en el enlace del párrafo siguiente . Este se encargara de desplegar 2 maquinas una que hará de cortafuegos y otra que simulara un cliente que estará conectado a la primera maquina para simular una red local .","tags":["FIREWALL","LINUX","DEBIAN","NFTABLES"],"title":"Implementación de un cortafuegos perimetral con Nftables I"},{"categories":null,"contents":" Sobre el escenario creado en el módulo de servicios con las máquinas Odin (Router), Hela (DMZ), Loki y Thor (LAN) y empleando nftables, configura un cortafuegos perimetral en la máquina Odin de forma que el escenario siga funcionando completamente teniendo en cuenta los siguientes puntos:\n• Se valorará la creación de cadenas diferentes para cada flujo de tráfico (de LAN al exterior, de LAN a DMZ, etc…). • Política por defecto DROP para todas las cadenas. • Se pueden usar las extensiones que creamos adecuadas, pero al menos debe implementarse seguimiento de la conexión cuando sea necesario. • Debemos implementar que el cortafuegos funcione después de un reinicio de la máquina. • Debes mostrar pruebas de funcionamiento de todas las reglas. Para no hacer demasiado larga la practica , voy a mostrarte los hits de las reglas al final , así como el script completo de las reglas . Ya que solo te pondré en cada ejercicio las reglas que intervienen y una comprobación del mismo .\nMontar el escenario con Nftables Voy a eliminar iptables y vamos a pasar a Nftables para que no perdamos ninguna funcionalidad del escenario .\nLo primero sera crear las tablas y cadenas :\njaviercruces@odin:~$ sudo nft add table inet filter javiercruces@odin:~$ sudo nft add chain inet filter input { type filter hook input priority 0 \\; counter \\; policy accept \\; } javiercruces@odin:~$ sudo nft add chain inet filter output { type filter hook output priority 0 \\; counter \\; policy accept \\; } javiercruces@odin:~$ sudo nft add chain inet filter WAN_LAN { type filter hook forward priority 0\\; counter \\; policy accept \\;} javiercruces@odin:~$ sudo nft add chain inet filter WAN_DMZ { type filter hook forward priority 0\\; counter \\; policy accept \\;} javiercruces@odin:~$ sudo nft add chain inet filter LAN_WAN { type filter hook forward priority 0\\; counter \\; policy accept \\;} javiercruces@odin:~$ sudo nft add chain inet filter LAN_DMZ { type filter hook forward priority 0\\; counter \\; policy accept \\;} javiercruces@odin:~$ sudo nft add chain inet filter DMZ_LAN { type filter hook forward priority 0\\; counter \\; policy accept \\;} javiercruces@odin:~$ sudo nft add chain inet filter DMZ_WAN { type filter hook forward priority 0\\; counter \\; policy accept \\;} Así quedarían nuestras cadenas creadas :\njaviercruces@odin:~$ sudo nft list chains table inet filter { chain input { type filter hook input priority filter; policy accept; } chain output { type filter hook output priority filter; policy accept; } chain WAN_LAN { type filter hook forward priority filter; policy accept; } chain WAN_DMZ { type filter hook forward priority filter; policy accept; } chain LAN_WAN { type filter hook forward priority filter; policy accept; } chain DMZ_LAN { type filter hook forward priority filter; policy accept; } chain LAN_DMZ { type filter hook forward priority filter; policy accept; } chain DMZ_WAN { type filter hook forward priority filter; policy accept; } } La red LAN corresponde a la red de los contenedores 192.168.0.0/24 . La red DMZ corresponde a la red de hela 172.16.0.0/16 .\nContinuamos creando la tabla de NAT para poder configurar el SNAT y el DNAT , estas ya que suelen ser un numero reducido de reglas no voy a crear distintas cadenas :\n# Creamos la tabla NAT javiercruces@odin:~$ sudo nft add table nat # Cadena para el DNAT javiercruces@odin:~$ sudo nft add chain nat prerouting { type nat hook prerouting priority 0 \\; } # Cadena para el SNAT javiercruces@odin:~$ sudo nft add chain nat postrouting { type nat hook postrouting priority 100 \\; } Reglas SNAT Una vez hecho esto voy a crear las reglas de SNAT para que nuestros clientes puedan salir a Internet en la red LAN y DMZ :\nMi tarjeta de red que esta de cara al exterior es la ens4 .\n# Regla SNAT para LAN sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter masquerade # Regla SNAT para DMZ sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; iffname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.0/16 counter masquerade sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter snat to 172.22.200.47 sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.0/16 counter snat to 172.22.200.47 Vamos a comprobar que en los clientes ya pueden acceder a Internet , actualmente la política por defecto es ACCEPT.\nComprobación de SNAT en Hela :\n[javiercruces@hela ~]$ ping www.javiercd.es -c 1 PING javierasping.github.io (185.199.109.153) 56(84) bytes of data. 64 bytes from cdn-185-199-109-153.github.com (185.199.109.153): icmp_seq=1 ttl=51 time=39.4 ms --- javierasping.github.io ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 39.439/39.439/39.439/0.000 ms Comprobación de SNAT en Thor :\njaviercruces@thor:~$ ping www.javiercd.es -c 1 PING javierasping.github.io (185.199.108.153) 56(84) bytes of data. 64 bytes from cdn-185-199-108-153.github.com (185.199.108.153): icmp_seq=1 ttl=51 time=38.1 ms --- javierasping.github.io ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 38.138/38.138/38.138/0.000 ms Comprobación de SNAT en Loki :\njaviercruces@loki:~$ ping www.javiercd.es -c 1 PING javierasping.github.io (185.199.111.153) 56(84) bytes of data. 64 bytes from cdn-185-199-111-153.github.com (185.199.111.153): icmp_seq=1 ttl=51 time=37.7 ms --- javierasping.github.io ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 37.667/37.667/37.667/0.000 ms Por ultimo nos aseguraremos de que la regla recibe hits :\njaviercruces@odin:~$ sudo nft list ruleset # Salida del comando recortada chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.0/16 counter packets 11 bytes 868 masquerade oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter packets 122 bytes 10594 masquerade } } Reglas de DNAT Las reglas anteriores que teníamos eran las siguientes :\njaviercruces@odin:~$ sudo iptables -L -t nat Chain PREROUTING (policy ACCEPT) target prot opt source destination DNAT tcp -- anywhere anywhere tcp dpt:http to:172.16.0.200 DNAT udp -- anywhere anywhere udp dpt:domain to:192.168.0.2 DNAT tcp -- anywhere anywhere tcp dpt:smtp to:192.168.0.3 DNAT tcp -- anywhere anywhere tcp dpt:mysql to:192.168.0.3 Así que vamos a pasarlas a nftables :\n# Para un wordpress que hay en hela sudo nft add rule ip nat prerouting tcp dport 80 counter dnat to 172.16.0.200 # Para hacer consultas DNS a thor sudo nft add rule ip nat prerouting udp dport 53 counter dnat to 192.168.0.2 # Para poder recibir correos en loki sudo nft add rule ip nat prerouting tcp dport 25 counter dnat to 192.168.0.3 # Para acceder desde fuera a un mysql que hay en loki sudo nft add rule ip nat prerouting tcp dport 3306 counter dnat to 192.168.0.3 Ahora vamos a añadir una series de reglas para permitir el trafico anterior y el resto de la preparacion del escenario :\n# PERMITIR USO DE ODIN ## Permitir consultas DNS de odin a thor (DNSSERVER) sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept ## Permitir tráfico HTTP y HTTPS en odin sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp dport { 80,443 } ct state new,established counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp sport { 80,443 } ct state established counter accept # Permitir conexiones SSH por el puerto 2222 sudo nft add rule ip nat prerouting iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter dnat to 192.168.0.1:22 sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state new,established counter accept # Permitir conexiones SSH de odin a hela sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.0/16 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.0/16 tcp sport 22 ct state established,related counter accept # Permitir conexiones ssh de odin a thor y loki sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.0/24 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.0/24 tcp sport 22 ct state established,related counter accept # Reglas perimetrales ## Permitir consultas DNS desde br-intra hacia ens4 , necesario para el forward del dns (ESTA REGLA SOLO ME FUNCIONA SI ESTA EN LA MISMA CADENA) #sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter accept #sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept ## Permitir consultas dns desde LAN a DMZ (hela --\u0026gt; thor) (ESTA REGLA SOLO ME FUNCIONA SI ESTA EN LA MISMA CADENA) #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter accept ## Reglas para permitir trafico a wordpress en hela sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept # Regla para hacer consultas DNS a thor (Permitir DNAT) sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 udp dport 53 ct state new,established counter accept sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.2 udp sport 53 ct state established,related counter accept # Regla para recibir e enviar correos en loki sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state new,established counter accept sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept # Permitir a hela usar el servidor LDAP sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; tcp dport 389 counter accept sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport 389 counter accept Ejercicios El cortafuegos debe cumplir al menos estas reglas:\nLa máquina Odin tiene un servidor ssh escuchando por el puerto 22, pero al acceder desde el exterior habrá que conectar al puerto 2222. Para realizar este ejercicio voy a hacer un DNAT a la interfaz de DMZ de odin que es la 192.168.0.1 , asi me conectare a esa interfaz por ssh . Posteriomente hay que permitir este trafico que va desde la ens4 a la ens3 .\n# Permitimos el trafico que ahora \u0026#34;cambiamos\u0026#34; el puerto con la regla DNAT de 2222 a 22 hacia odin sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state new,established counter accept # Regla DNAT sudo nft add rule ip nat prerouting iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter dnat to 192.168.0.1:22 Pondré la política por defecto DROP una vez llegado a este punto :\nsudo nft chain inet filter input { policy drop \\; } sudo nft chain inet filter output { policy drop \\; } sudo nft chain inet filter WAN_LAN { policy drop \\; } sudo nft chain inet filter WAN_DMZ { policy drop \\; } sudo nft chain inet filter LAN_WAN { policy drop \\; } sudo nft chain inet filter DMZ_LAN { policy drop \\; } sudo nft chain inet filter LAN_DMZ { policy drop \\; } sudo nft chain inet filter DMZ_WAN { policy drop \\; } Y vamos a comprobar que la conexión funciona por el puerto 2222 :\njaviercruces@HPOMEN15:~$ ssh 172.22.200.47 -p 2222 Linux odin.javiercd.gonzalonazareno.org 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat Mar 9 13:49:09 2024 from 172.29.0.58 javiercruces@odin:~$ Comprobamos los hits en las reglas :\njaviercruces@odin:~$ sudo nft list ruleset # IMPUT iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state established,new counter packets 241918 bytes 13788652 accept #OUTPUT oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter packets 355383 bytes 210012030 accept #DNAT iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter packets 5 bytes 300 dnat to 192.168.0.1:22 Desde Thor y Hela se debe permitir la conexión ssh por el puerto 22 a la máquina Odin. Para poder comprobar estas reglas voy a permitir las conexiones ssh desde Odin a ambas redes DMZ y LAN\n# Permitir conexiones ssh de odin a hela sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.0/16 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.0/16 tcp sport 22 ct state established,related counter accept # Permitir conexiones ssh de odin a thor y loki sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.0/24 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.0/24 tcp sport 22 ct state established,related counter accept # Permitir conexion ssh desde hela a odin sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.200 tcp dport 22 ct state new,established counter accept sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 ct state established counter accept # Permitir conexion ssh desde thor a odin sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.2 tcp dport 22 ct state new,established counter accept sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 tcp sport 22 ct state established counter accept Vamos a comprobar las 2 reglas anteriores conectándonos a Odin por ssh desde estos dos clientes :\n#Hela --\u0026gt; Odin javiercruces@odin:~$ ssh 172.16.0.200 -A Last login: Sat Mar 9 19:02:49 2024 from 172.16.0.1 [javiercruces@hela ~]$ ssh 172.16.0.1 Linux odin.javiercd.gonzalonazareno.org 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat Mar 9 19:49:28 2024 from 192.168.0.2 javiercruces@odin:~$ # Thor --\u0026gt; Odin javiercruces@thor:~$ ssh 192.168.0.1 Linux odin.javiercd.gonzalonazareno.org 6.1.0-18-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat Mar 9 19:46:12 2024 from 192.168.0.2 javiercruces@odin:~$ Te dejare los hits de las reglas al final de la practica .\nLa máquina Odin debe tener permitido el tráfico para la interfaz loopback. sudo nft add rule inet filter input iifname \u0026#34;lo\u0026#34; counter accept sudo nft add rule inet filter output oifname \u0026#34;lo\u0026#34; counter accept Comprobación :\njaviercruces@odin:~$ ping 127.0.0.1 -c 1 PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data. 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.100 ms --- 127.0.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.100/0.100/0.100/0.000 ms A la máquina Odin se le puede hacer ping desde la DMZ, pero desde la LAN se le debe rechazar la conexión (REJECT) y desde el exterior se rechazará de manera silenciosa. # DMZ sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-reply counter accept # Las siguientes 2 reglas , no funcionaran como esperamos ya que hacen lo mismo que la politica por defecto , ademas no se permite este trafico . # LAN sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip protocol icmp counter reject # Exterior sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip protocol icmp counter drop Vamos a comprobar estas reglas :\n# LAN Thor a odin javiercruces@thor:~$ ping 192.168.0.1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. From 192.168.0.1 icmp_seq=1 Destination Port Unreachable # DMZ , Hela --\u0026gt; Odin [javiercruces@hela ~]$ ping 172.16.0.1 -c 1 PING 172.16.0.1 (172.16.0.1) 56(84) bytes of data. 64 bytes from 172.16.0.1: icmp_seq=1 ttl=64 time=0.471 ms --- 172.16.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.471/0.471/0.471/0.000 ms # Exterior a odin javiercruces@HPOMEN15:~$ ping 172.22.200.47 PING 172.22.200.47 (172.22.200.47) 56(84) bytes of data. ^C --- 172.22.200.47 ping statistics --- 419 packets transmitted, 0 received, 100% packet loss, time 428036ms Al final de la practica te dejare todos los hits de las reglas .\nLa máquina Odin puede hacer ping a la LAN, la DMZ y al exterior. # PERMITIR PING A DMZ sudo nft insert rule inet filter output oifname \u0026#34;ens3\u0026#34; icmp type echo-request counter accept sudo nft insert rule inet filter input iifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter accept # PERMITIR PING A EXTERIOR sudo nft insert rule inet filter output oifname \u0026#34;ens4\u0026#34; icmp type echo-request counter accept sudo nft insert rule inet filter input iifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter accept # PERMITIR PING A LAN sudo nft insert rule inet filter output oifname \u0026#34;br-intra2\u0026#34; icmp type echo-request counter accept sudo nft insert rule inet filter input iifname \u0026#34;br-intra2\u0026#34; icmp type echo-reply counter accept Comprobación :\njaviercruces@odin:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=116 time=8.70 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 8.701/8.701/8.701/0.000 ms javiercruces@odin:~$ ping 192.168.0.2 -c 1 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=6.030 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.030/0.030/0.030/0.000 ms javiercruces@odin:~$ ping 172.16.0.200 -c 1 PING 172.16.0.200 (172.16.0.200) 56(84) bytes of data. 64 bytes from 172.16.0.200: icmp_seq=1 ttl=63 time=59.1 ms --- 172.16.0.200 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 59.052/59.052/59.052/0.000 ms Desde la máquina Hela se puede hacer ping y conexión ssh a las máquinas de la LAN. ## Si no estan en la cadena forward no funciona #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 ip protocol icmp icmp type echo-request counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 ip protocol icmp icmp type echo-reply counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp dport 22 counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 ip protocol icmp icmp type echo-reply counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp dport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 counter accept Comprobación :\n[javiercruces@hela ~]$ ping 192.168.0.2 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=63 time=0.596 ms ^C --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.596/0.596/0.596/0.000 ms [javiercruces@hela ~]$ ssh 192.168.0.2 Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 6.1.0-18-amd64 x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Sun Mar 10 14:52:57 2024 from 192.168.0.1 javiercruces@thor:~$ Desde cualquier máquina de la LAN se puede conectar por ssh a la máquina Hela. ## Si no esta en la cadena forward no funciona #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 22 counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 22 counter accept Comprobación :\njaviercruces@thor:~$ ssh 172.16.0.200 Last login: Sun Mar 10 14:53:12 2024 from 192.168.0.2 [javiercruces@hela ~]$ Configura la máquina Odin para que las máquinas de LAN y DMZ puedan acceder al exterior. Estas reglas ya estaban indicadas previamente .\nsudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter masquerade sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.0/16 counter masquerade Las máquinas de la LAN pueden hacer ping al exterior y navegar. # Las máquinas de la LAN pueden hacer ping al exterior y navegar. ## Si no estan en la cadena forward no funciona #sudo nft add rule inet filter LAN_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter accept #sudo nft add rule inet filter WAN_LAN iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip protocol icmp icmp type echo-reply counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip protocol icmp icmp type echo-reply counter accept Comprobación :\njaviercruces@thor:~$ curl -I https://www.javiercd.es HTTP/2 200 server: GitHub.com content-type: text/html; charset=utf-8 last-modified: Sat, 02 Mar 2024 10:17:01 GMT access-control-allow-origin: * strict-transport-security: max-age=31556952 etag: \u0026#34;65e2fc9d-675b\u0026#34; expires: Sun, 10 Mar 2024 15:35:43 GMT cache-control: max-age=600 x-proxy-cache: MISS x-github-request-id: E24C:3800B1:1881E48:18E9A93:65EDD0F7 accept-ranges: bytes date: Sun, 10 Mar 2024 19:14:10 GMT via: 1.1 varnish age: 60 x-served-by: cache-mad22083-MAD x-cache: HIT x-cache-hits: 1 x-timer: S1710098050.166466,VS0,VE2 vary: Accept-Encoding x-fastly-request-id: 0c6c80bbef19370976aadfc6988441c5a36beccc content-length: 26459 javiercruces@thor:~$ ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=110 time=38.5 ms ^C --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 38.451/38.451/38.451/0.000 ms La máquina Hela puede navegar. Instala un servidor web, un servidor ftp y un servidor de correos si no los tienes aún. # La máquina Hela puede navegar. Instala un servidor web, un servidor ftp y un servidor de correos si no los tienes aún. # Hela ya tiene permitido hacer consultas dns a thor sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; tcp dport {80, 443} counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport {80, 443} counter accept Compruebo que puedo navegar :\n[root@hela javiercruces]# curl -I https://www.javiercd.es/ HTTP/2 200 server: GitHub.com content-type: text/html; charset=utf-8 last-modified: Sat, 02 Mar 2024 10:17:01 GMT access-control-allow-origin: * strict-transport-security: max-age=31556952 etag: \u0026#34;65e2fc9d-675b\u0026#34; expires: Sun, 10 Mar 2024 15:35:43 GMT cache-control: max-age=600 x-proxy-cache: MISS x-github-request-id: E24C:3800B1:1881E48:18E9A93:65EDD0F7 accept-ranges: bytes date: Sun, 10 Mar 2024 19:13:17 GMT via: 1.1 varnish age: 7 x-served-by: cache-mad22067-MAD x-cache: HIT x-cache-hits: 1 x-timer: S1710097997.474757,VS0,VE2 vary: Accept-Encoding x-fastly-request-id: 2d2811893898abf05bebd96c6bd5a09ed7abfe5b content-length: 26459 Entiendo que quieres que instale estos 3 servicios en hela . En nuestro escenario son las otras maquinas quien alberga estos servicios .\nConfigura la máquina Odin para que los servicios web y ftp sean accesibles desde el exterior. El servidor web ya esta configurado previamente en la migración del escenario .\nsudo nft add rule ip nat prerouting tcp dport 21 counter dnat to 172.16.0.200 # No funcionan en cadenas separadas #sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept #sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept El servidor web y el servidor ftp deben ser accesibles desde la LAN y desde el exterior. El servidor FTP esta en la LAN así que ya es accesible , voy a hacer que sea accesible desde la DMZ . Desde el exterior ambos , ya son accesibles.\n## No funcionan las reglass en cadenas separadas #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept Acceso desde la DMZ a LAN :\njaviercruces@thor:~$ curl 172.16.0.200 \u0026lt;!DOCTYPE html\u0026gt; javiercruces@thor:~$ ftp 172.16.0.200 Connected to 172.16.0.200. 220 (vsFTPd 3.0.5) El servidor de correos sólo debe ser accesible desde la LAN. Comentamos las lineas de la preparación del escenario que permito el acceso a este y añadimos :\n# No funciona en cadenas separadas #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept Accedemos a el :\n[root@hela javiercruces]# telnet 192.168.0.3 25 Trying 192.168.0.3... Connected to 192.168.0.3. Escape character is \u0026#39;^]\u0026#39;. 220 loki.javiercd.gonzalonazareno.org ESMTP Postfix (Ubuntu) En la máquina Loki instala un servidor Postgres si no lo tiene aún. A este servidor se puede acceder desde la DMZ, pero no desde el exterior. # no funciona en cadenas distintas #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 5432 ct state { new, established } counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 5432 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 5432 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 5432 ct state established,related counter accept Accedemos al servidor postgree desde hela :\n[root@hela javiercruces]# psql -h 192.168.0.3 -U postgres Password for user postgres: psql (13.14, server 14.11 (Ubuntu 14.11-0ubuntu0.22.04.1)) WARNING: psql major version 13, server major version 14. Some psql features might not work. SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off) Type \u0026#34;help\u0026#34; for help. postgres=# Evita ataques DoS por ICMP Flood, limitando a 4 el número de peticiones por segundo desde una misma IP. sudo nft insert rule inet filter input icmp type echo-request limit rate 1/second burst 4 packets counter drop Si le hacemos un ataque de flood , este cortara el trafico :\n[root@hela javiercruces]# hping3 --icmp --flood --rand-source 172.16.0.1 HPING 172.16.0.1 (eth0 172.16.0.1): icmp mode set, 28 headers + 0 data bytes hping in flood mode, no replies will be shown icmp type echo-request limit rate 1/second burst 4 packets counter packets 46 bytes 2128 drop Evita ataques DoS por SYN Flood. # Evita ataques DoS por SYN Flood. sudo nft add rule inet filter input tcp flags \\\u0026amp; \u0026#39;(fin|syn|rst|ack) == syn\u0026#39; counter limit rate over 25/second drop Si probamos el ataque :\n[root@hela javiercruces]# hping3 --flood --rand-source 172.16.0.1 HPING 172.16.0.1 (eth0 172.16.0.1): NO FLAGS are set, 40 headers + 0 data bytes hping in flood mode, no replies will be shown ^C --- 172.16.0.1 hping statistic --- 1267916 packets transmitted, 0 packets received, 100% packet loss round-trip min/avg/max = 0.0/0.0/0.0 ms icmp type echo-request limit rate 1/second burst 4 packets counter packets 31 bytes 2492 drop Script con todas las reglas Te dejo aquí el script que he utilizado durante la practica .\n# Crear estructura de tablas sudo nft delete table inet filter sudo nft delete table ip nat ## Añadir tabla filter y sus cadenas sudo nft add table inet filter sudo nft add chain inet filter forward { type filter hook forward priority 10\\; counter \\; policy drop\\; } sudo nft add chain inet filter input { type filter hook input priority 0 \\; counter \\; policy drop \\; } sudo nft add chain inet filter output { type filter hook output priority 0 \\; counter \\; policy drop \\; } sudo nft add chain inet filter WAN_LAN { type filter hook forward priority 1\\; counter \\; policy accept \\;} sudo nft add chain inet filter WAN_DMZ { type filter hook forward priority 2\\; counter \\; policy accept \\;} sudo nft add chain inet filter LAN_WAN { type filter hook forward priority 3\\; counter \\; policy accept \\;} sudo nft add chain inet filter LAN_DMZ { type filter hook forward priority 4\\; counter \\; policy accept \\;} sudo nft add chain inet filter DMZ_LAN { type filter hook forward priority 5\\; counter \\; policy accept \\;} sudo nft add chain inet filter DMZ_WAN { type filter hook forward priority 6\\; counter \\; policy accept \\;} ## Añadir Tabla NAT y sus cadenas : sudo nft add table ip nat sudo nft add chain ip nat prerouting { type nat hook prerouting priority 0 \\; } sudo nft add chain ip nat postrouting { type nat hook postrouting priority 100 \\; } # Reglas para mantener el escenario de clase anterior con IPTABLES ## Reglas SNAT ### Regla SNAT para LAN sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter masquerade ### Regla SNAT para DMZ sudo nft add rule ip nat postrouting oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.0/16 counter masquerade ## Reglas DNAT # Para un wordpress que hay en hela sudo nft add rule ip nat prerouting tcp dport 80 counter dnat to 172.16.0.200 # Para hacer consultas DNS a thor #sudo nft add rule ip nat prerouting udp dport 53 counter dnat to 192.168.0.2 sudo nft add rule ip nat prerouting iifname \u0026#34;ens3\u0026#34; ip saddr { 172.22.0.0/16, 172.19.0.0/16 } udp dport 53 counter dnat to 192.168.0.2 # Para poder recibir correos en loki sudo nft add rule ip nat prerouting tcp dport 25 counter dnat to 192.168.0.3 # Para acceder desde fuera a un mysql que hay en loki sudo nft add rule ip nat prerouting tcp dport 3306 counter dnat to 192.168.0.3 # PERMITIR USO DE ODIN ## Permitir consultas DNS de odin a thor (DNSSERVER) sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept ## Permitir tráfico HTTP y HTTPS en odin sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp dport { 80,443 } ct state new,established counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp sport { 80,443 } ct state established counter accept # Permitir conexiones SSH por el puerto 2222 sudo nft add rule ip nat prerouting iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter dnat to 192.168.0.1:22 sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state new,established counter accept # Permitir conexiones SSH de odin a hela sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.0/16 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.0/16 tcp sport 22 ct state established,related counter accept # Permitir conexiones ssh de odin a thor y loki sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.0/24 tcp dport 22 counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.0/24 tcp sport 22 ct state established,related counter accept # Reglas perimetrales ## Permitir consultas DNS desde br-intra hacia ens4 , necesario para el forward del dns (ESTA REGLA SOLO ME FUNCIONA SI ESTA EN LA MISMA CADENA) sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter accept ## Permitir consultas dns desde LAN a DMZ (hela --\u0026gt; thor) (ESTA REGLA SOLO ME FUNCIONA SI ESTA EN LA MISMA CADENA) sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter accept ## Reglas para permitir trafico a wordpress en hela sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept # Regla para hacer consultas DNS a thor (Permitir DNAT) sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 udp dport 53 ct state new,established counter accept sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.2 udp sport 53 ct state established,related counter accept # Regla para recibir e enviar correos en loki # No funcionan en cadenas separadas #sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state new,established counter accept #sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state new,established counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept # Permitir a hela usar el servidor LDAP sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; tcp dport 389 counter accept sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport 389 counter accept # Ejercicios practica ## Permitir conexiones SSH por el puerto 2222 #sudo nft add rule ip nat prerouting iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter dnat to 192.168.0.1:22 #sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter accept #sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state new,established counter accept # Desde Thor y Hela se debe permitir la conexión ssh por el puerto 22 a la máquina Odin. ## Permitir conexion ssh desde hela a odin sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.200 tcp dport 22 ct state new,established counter accept sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 ct state established counter accept ## Permitir conexion ssh desde thor a odin sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.2 tcp dport 22 ct state new,established counter accept sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 tcp sport 22 ct state established counter accept #La máquina Odin debe tener permitido el tráfico para la interfaz loopback. sudo nft add rule inet filter input iifname \u0026#34;lo\u0026#34; counter accept sudo nft add rule inet filter output oifname \u0026#34;lo\u0026#34; counter accept # A la máquina Odin se le puede hacer ping desde la DMZ, pero desde la LAN se le debe rechazar la conexión (REJECT) y desde el exterior se rechazará de manera silenciosa. sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; ip protocol icmp icmp type echo-reply counter accept ## Denegar la conexion desde LAN REJECT sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; ip protocol icmp counter reject ## Denegar de manera silenciosa desde EXTERIOR sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; ip protocol icmp counter drop # La máquina Odin puede hacer ping a la LAN, la DMZ y al exterior. ## LAN sudo nft add rule inet filter output oifname \u0026#34;ens3\u0026#34; icmp type echo-request counter accept sudo nft add rule inet filter input iifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter accept ## EXTERIOR sudo nft add rule inet filter output oifname \u0026#34;ens4\u0026#34; icmp type echo-request counter accept sudo nft add rule inet filter input iifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter accept ## DMZ sudo nft add rule inet filter output oifname \u0026#34;br-intra2\u0026#34; icmp type echo-request counter accept sudo nft add rule inet filter input iifname \u0026#34;br-intra2\u0026#34; icmp type echo-reply counter accept #### Desde la máquina Hela se puede hacer ping y conexión ssh a las máquinas de la LAN. sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 ip protocol icmp icmp type echo-reply counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp dport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 counter accept ## Si no estan en la cadena forward no funciona #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 ip protocol icmp icmp type echo-request counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 ip protocol icmp icmp type echo-reply counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp dport 22 counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 counter accept # Desde cualquier máquina de la LAN se puede conectar por ssh a la máquina Hela. sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 22 counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 22 counter accept ## Si no esta en la cadena forward no funciona #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 22 counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 22 counter accept # Configura la máquina Odin para que las máquinas de LAN y DMZ puedan acceder al exterior. ## SNAT hecho anteriormente # Las máquinas de la LAN pueden hacer ping al exterior y navegar. ## Si no estan en la cadena forward no funciona #sudo nft add rule inet filter LAN_WAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter accept #sudo nft add rule inet filter WAN_LAN iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip protocol icmp icmp type echo-reply counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip protocol icmp icmp type echo-reply counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; tcp dport {80, 443} counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; tcp sport {80, 443} counter accept # La máquina Hela puede navegar. Instala un servidor web, un servidor ftp y un servidor de correos si no los tienes aún. # Hela ya tiene permitido hacer consultas dns a thor sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; tcp dport {80, 443} counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport {80, 443} counter accept # ### Configura la máquina Odin para que los servicios web y ftp sean accesibles desde el exterior. sudo nft add rule ip nat prerouting tcp dport 21 counter dnat to 172.16.0.200 # No funcionan en cadenas separadas #sudo nft add rule inet filter WAN_DMZ iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept #sudo nft add rule inet filter DMZ_WAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept # ### El servidor web y el servidor ftp deben ser accesibles desde la LAN y desde el exterior. ## No funcionan las reglass en cadenas separadas #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter accept # ### El servidor de correos sólo debe ser accesible desde la LAN. # no funciona en cadenas separadas #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state { new, established } counter accept #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter accept # ### En la máquina Loki instala un servidor Postgres si no lo tiene aún. A este servidor se puede acceder desde la DMZ, pero no desde el exterior. # no funciona en cadenas distintas #sudo nft add rule inet filter LAN_DMZ iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 5432 ct state { new, established } counter accept #sudo nft add rule inet filter DMZ_LAN iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 5432 ct state established,related counter accept sudo nft add rule inet filter forward iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 5432 ct state { new, established } counter accept sudo nft add rule inet filter forward iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 5432 ct state established,related counter accept # ### Evita ataques DoS por ICMP Flood, limitando a 4 el número de peticiones por segundo desde una misma IP. sudo nft insert rule inet filter input icmp type echo-request limit rate 1/second burst 4 packets counter drop # ### Evita ataques DoS por SYN Flood. #sudo nft insert rule inet filter input tcp flags \\\u0026amp; \u0026#39;(fin|syn|rst|ack) == syn\u0026#39; counter limit rate over 25/second drop #### Evita que realicen escaneos de puertos a Odin. #sudo nft insert rule inet filter input tcp flags \u0026amp; (fin|syn|rst|ack) == (syn) counter drop #sudo nft add rule inet filter output udp dport 53 counter accept #sudo nft add rule inet filter input udp sport 53 counter accept Hits de las reglas Cada vez que he ejecutado el script las reglas pierden los contadores pero así seria el esquema con todas las reglas al finalizar la practica :\njaviercruces@odin:~$ sudo nft list ruleset table inet filter { chain forward { type filter hook forward priority filter + 10; policy drop; counter packets 711 bytes 171730 iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter packets 107 bytes 8505 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter packets 107 bytes 93423 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter packets 11 bytes 758 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter packets 11 bytes 1818 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state established,new counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter packets 0 bytes 0 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 ip protocol icmp icmp type echo-request counter packets 2 bytes 168 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 ip protocol icmp icmp type echo-reply counter packets 2 bytes 168 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp dport 22 counter packets 160 bytes 16502 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 counter packets 100 bytes 15086 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 22 counter packets 30 bytes 6041 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 22 counter packets 23 bytes 5213 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip protocol icmp icmp type echo-request counter packets 1 bytes 84 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip protocol icmp icmp type echo-reply counter packets 1 bytes 84 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; tcp dport { 80, 443 } counter packets 16 bytes 1666 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; tcp sport { 80, 443 } counter packets 17 bytes 4947 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; tcp dport { 80, 443 } counter packets 32 bytes 3332 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport { 80, 443 } counter packets 34 bytes 9903 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { established, new } counter packets 0 bytes 0 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 21 ct state { established, new } counter packets 0 bytes 0 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 21 ct state established,related counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { established, new } counter packets 18 bytes 1064 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter packets 14 bytes 1348 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 25 ct state { established, new } counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 25 ct state established,related counter packets 0 bytes 0 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.3 tcp dport 5432 ct state { established, new } counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; ip saddr 192.168.0.3 tcp sport 5432 ct state established,related counter packets 0 bytes 0 accept } chain input { type filter hook input priority filter; policy drop; icmp type echo-request limit rate 1/second burst 4 packets counter packets 13 bytes 1092 drop counter packets 1490 bytes 141906 iifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter packets 18 bytes 2352 accept iifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp sport { 80, 443 } ct state established counter packets 17 bytes 13286 accept iifname \u0026#34;ens4\u0026#34; tcp dport 22 ct state established,new counter packets 965 bytes 70084 accept iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.0/16 tcp sport 22 ct state established,related counter packets 356 bytes 39980 accept iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.0/24 tcp sport 22 ct state established,related counter packets 131 bytes 15952 accept iifname \u0026#34;ens3\u0026#34; ip saddr 172.16.0.200 tcp dport 22 ct state established,new counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; ip saddr 192.168.0.2 tcp dport 22 ct state established,new counter packets 0 bytes 0 accept iifname \u0026#34;lo\u0026#34; counter packets 0 bytes 0 accept iifname \u0026#34;ens3\u0026#34; ip protocol icmp icmp type echo-request counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; ip protocol icmp counter packets 1 bytes 84 reject with icmp port-unreachable iifname \u0026#34;ens3\u0026#34; ip protocol icmp counter packets 1 bytes 84 drop iifname \u0026#34;ens3\u0026#34; icmp type echo-reply counter packets 0 bytes 0 accept iifname \u0026#34;ens4\u0026#34; icmp type echo-reply counter packets 1 bytes 84 accept iifname \u0026#34;br-intra2\u0026#34; icmp type echo-reply counter packets 0 bytes 0 accept iifname \u0026#34;lo\u0026#34; counter packets 0 bytes 0 accept } chain output { type filter hook output priority filter; policy drop; counter packets 1404 bytes 207511 oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter packets 18 bytes 1304 accept oifname \u0026#34;ens4\u0026#34; ip protocol tcp tcp dport { 80, 443 } ct state established,new counter packets 19 bytes 7331 accept oifname \u0026#34;ens4\u0026#34; tcp sport 22 ct state established counter packets 577 bytes 142596 accept oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.0/16 tcp dport 22 counter packets 547 bytes 38208 accept oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.0/24 tcp dport 22 counter packets 194 bytes 14400 accept oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp sport 22 ct state established counter packets 0 bytes 0 accept oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 tcp sport 22 ct state established counter packets 0 bytes 0 accept oifname \u0026#34;lo\u0026#34; counter packets 12 bytes 1008 accept oifname \u0026#34;ens3\u0026#34; ip protocol icmp icmp type echo-reply counter packets 0 bytes 0 accept oifname \u0026#34;ens3\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept oifname \u0026#34;ens4\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept oifname \u0026#34;br-intra2\u0026#34; icmp type echo-request counter packets 1 bytes 84 accept oifname \u0026#34;lo\u0026#34; counter packets 0 bytes 0 accept } chain WAN_LAN { type filter hook forward priority filter + 1; policy accept; counter packets 711 bytes 171730 } chain WAN_DMZ { type filter hook forward priority filter + 2; policy accept; counter packets 711 bytes 171730 iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp sport 53 counter packets 107 bytes 93423 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;ens3\u0026#34; ip daddr 172.16.0.200 tcp dport 80 ct state { established, new } counter packets 0 bytes 0 accept iifname \u0026#34;ens4\u0026#34; oifname \u0026#34;br-intra2\u0026#34; ip daddr 192.168.0.2 udp dport 53 ct state established,new counter packets 0 bytes 0 accept } chain LAN_WAN { type filter hook forward priority filter + 3; policy accept; counter packets 711 bytes 171730 } chain LAN_DMZ { type filter hook forward priority filter + 4; policy accept; counter packets 711 bytes 171730 iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; udp dport 53 counter packets 11 bytes 758 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;br-intra2\u0026#34; tcp dport 389 counter packets 0 bytes 0 accept } chain DMZ_LAN { type filter hook forward priority filter + 5; policy accept; counter packets 711 bytes 171730 iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; udp sport 53 counter packets 11 bytes 1818 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens3\u0026#34; tcp sport 389 counter packets 0 bytes 0 accept } chain DMZ_WAN { type filter hook forward priority filter + 6; policy accept; counter packets 711 bytes 171730 iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; udp dport 53 counter packets 107 bytes 8505 accept iifname \u0026#34;ens3\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.200 tcp sport 80 ct state established,related counter packets 0 bytes 0 accept iifname \u0026#34;br-intra2\u0026#34; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.2 udp sport 53 ct state established,related counter packets 0 bytes 0 accept } } table ip nat { chain prerouting { type nat hook prerouting priority filter; policy accept; tcp dport 80 counter packets 8 bytes 480 dnat to 172.16.0.200 iifname \u0026#34;ens3\u0026#34; ip saddr { 172.19.0.0/16, 172.22.0.0/16 } udp dport 53 counter packets 0 bytes 0 dnat to 192.168.0.2 tcp dport 25 counter packets 0 bytes 0 dnat to 192.168.0.3 tcp dport 3306 counter packets 12 bytes 720 dnat to 192.168.0.3 iifname \u0026#34;ens4\u0026#34; tcp dport 2222 counter packets 0 bytes 0 dnat to 192.168.0.1:22 tcp dport 21 counter packets 0 bytes 0 dnat to 172.16.0.200 } chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname \u0026#34;ens4\u0026#34; ip saddr 192.168.0.0/24 counter packets 109 bytes 8649 masquerade oifname \u0026#34;ens4\u0026#34; ip saddr 172.16.0.0/16 counter packets 2 bytes 120 masquerade } } Hacer las reglas persistentes Vamos a guardar las reglas con :\nroot@odin:/home/javiercruces# nft list ruleset \u0026gt; /etc/nftables.conf Si las queremos restaurar :\njaviercruces@odin:~$ sudo nft -f /etc/nftables.conf Para hacer que al reiniciar las reglas se restauren solas :\n# Creamos la unidad de systemd javiercruces@odin:~$ sudo cat /etc/systemd/system/nftables-persistent.service [Unit] Description=Cargar reglas de nftables al iniciar el sistema [Service] Type=oneshot ExecStart=/usr/sbin/nft -f /etc/nftables/nftables.rules [Install] WantedBy=multi-user.target # Activa el servicio para que al reiniciar se apliquen los cambios javiercruces@odin:~$ sudo systemctl enable nftables-persistent.service ","date":"March 28, 2024","hero":"/images/cortafuegos/nftables.png","permalink":"https://www.javiercd.es/posts/cortafuegos/nftables_dos/cortafuegos_dos/","summary":"Sobre el escenario creado en el módulo de servicios con las máquinas Odin (Router), Hela (DMZ), Loki y Thor (LAN) y empleando nftables, configura un cortafuegos perimetral en la máquina Odin de forma que el escenario siga funcionando completamente teniendo en cuenta los siguientes puntos:\n• Se valorará la creación de cadenas diferentes para cada flujo de tráfico (de LAN al exterior, de LAN a DMZ, etc…). • Política por defecto DROP para todas las cadenas.","tags":["FIREWALL","LINUX","DEBIAN","NFTABLES"],"title":"Implementación de un cortafuegos perimetral con Nftables II"},{"categories":null,"contents":" Para descargarnos la imagen de android puedes hacerlo desde esta pagina \u0026ndash;\u0026gt; https://www.fosshub.com/Android-x86.html :\nwget https://www.fosshub.com/Android-x86.html?dwl=android-x86_64-9.0-r2.iso Crea una maquina en KVM como si fuese un Debian , yo le he dado 2GB de RAM y 2 cores :\nEn nuestro caso podemos lanzar una instalación automática :\nCuando tengas la maquina instalada , apaga la maquina y vamos a importarla en gns3 . Para ello vamos a llevarnos el disco de KVM y vamos a importarlo en el directorio donde hayamos instalado las imágenes de GNS3 , luego haz propiedad del disco copiado a tu usuario .\ncp /var/lib/libvirt/images/android-wireguard.qcow2 /home/javiercruces/GNS3/images/QEMU/ javiercruces@HPOMEN15:~$ sudo chown javiercruces:javiercruces /home/javiercruces/GNS3/images/QEMU/android-wireguard.qcow2 Ahora accede a tu GNS3 y en preferencias vamos a añadir una nueva QEMU VMs :\nSelecciona el binario de emulación x86_64 y asignale la memoria que consideres oportuna , a mi con 2GB me funciona correctamente :\nComo la imagen utiliza entorno gráfico vamos a seleccionar VNC :\nY selecciona el disco que hemos copiado a la carpeta images anteriormente :\n","date":"March 28, 2024","hero":"/images/redes/android_gns3/android.png","permalink":"https://www.javiercd.es/posts/redes/android_gns3/android/","summary":"Para descargarnos la imagen de android puedes hacerlo desde esta pagina \u0026ndash;\u0026gt; https://www.fosshub.com/Android-x86.html :\nwget https://www.fosshub.com/Android-x86.html?dwl=android-x86_64-9.0-r2.iso Crea una maquina en KVM como si fuese un Debian , yo le he dado 2GB de RAM y 2 cores :\nEn nuestro caso podemos lanzar una instalación automática :\nCuando tengas la maquina instalada , apaga la maquina y vamos a importarla en gns3 . Para ello vamos a llevarnos el disco de KVM y vamos a importarlo en el directorio donde hayamos instalado las imágenes de GNS3 , luego haz propiedad del disco copiado a tu usuario .","tags":["GNS3","ANDORID","LINUX","DEBIAN","KVM"],"title":"Instalación de android en GNS3 con KVM"},{"categories":null,"contents":" En primer lugar configurare la maquina servidor1 como servidor VPN de acceso remoto y servidor2 como cliente VPN . Posteriormente configurare un cliente Windows y Android .\nLo primero que haremos sera instalarnos tanto en ambas maquinas el paquete Wireguard :\nroot@servidor1:~# sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard debian@servidor2:~$ sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard Vamos a generar los pares de claves que se utilizarán para cifrar la conexión. Necesitaremos una clave para el servidor y un par de claves adicionales por cada cliente.\nComenzaremos con el par de claves del servidor1:\ndebian@servidor1:~$ wg genkey | sudo tee /etc/wireguard/server_private.key | wg pubkey | sudo tee /etc/wireguard/server_public.key 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= # Puedes visualizar la clave privada posteriormente : debian@servidor1:~$ sudo cat /etc/wireguard/server_private.key 2Gg3EnKD+rdyMPEjMikZTwq2w0m78KrEcUsAJ/8icFA= # Puedes visualizar la clave publica posteriormente : debian@servidor1:~$ sudo cat /etc/wireguard/server_public.key 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= Nos desplazamos al servidor2 y les generamos las suyas :\n# Generamos el par de claves para el cliente de acceso remoto servidor2 debian@servidor2:~$ wg genkey | sudo tee /etc/wireguard/client_private.key | wg pubkey | sudo tee /etc/wireguard/client_public.key gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= # Puedes visualizar la clave privada posteriormente : debian@servidor2:~$ sudo cat /etc/wireguard/client_private.key 8IdsSwunfU5zJQzS5nZg4D//cFEbRa+27HGOQE1V90k= # Puedes visualizar la clave publica posteriormente : debian@servidor2:~$ sudo cat /etc/wireguard/client_public.key gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= Una vez generado las claves , vamos a proceder a configurar el servidor de acceso remoto Wireguard , en mi caso voy a llamar al fichero de configuración wg0.conf . Voy a añadirte en cada parámetro de la configuración un comentario para que sepas que tienes que poner en cada campo :\ndebian@servidor1:~$ sudo cat /etc/wireguard/wg0.conf [Interface] # IP que tendrá el túnel VPN , en concreto la interfaz wg0 que es como has llamado el fichero de conf Address = 10.99.99.1 #Clave privada del servidor PrivateKey = 2Gg3EnKD+rdyMPEjMikZTwq2w0m78KrEcUsAJ/8icFA= #Puerto de escucha , 51820 es el puerto por defecto de Wireguard ListenPort = 51820 # Si no tienes activado el bit de forwarding por defecto puedes hacerlo asi : PreUp = sysctl -w net.ipv4.ip_forward=1 # Este apartado hace referencia a la configuración de los clientes : [Peer] #Clave pública del cliente Publickey = gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= #IP del túnel VPN del cliente AllowedIPs = 10.99.99.2/32 #Tiempo de espera que tendrá activo el túnel si no hay trafico PersistentKeepAlive = 25 Ahora configuraremos un cliente debian , le he dado el mismo nombre al fichero de configuración por lo que la interfaz también se llamara wg0 :\ndebian@servidor2:~$ sudo cat /etc/wireguard/wg0.conf [Interface] Address = 10.99.99.2/24 #Clave privada del cliente PrivateKey = 8IdsSwunfU5zJQzS5nZg4D//cFEbRa+27HGOQE1V90k= #Puerto de escucha del servidor ListenPort = 51820 [Peer] #Clave pública del servidor PublicKey = 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= AllowedIPs = 0.0.0.0/0 #Punto de acceso del servidor Endpoint = 90.0.0.2:51820 #Tiempo de espera de la conexión PersistentKeepalive = 25 Una vez tenemos configurados ambos ficheros levantaremos el túnel , para ello tenemos varias formas de hacerlo , personalmente la mas cómoda que veo es usando el comando wg-quick .\nLevantamos el túnel en el servidor :\ndebian@servidor1:~$ sudo wg-quick up wg0 [#] sysctl -w net.ipv4.ip_forward=1 net.ipv4.ip_forward = 1 [#] ip link add wg0 type wireguard [#] wg setconf wg0 /dev/fd/63 [#] ip -4 address add 10.99.99.1 dev wg0 [#] ip link set mtu 1420 up dev wg0 [#] ip -4 route add 10.99.99.2/32 dev wg0 Levantamos el otro extremo , en este caso nuestro cliente es servidor2 :\ndebian@servidor2:~$ sudo wg-quick up wg0 [#] ip link add wg0 type wireguard [#] wg setconf wg0 /dev/fd/63 [#] ip -4 address add 10.99.99.2/24 dev wg0 [#] ip link set mtu 1420 up dev wg0 [#] wg set wg0 fwmark 51820 [#] ip -4 route add 0.0.0.0/0 dev wg0 table 51820 [#] ip -4 rule add not fwmark 51820 table 51820 [#] ip -4 rule add table main suppress_prefixlength 0 [#] sysctl -q net.ipv4.conf.all.src_valid_mark=1 [#] iptables-restore -n Una vez hecho esto comprobaremos que en ambos extremos se nos ha creado una nueva interfaz , que se llama igual que nuestro fichero de configuración sin la extensión .conf .\nComprobamos que se haya creado en servidor1 :\ndebian@servidor1:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 90.0.0.2/24 brd 90.0.0.255 scope global ens3 valid_lft forever preferred_lft forever 3: ens4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s4 inet 192.168.0.1/24 brd 192.168.0.255 scope global ens4 valid_lft forever preferred_lft forever 6: wg0: \u0026lt;POINTOPOINT,NOARP,UP,LOWER_UP\u0026gt; mtu 1420 qdisc noqueue state UNKNOWN group default qlen 1000 inet 10.99.99.1/32 scope global wg0 valid_lft forever preferred_lft forever Comprobamos que se haya creado en servidor2 :\ndebian@servidor2:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 100.0.0.2/24 brd 100.0.0.255 scope global ens3 valid_lft forever preferred_lft forever 3: ens4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s4 inet 192.168.1.1/24 brd 192.168.1.255 scope global ens4 valid_lft forever preferred_lft forever 6: wg0: \u0026lt;POINTOPOINT,NOARP,UP,LOWER_UP\u0026gt; mtu 1420 qdisc noqueue state UNKNOWN group default qlen 1000 inet 10.99.99.2/24 scope global wg0 valid_lft forever preferred_lft forever También comprobaremos las rutas que se nos ha creado en el servidor y en el cliente :\ndebian@servidor1:~$ ip r default via 90.0.0.1 dev ens3 onlink 10.99.99.2 dev wg0 scope link 10.99.99.4 dev wg0 scope link 90.0.0.0/24 dev ens3 proto kernel scope link src 90.0.0.2 192.168.0.0/24 dev ens4 proto kernel scope link src 192.168.0.1 debian@servidor2:~$ ip r default via 100.0.0.1 dev ens3 onlink 10.99.99.0/24 dev wg0 proto kernel scope link src 10.99.99.2 100.0.0.0/24 dev ens3 proto kernel scope link src 100.0.0.2 192.168.1.0/24 dev ens4 proto kernel scope link src 192.168.1.1 Vamos a comprobar que desde nuestro cliente (servidor2) tenemos acceso a las distintas maquinas de nuestra red :\n## Ping con el túnel del extremo servidor1 debian@servidor2:~$ ping 10.99.99.1 -c 1 PING 10.99.99.1 (10.99.99.1) 56(84) bytes of data. 64 bytes from 10.99.99.1: icmp_seq=1 ttl=64 time=14.9 ms --- 10.99.99.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 14.862/14.862/14.862/0.000 ms ## Pings con cliente1 : debian@servidor2:~$ ping 192.168.0.2 -c 1 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=63 time=17.5 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 17.503/17.503/17.503/0.000 ms # Ping con cliente2 debian@servidor2:~$ ping 192.168.0.3 -c 1 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=63 time=16.5 ms --- 192.168.0.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 16.522/16.522/16.522/0.000 ms ## Ping con la ip privada del servidor1 debian@servidor2:~$ ping 192.168.0.1 -c 1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=20.3 ms --- 192.168.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 20.272/20.272/20.272/0.000 ms Aunque como esta montado mi escenario , las direcciones IP privadas no están erutadas vamos a comprobar que el trafico va por el túnel , haciendo uso de traceroute :\ndebian@servidor2:~$ traceroute 192.168.0.2 traceroute to 192.168.0.2 (192.168.0.2), 30 hops max, 60 byte packets 1 10.99.99.1 (10.99.99.1) 18.692 ms 28.987 ms 28.951 ms 2 192.168.0.2 (192.168.0.2) 28.912 ms 28.877 ms 28.859 ms Configuración cliente android La maquina virtual de android es bastante incomoda de controlar , así que voy a generarle las claves y su fichero de configuración en el servidor1 . Posteriormente se lo haremos llegar descargandonoslo de este con apache .\nNos generamos las claves para android :\ndebian@servidor1:~$ wg genkey | tee androidprivate | wg pubkey \u0026gt; androidpublic debian@servidor1:~$ cat androidprivate CBY5o2iko7xXQrNAFcFDIKohOngawB1uvws7aDDgl0g= debian@servidor1:~$ cat androidpublic cBGl5QWOsbZyI2GN1MXDxUsfeMmI5sKnp3VkxW9lO3g= El fichero de configuración seria el siguiente :\ndebian@servidor1:~$ sudo cat android.conf [Interface] Address = 10.99.99.4 PrivateKey = CBY5o2iko7xXQrNAFcFDIKohOngawB1uvws7aDDgl0g= ListenPort = 51820 [Peer] Publickey = 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= AllowedIPs = 0.0.0.0/0 Endpoint = 90.0.0.2:51820 Me he instalado apache y copiare este archivo al document root para hacerlo llegar a la maquina android . Uso este medio ya que es un escenario ficticio .\ndebian@servidor1:~$ sudo cp android.conf /var/www/html/ Desde una terminal , ya que el navegador no funciona demasiado bien nos descargamos el fichero : Ahora vamos a añadir en el fichero de configuración del servidor este nuevo cliente :\ndebian@servidor1:~$ sudo cat /etc/wireguard/wg0.conf #Al final del todo :) [Peer] Publickey = cBGl5QWOsbZyI2GN1MXDxUsfeMmI5sKnp3VkxW9lO3g= AllowedIPs = 10.99.99.4/32 PersistentKeepAlive = 25 No olvides reiniciar el túnel :\ndebian@servidor1:~$ sudo wg-quick down wg0 debian@servidor1:~$ sudo wg-quick up wg0 Ahora abre la aplicación de wireguard y dale a importar desde archivo y activa la conexión . Activa el túnel y asegúrate de que se produce el handshake :\nSi abrimos una terminal podremos hacerle pings a los clientes :\nConfiguración del cliente Windows Vamos a repetir el proceso pero ahora con nuestro cliente Windows .\nPara poder copiar y pegar voy a realizar la generación de claves de este cliente en la maquina servidor1 .\nComenzaremos generando el par de claves\ndebian@servidor1:~$ wg genkey | tee winprivate | wg pubkey \u0026gt; winpublic debian@servidor1:~$ cat winprivate QKGQEdrB9FBYRZsLNgc3qr9m8/lx+uc9n5vvj67I9m8= debian@servidor1:~$ cat winpublic E8VdupsWJ7vCTO7SF3oXUciUrsRgJ3p6T+F5UbbLngo= Nos creamos el fichero de configuración para este cliente :\ndebian@servidor1:~$ cat win.conf [Interface] Address = 10.99.99.5 PrivateKey = QKGQEdrB9FBYRZsLNgc3qr9m8/lx+uc9n5vvj67I9m8= ListenPort = 51820 [Peer] Publickey = 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= AllowedIPs = 0.0.0.0/0 Endpoint = 90.0.0.2:51820 Lo moveré al document root para poder descargarlo en mi Windows , no hagas esto en un entorno real .\ndebian@servidor1:~$ sudo cp win.conf /var/www/html/ Recuerda configurar en la maquina servidor1 este nuevo cliente :\ndebian@servidor1:~$ sudo nano /etc/wireguard/wg0.conf [Peer] Publickey = E8VdupsWJ7vCTO7SF3oXUciUrsRgJ3p6T+F5UbbLngo= AllowedIPs = 10.99.99.5/32 PersistentKeepAlive = 25 Para que se apliquen los cambios reinicia el túnel :\ndebian@servidor1:~$ sudo wg-quick down wg0 debian@servidor1:~$ sudo wg-quick up wg0 Una vez tenemos todo configurado , accede a la maquina Windows y descargate el fichero de configuración :\nAbre la aplicación de wireguard y selecciona importar desde archivo :\nUna vez añadido activa el túnel y comprueba que se ha producido el handshake :\nSi volvemos a nuestro Windows , se nos habrá creado una nueva interfaz :\nY tendremos conectividad con las maquinas de la red 192.168.0.0/24 :\nA modo de curiosidad podemos ver en el servidor que clientes están conectados :\ndebian@servidor1:~$ sudo wg show interface: wg0 public key: 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= private key: (hidden) listening port: 51820 peer: cBGl5QWOsbZyI2GN1MXDxUsfeMmI5sKnp3VkxW9lO3g= endpoint: 100.0.0.2:51820 allowed ips: 10.99.99.4/32 latest handshake: 1 minute, 14 seconds ago transfer: 6.43 KiB received, 788 B sent persistent keepalive: every 25 seconds peer: E8VdupsWJ7vCTO7SF3oXUciUrsRgJ3p6T+F5UbbLngo= endpoint: 100.0.0.2:49981 allowed ips: 10.99.99.5/32 latest handshake: 1 minute, 32 seconds ago transfer: 46.23 KiB received, 1.64 KiB sent persistent keepalive: every 25 seconds peer: gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= allowed ips: 10.99.99.2/32 persistent keepalive: every 25 seconds ","date":"March 28, 2024","hero":"/images/vpn/wireguard.png","permalink":"https://www.javiercd.es/posts/vpn/acceso_remoto_wireguard/acceso_remoto_wireguard/","summary":"En primer lugar configurare la maquina servidor1 como servidor VPN de acceso remoto y servidor2 como cliente VPN . Posteriormente configurare un cliente Windows y Android .\nLo primero que haremos sera instalarnos tanto en ambas maquinas el paquete Wireguard :\nroot@servidor1:~# sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard debian@servidor2:~$ sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard Vamos a generar los pares de claves que se utilizarán para cifrar la conexión.","tags":["VPN","CISCO","LINUX","DEBIAN","WIREGUARD"],"title":"VPN acceso remoto Wireguard"},{"categories":null,"contents":" StrongSwan es una implementación de VPN (Red Privada Virtual) basada en IPsec, de código abierto, multiplataforma, completa y ampliamente utilizada. Funciona en sistemas operativos como Linux, FreeBSD, OS X, Windows, Android e iOS. Principalmente, es un demonio de intercambio de claves que admite los protocolos de Intercambio de Claves de Internet (IKEv1 e IKEv2) para establecer asociaciones de seguridad (SA) entre dos pares.\n[!NOTE]\nVoy a partir del post de VPN acceso remoto con OpenVPN , asi que es posible que haga referencia a este durante este articulo . Si quieres tener el mismo escenario ve primero a este .\nRecuerda que para la configuración que vamos a hacer tienes que activar el bit de forwarding en las maquinas Servidor1 y Servidor2 .\nInstalación de StrongSwan Comenzaremos instalando el paquete StrongSwan en ambas maquinas :\ndebian@servidor1:~$ sudo apt install strongswan -y debian@servidor2:~$ sudo apt install strongswan -y Configuración de StrongSwan Servidor 1 A continuación configuraremos el servidor 1 , voy a ponerte un comentario para que sepas que significada cada opción :\ndebian@servidor1:~$ sudo cat /etc/ipsec.conf # Configuración global de strongSwan config setup charondebug=\u0026#34;ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2\u0026#34; # Configuración por defecto para conexiones VPN conn %default ikelifetime=1h # Tiempo de vida de la negociación de intercambio de claves y SA. keylife=1h # Tiempo de vida de la llave del cifrado. rekeymargin=5m # Margen de tiempo antes de la expiración para la renovación. keyingtries=3 # Número máximo de intentos de renegociación. keyexchange=ikev2 # Versión del protocolo IKE. authby=secret # Uso de autenticación con clave precompartida (PSK). ike=aes256-sha1-modp1024 # Configuración de algoritmos para la fase IKE. esp=aes256-sha1 # Configuración de algoritmos para la fase ESP. conn servidor2a1 left=90.0.0.2 # Dirección IP publica de la maquina (servidor1). leftsubnet=192.168.0.0/24 # Subred privada de la maquina servidor 1. right=100.0.0.2 # Dirección IP publica del otro extremo (servidor2). rightsubnet=192.168.1.0/24 # Subred privada del otro extremo (servidor 2). auto=start # Iniciar la conexión automáticamente al arrancar strongSwan. Servidor 2 A continuación configuraremos el servidor 2 , voy a ponerte un comentario para que sepas que significada cada opción :\ndebian@servidor2:~$ sudo cat /etc/ipsec.conf # Configuración global de strongSwan config setup charondebug=\u0026#34;ike 2, knl 2, cfg 2, net 2, esp 2, dmn 2, mgr 2\u0026#34; # Configuración por defecto para conexiones VPN conn %default ikelifetime=1h # Tiempo de vida de la negociación de intercambio de claves y SA. keylife=1h # Tiempo de vida de la llave del cifrado. rekeymargin=5m # Margen de tiempo antes de la expiración para la renovación. keyingtries=3 # Número máximo de intentos de renegociación. keyexchange=ikev2 # Versión del protocolo IKE. authby=secret # Uso de autenticación con clave precompartida (PSK). ike=aes256-sha1-modp1024 # Configuración de algoritmos para la fase IKE. esp=aes256-sha1 # Configuración de algoritmos para la fase ESP. conn servidor2a1 left=100.0.0.2 # Dirección IP publica de la maquina. leftsubnet=192.168.1.0/24 # Subred privada de la maquina. right=90.0.0.2 # Dirección IP publica del servidor1. rightsubnet=192.168.0.0/24 # Subred privada del servidor 1. auto=start # Iniciar la conexión automáticamente al arrancar strongSwan. Generación de la clave compartida Una vez que hayas configurado ambas máquinas, es necesario acordar el uso de una clave compartida denominada PSK (Pre-Shared Key). Puedes generar una PSK de manera aleatoria para mejorar la seguridad de la conexión. A continuación, te proporciono un ejemplo de cómo generar una clave aleatoria :\ndebian@servidor1:~$ head -c 24 /dev/urandom | base64 cXPeOAcKIVszFHp68CcGX6dLXcWcbrIl Ahora en el fichero /etc/ipsec.secrets configuraremos la clave PSK , que en ambos extremos tiene que ser la misma :\ndebian@servidor1:~$ sudo cat /etc/ipsec.secrets # Ip publica de la maquina servidor 1 90.0.0.2 : PSK \u0026#34;cXPeOAcKIVszFHp68CcGX6dLXcWcbrIl\u0026#34; debian@servidor2:~$ sudo cat /etc/ipsec.secrets # Ip publica de la maquina servidor 2 100.0.0.2 : PSK \u0026#34;cXPeOAcKIVszFHp68CcGX6dLXcWcbrIl\u0026#34; Una vez configurado , reiniciaremos el servicio en ambos extremos :\ndebian@servidor1:~$ sudo ipsec restart debian@servidor2:~$ sudo ipsec restart Comprobación de funcionamiento Ahora comprobaremos que se ha levantado el túnel en ambos extremos :\ndebian@servidor1:~$ sudo ipsec status Security Associations (1 up, 0 connecting): servidor1a2[1]: ESTABLISHED 62 seconds ago, 90.0.0.2[90.0.0.2]...100.0.0.2[100.0.0.2] servidor1a2{1}: INSTALLED, TUNNEL, reqid 1, ESP SPIs: ccb4e51d_i c186cf93_o servidor1a2{1}: 192.168.0.0/24 === 192.168.1.0/24 debian@servidor2:~$ sudo ipsec status Security Associations (1 up, 0 connecting): servidor2a1[2]: ESTABLISHED 45 seconds ago, 100.0.0.2[100.0.0.2]...90.0.0.2[90.0.0.2] servidor2a1{2}: INSTALLED, TUNNEL, reqid 1, ESP SPIs: c186cf93_i ccb4e51d_o servidor2a1{2}: 192.168.1.0/24 === 192.168.0.0/24 Es cierto que, a diferencia de OpenVPN y WireGuard, StrongSwan no crea automáticamente una interfaz virtual para la conexión VPN. En lugar de ello, utiliza las rutas del sistema operativo para dirigir el tráfico a través del túnel IPSec.\nTablas de enrutamiento Podemos ver estas rutas de la siguiente manera , estas están guardadas en la tabla 220:\ndebian@servidor1:~$ ip r show table 220 192.168.1.0/24 via 90.0.0.1 dev ens3 proto static src 192.168.0.1 debian@servidor2:~$ ip route list table 220 192.168.0.0/24 via 100.0.0.1 dev ens3 proto static src 192.168.1.1 Comprobación de conectividad Una vez hecho esto vamos a comprobar que la maquina servidor2 puede llegar a las maquinas de la red 192.168.0.0/24 :\ndebian@servidor2:~$ ping -c 1 192.168.0.1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=12.7 ms --- 192.168.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 12.721/12.721/12.721/0.000 ms debian@servidor2:~$ ping -c 1 192.168.0.2 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=63 time=11.5 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 11.485/11.485/11.485/0.000 ms Estadísticas de los túneles Si quieres ver si el trafico ha pasado por el \u0026ldquo;túnel\u0026rdquo; , puedes hacer un statusall y ver las estadísticas :\ndebian@servidor1:~$ sudo ipsec statusall Status of IKE charon daemon (strongSwan 5.9.8, Linux 6.1.0-17-cloud-amd64, x86_64): uptime: 9 minutes, since Jan 28 10:44:01 2024 malloc: sbrk 2166784, mmap 0, used 1242160, free 924624 worker threads: 11 of 16 idle, 5/0/0/0 working, job queue: 0/0/0/0, scheduled: 2 loaded plugins: charon test-vectors ldap pkcs11 aes rc2 sha2 sha1 md5 mgf1 random nonce x509 revocation constraints pubkey pkcs1 pkcs7 pkcs12 pgp dnskey sshkey pem openssl gcrypt pkcs8 af-alg fips-prf gmp curve25519 agent chapoly xcbc cmac hmac kdf ctr ccm gcm drbg curl attr kernel-netlink resolve socket-default connmark forecast farp stroke updown eap-identity eap-aka eap-md5 eap-gtc eap-mschapv2 eap-radius eap-tls eap-ttls eap-tnc xauth-generic xauth-eap xauth-pam tnc-tnccs dhcp lookip error-notify certexpire led addrblock unity counters Listening IP addresses: 90.0.0.2 192.168.0.1 Connections: servidor1a2: 90.0.0.2...100.0.0.2 IKEv2 servidor1a2: local: [90.0.0.2] uses pre-shared key authentication servidor1a2: remote: [100.0.0.2] uses pre-shared key authentication servidor1a2: child: 192.168.0.0/24 === 192.168.1.0/24 TUNNEL Security Associations (1 up, 0 connecting): servidor1a2[1]: ESTABLISHED 9 minutes ago, 90.0.0.2[90.0.0.2]...100.0.0.2[100.0.0.2] servidor1a2[1]: IKEv2 SPIs: 80b3e1894dc769f5_i* 92c50ec8c2dedde7_r, pre-shared key reauthentication in 43 minutes servidor1a2[1]: IKE proposal: AES_CBC_256/HMAC_SHA1_96/PRF_HMAC_SHA1/MODP_1024 servidor1a2{1}: INSTALLED, TUNNEL, reqid 1, ESP SPIs: ccb4e51d_i c186cf93_o servidor1a2{1}: AES_CBC_256/HMAC_SHA1_96, 252 bytes_i (3 pkts, 358s ago), 280 bytes_o (3 pkts, 355s ag o), rekeying in 41 minutes servidor1a2{1}: 192.168.0.0/24 === 192.168.1.0/24 Captura con Wireshark Ademas puedes hacer una captura del trafico y asegurarte de que los mensajes van cifrados :\nComprobación con traceroute Ademas es curioso porque si haces un traceroute el primer salto que da es a la interfaz 192.168.0.1 del servidor1 :\ndebian@servidor2:~$ traceroute 192.168.0.2 traceroute to 192.168.0.2 (192.168.0.2), 30 hops max, 60 byte packets 1 192.168.0.1 (192.168.0.1) 13.695 ms 13.658 ms 13.712 ms 2 192.168.0.2 (192.168.0.2) 13.704 ms 13.695 ms 13.678 ms ","date":"March 28, 2024","hero":"/images/vpn/strongswan.png","permalink":"https://www.javiercd.es/posts/vpn/acceso_remoto_strongswang/strongswang/","summary":"StrongSwan es una implementación de VPN (Red Privada Virtual) basada en IPsec, de código abierto, multiplataforma, completa y ampliamente utilizada. Funciona en sistemas operativos como Linux, FreeBSD, OS X, Windows, Android e iOS. Principalmente, es un demonio de intercambio de claves que admite los protocolos de Intercambio de Claves de Internet (IKEv1 e IKEv2) para establecer asociaciones de seguridad (SA) entre dos pares.\n[!NOTE]\nVoy a partir del post de VPN acceso remoto con OpenVPN , asi que es posible que haga referencia a este durante este articulo .","tags":["VPN","LINUX","DEBIAN","STRONGSWAN"],"title":"VPN de acceso remoto con Ipsec StrongSwan"},{"categories":null,"contents":" Uno de los dos equipos (el que actuará como servidor) estará conectado a dos redes Para la autenticación de los extremos se usarán obligatoriamente certificados digitales, que se generarán utilizando openssl y se almacenarán en el directorio /etc/openvpn, junto con los parámetros Diffie-Helman y el certificado de la propia Autoridad de Certificación. Se utilizarán direcciones de la red 10.99.99.0/24 para las direcciones virtuales de la VPN. La dirección 10.99.99.1 se asignará al servidor VPN. Los ficheros de configuración del servidor y del cliente se crearán en el directorio /etc/openvpn de cada máquina, y se llamarán servidor.conf y cliente.conf respectivamente. Tras el establecimiento de la VPN, la máquina cliente debe ser capaz de acceder a una máquina que esté en la otra red a la que está conectado el servidor. Montando el escenario Para realizar este ejercicio he montado el siguiente escenario en GNS3 :\nConfiguración del router cisco Vamos a darle a cada interfaz la configuración de red correspondiente :\n# Interfaz que nos dará internet R1#configure terminal R1(config)#interface fastEthernet 0/0 R1(config-if)#ip add dhcp R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 1 R1(config)#interface fastEthernet 1/0 R1(config-if)#ip add 90.0.0.1 255.255.255.0 R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 2 R1(config)#interface fastEthernet 1/1 R1(config-if)#ip add 100.0.0.1 255.255.255.0 R1(config-if)#no shut R1(config-if)#exit # Ruta por defecto para internet R1(config)#ip route 0.0.0.0 0.0.0.0 192.168.122.1 # Guarda la configuración R1#write # Configuración de SNAT R1#conf term R1(config)#access-list 1 permit 90.0.0.0 0.0.0.255 R1(config)#access-list 1 permit 100.0.0.0 0.0.0.255 R1(config)# ip nat pool NAT-Pool 192.168.122.127 192.168.122.127 prefix-length 24 R1(config)#ip nat inside source list 1 pool NAT-Pool overload R1(config)#interface FastEthernet0/0 R1(config-if)#ip nat outside R1(config)#interface FastEthernet1/0 R1(config-if)#ip nat inside R1(config)#interface FastEthernet1/1 R1(config-if)#ip nat inside Configuración del Servidor 1 Configuración de red servidor 1 :\ndebian@servidor1:~$ cat /etc/network/interfaces auto lo iface lo inet loopback auto ens3 iface ens3 inet static address 90.0.0.2 netmask 255.255.255.0 gateway 90.0.0.1 dns-nameservers 8.8.8.8 auto ens4 iface ens4 inet static address 192.168.0.1 netmask 255.255.255.0 Ademas configuraremos el SNAT :\n#Activa el bit de forwarding debian@servidor1:~$ sudo nano /etc/sysctl.conf net.ipv4.ip_forward=1 # Regla SNAT debian@servidor1:~$ sudo iptables -t nat -A POSTROUTING -o ens3 -s 192.168.0.0/24 -j MASQUERADE # Te recomiendo que lo hagas permanente , configura iptables-persistent debian@servidor1:~$ sudo apt install iptables-persistent Configuración del Servidor 2 Configuración de red servidor 2 :\ndebian@servidor2:~$ cat /etc/network/interfaces auto lo iface lo inet loopback auto ens3 iface ens3 inet static address 100.0.0.2 netmask 255.255.255.0 gateway 100.0.0.1 dns-nameservers 8.8.8.8 auto ens4 iface ens4 inet static address 192.168.1.1 netmask 255.255.255.0 Ademas configuraremos el SNAT :\n#Activa el bit de forwarding debian@servidor2:~$ sudo nano /etc/sysctl.conf net.ipv4.ip_forward=1 # Regla SNAT debian@servidor2:~$ sudo iptables -t nat -A POSTROUTING -o ens3 -s 192.168.1.0/24 -j MASQUERADE # Te recomiendo que lo hagas permanente , configura iptables-persistent debian@servidor2:~$ sudo apt install iptables-persistent Comprobación enroutamiento Vamos a comprobar que hemos enroutado bien nuestro escenario , para ello desde los servidores haremos un ping al contrario y ha Internet .\nDesde servidor 1 :\ndebian@servidor1:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=37.4 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 37.374/37.374/37.374/0.000 ms debian@servidor1:~$ debian@servidor1:~$ ping 100.0.0.2 -c 1 PING 100.0.0.2 (100.0.0.2) 56(84) bytes of data. 64 bytes from 100.0.0.2: icmp_seq=1 ttl=63 time=18.6 ms --- 100.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 18.567/18.567/18.567/0.000 ms debian@servidor1:~$ Desde el servidor 2 :\ndebian@servidor2:~$ ping 90.0.0.2 -c 1 PING 90.0.0.2 (90.0.0.2) 56(84) bytes of data. 64 bytes from 90.0.0.2: icmp_seq=1 ttl=63 time=19.1 ms --- 90.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 19.099/19.099/19.099/0.000 ms debian@servidor2:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=160 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 160.147/160.147/160.147/0.000 ms debian@servidor2:~$ También comprobaremos desde los clientes ya que hay configurado un snat .\nDesde el cliente 1 :\ndebian@cliente1:~$ ping 100.0.0.2 -c 1 PING 100.0.0.2 (100.0.0.2) 56(84) bytes of data. 64 bytes from 100.0.0.2: icmp_seq=1 ttl=62 time=19.0 ms --- 100.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 18.968/18.968/18.968/0.000 ms debian@cliente1:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=61.6 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 61.598/61.598/61.598/0.000 ms Desde el cliente 3 :\ndebian@cliente3:~$ ping 90.0.0.2 -c 1 PING 90.0.0.2 (90.0.0.2) 56(84) bytes of data. 64 bytes from 90.0.0.2: icmp_seq=1 ttl=62 time=15.7 ms --- 90.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 15.656/15.656/15.656/0.000 ms debian@cliente3:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=45.8 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 45.760/45.760/45.760/0.000 ms Instalación de OpenVPN Instalaremos en ambos servidores el paquete openvpn\n# Servidor 1 debian@servidor1:~$ sudo apt install -y openvpn # Servidor 2 debian@servidor2:~$ sudo apt install -y openvpn Generación de claves y certificados Podemos generar los certificados manualmente, pero existe una herramienta llamada Easy RSA que automatiza este proceso. Además, Easy RSA facilita la generación de los módulos Diffie-Hellman, que son esenciales para el funcionamiento del servidor OpenVPN.\nNo es necesario que nos la descarguemos ya que esta viene con el paquete openvpn .\nPara OpenVPN necesitamos crear:\nUna clave privada y un certificado x509 para la autoridad certificante que firma (CA) Una clave privada y un certificado x509 firmado para el servidor. Una clave privada y un certificado x509 firmado para cada cliente. Un grupo Diffie-Hellman para el servidor. En el servidor 1, copiaremos el archivo de ejemplo de variables para evitar la solicitud repetitiva de información como organización, país, provincia, etc., por parte de EasyRSA.\ndebian@servidor1:/usr/share/easy-rsa$ sudo cp vars.example vars Editaremos el mismo y cambiaremos los siguientes valores :\ndebian@servidor1:/usr/share/easy-rsa$ sudo nano vars set_var EASYRSA_REQ_COUNTRY \u0026#34;ES\u0026#34; set_var EASYRSA_REQ_PROVINCE \u0026#34;Sevilla\u0026#34; set_var EASYRSA_REQ_CITY \u0026#34;Dos Hermanas\u0026#34; set_var EASYRSA_REQ_ORG \u0026#34;iesgn\u0026#34; set_var EASYRSA_REQ_EMAIL \u0026#34;contacto@javiercd.es\u0026#34; set_var EASYRSA_REQ_OU \u0026#34;Informatica\u0026#34; Una vez cambiado los valores por defecto por los nuestros , vamos a iniciar la infraestructura de clave pública (PKI) utilizando el script EasyRSA. Al ejecutar este comando, se crea un nuevo directorio PKI con la estructura necesaria para gestionar las claves y certificados.\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa init-pki * Notice: init-pki complete; you may now create a CA or requests. Your newly created PKI dir is: * /usr/share/easy-rsa/pki Generación de los parámetros Diffie-Hellman La clave de intercambio de Diffie-Hellman, es un método criptográfico que permite a dos partes acordar de forma segura una clave de sesión compartida sobre un canal no seguro. Así que vamos a generarla haciedo uso del siguiente comando :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-dh * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) Generating DH parameters, 2048 bit long safe prime ......... * Notice: DH parameters of size 2048 created at /usr/share/easy-rsa/pki/dh.pem Se nos habrá generado la clave en /usr/share/easy-rsa/pki/dh.pem , tal y como indica la salida del comando .\nGeneración del certificado de la CA Vamos a proceder a generar el certificado de nuestra CA :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa build-ca nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) Using configuration from /usr/share/easy-rsa/pki/52a64968/temp.25a8f31d You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [Easy-RSA CA]:ca.javiercd.es * Notice: CA creation complete and you may now import and sign cert requests. Your new CA certificate file for publishing is at: /usr/share/easy-rsa/pki/ca.crt Se nos habrá generado en /usr/share/easy-rsa/pki/ca.crt\nGeneración del certificado del servidor 1 Con el siguiente comando generaremos los certificados para el servidor 1 . Se generaran varios archivos :\nservidor1.req : Este archivo contiene la solicitud de certificado generada para el servidor servidor1.key : Este archivo contiene la clave privada debian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-req servidor1 nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) ....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*..+........+...+.+......+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+............+...+....+...+.....+...+...+......+....+.....+......+...+.+..+...+....+..+...............+......+.........+......+.......+.....+......+.+........+.+.....+......+...............+.+.....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ....+............+..+.+...+...........+....+...........+......+...+.+...+..+.+........+....+...+.....+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.........+............+...+.....+....+..+...+.+...............+.....+......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*......+........+..........+...+.................+.+..+....+.....+..........+...+......+.........+.....+.+............+..+..................+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [servidor1]: * Notice: Keypair and certificate request completed. Your files are: req: /usr/share/easy-rsa/pki/reqs/servidor1.req key: /usr/share/easy-rsa/pki/private/servidor1.key Ahora vamos a firmar el certificado del servidor1 con la clave privada de la CA .\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa sign-req server servidor1 * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a server certificate for 825 days: subject= commonName = servidor1 Type the word \u0026#39;yes\u0026#39; to continue, or any other input to abort. Confirm request details: yes Using configuration from /usr/share/easy-rsa/pki/e66a9d70/temp.40a6d9dd Check that the request matches the signature Signature ok The Subject\u0026#39;s Distinguished Name is as follows commonName :ASN.1 12:\u0026#39;servidor1\u0026#39; Certificate is to be certified until Apr 18 16:15:16 2026 GMT (825 days) Write out database with 1 new entries Database updated * Notice: Certificate created at: /usr/share/easy-rsa/pki/issued/servidor1.crt Como puedes ver tendremos los 3 ficheros referentes a nuestro servidor 1 generados :\n# Certificado firmado debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/issued | grep servidor1 -rw------- 1 root root 4637 Jan 14 16:15 servidor1.crt # Clave privada debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/private | grep servidor1 -rw------- 1 root root 1704 Jan 14 16:09 servidor1.key # Solicitud de firma del certificado debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/reqs | grep servidor1 -rw------- 1 root root 891 Jan 14 16:09 servidor1.req Generación del certificado del servidor 2 Repetiremos el mismo proceso que hemos realizado para el servidor 1 , pero ahora para nuestro servidor 2 .\nGeneraremos la clave y el certificado :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-req servidor2 nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) .+.+.................+...+...+.......+..+.+...........+.+..+.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*........+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+....+..+..........+....................+.......+.....+.......+...+..+................+..+.......+.........+...........+....+..+...+.+......+..+...+....+.....+.........+....+......+......+.........+..+...+............+...+.+...+..+....+............+...............+..+...+.............+............+.....+.......+.....+.+......+........+.....................+.+......+..+.+......+.....+.........+......+.........+.......+...+...............+.....+...............+.+....................+......+...+................+...+...+............+.....+...............+.......+......+........+......+....+......+........+.+.....+....+..+.+........+.+.....+.+.....+...........................+......+.+...+.....+......+....+..+....+......+........+.............+..+...+.........+....+..+...+....+...+...+...........+......+...................+.....+................+...+..+....+...+..+......+...+..........+..+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ..........+............+...+....+...+.....+...+......+.+.....+.......+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.........+.+......+..+.+..+...+.........+............+..................+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+...+...........+.+...+..+....+..............+......+...............+.+......+..............+....+......+..................+...+............+..+....+.....+.......+...+.........+..+......+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [servidor2]: * Notice: Keypair and certificate request completed. Your files are: req: /usr/share/easy-rsa/pki/reqs/servidor2.req key: /usr/share/easy-rsa/pki/private/servidor2.key Fíjate que ahora a este certificado a la hora de firmarlo diremos que es de tipo cliente . Ya que el servidor 2 \u0026ldquo;actuara como un cliente\u0026rdquo;:\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa sign-req client servidor2 * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a client certificate for 825 days: subject= commonName = servidor2 Type the word \u0026#39;yes\u0026#39; to continue, or any other input to abort. Confirm request details: yes Using configuration from /usr/share/easy-rsa/pki/8e1b2785/temp.504078d9 Check that the request matches the signature Signature ok The Subject\u0026#39;s Distinguished Name is as follows commonName :ASN.1 12:\u0026#39;servidor2\u0026#39; Certificate is to be certified until Apr 18 16:57:49 2026 GMT (825 days) Write out database with 1 new entries Database updated * Notice: Certificate created at: /usr/share/easy-rsa/pki/issued/servidor2.crt Generación de la clave TLS Este paso es opcional , pero es recomendable generar una clave compartida (también conocida como clave de parámetro adicional o clave ta.key) en el contexto de OpenVPN.)\nEn el contexto de OpenVPN, esta clave compartida (ta.key) se utiliza para firmar y verificar todos los paquetes de datos transmitidos a través de la conexión VPN. Su propósito principal es proporcionar una capa adicional de seguridad y autenticación, ayudando a prevenir ataques como el de replay.\ndebian@servidor1:/usr/share/easy-rsa$ sudo openvpn --genkey --secret ta.key Distribuir las claves Ahora tenemos que hacer llegar cada clave a su lugar correspondiente .\nEn el servidor 1 crearemos el directorio /etc/openvpn/keys y guardaremos los siguientes ficheros :\n# Creamos el directorio donde guardaremos las claves debian@servidor1:/usr/share/easy-rsa$ sudo mkdir /etc/openvpn/keys # Nos la copiamos al directorio creado debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/dh.pem /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/ca.crt /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/private/servidor1.key /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/issued/servidor1.crt /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/ta.key /etc/openvpn/keys # Comprobamos que tenemos todoos los ficheros necesarios debian@servidor1:~$ sudo ls -l /etc/openvpn/keys total 24 -rw------- 1 root root 1216 Jan 14 17:08 ca.crt -rw------- 1 root root 424 Jan 14 17:08 dh.pem -rw------- 1 root root 4637 Jan 14 17:08 servidor1.crt -rw------- 1 root root 1704 Jan 14 17:08 servidor1.key -rw------- 1 root root 636 Jan 14 17:08 ta.key Ahora haremos lo mismo para el servidor2 , pero tendremos que llevarnos las claves haciendo uso de SCP\n# Creamos el directorio donde guardaremos las claves debian@servidor2:~$ sudo mkdir /etc/openvpn/keys # Desde servidor1 pasare a servidor2 las claves debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/ca.crt debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/ta.key debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/private/servidor2.key debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/issued/servidor2.crt debian@100.0.0.2:/home/debian # Las movemos a /etc/openvpn/keys debian@servidor2:~$ sudo mv * /etc/openvpn/keys # Nos aseguramos de tener los 4 ficheros que hemos enviado : debian@servidor2:~$ sudo ls -l /etc/openvpn/keys total 20 -rw------- 1 debian debian 1216 Jan 14 17:12 ca.crt -rw------- 1 debian debian 4515 Jan 14 17:14 servidor2.crt -rw------- 1 debian debian 1704 Jan 14 17:13 servidor2.key -rw------- 1 debian debian 636 Jan 14 17:13 ta.key Configuración de OpenVPN Configuración de OpenVPN en el servidor 1 Asegúrate de tener activado el bit de forwarding en tu servidor :\ndebian@servidor1:~$ sudo sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 1 Vamos a editar el fichero /etc/default/openvpn y descomentaremos la siguiente linea para indicar que se inicien automaticamente todos los túneles vpn :\nAUTOSTART=\u0026#34;all\u0026#34; Crearemos un fichero de configuración para nuestro servidor , en mi caso mi configuración es la siguiente :\ndebian@servidor1:~$ sudo nano /etc/openvpn/servidor1.conf # Use a dynamic TUN device dev tun # Use tcp for communicating with the client proto tcp # Virtual IP range for the VPN clients server 10.99.99.0 255.255.255.0 # Push the route for the local subnet to the clients push \u0026#34;route 192.168.0.0 255.255.255.0\u0026#34; # Enable TLS and assume the server role tls-server # Diffie-Hellman parameters dh /etc/openvpn/keys/dh.pem # Certificate Authority\u0026#39;s certificate ca /etc/openvpn/keys/ca.crt # Server\u0026#39;s certificate cert /etc/openvpn/keys/servidor1.crt # Server\u0026#39;s private key key /etc/openvpn/keys/servidor1.key # Use fast LZO compression comp-lzo # Ping the remote every 10 seconds and restart after 60 seconds keepalive 10 60 # Set output verbosity to normal usage range verb 3 Ahora reinicia el servicio para que se apliquen los cambios y se levante la interfaz . Es posible que necesites reiniciar la maquina :\ndebian@servidor1:~$ sudo systemctl restart openvpn.service Y veremos que se ha levantado la interfaz tun0 :\ndebian@servidor1:~$ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 0c:21:18:28:00:00 brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 90.0.0.2/24 brd 90.0.0.255 scope global ens3 valid_lft forever preferred_lft forever inet6 fe80::e21:18ff:fe28:0/64 scope link valid_lft forever preferred_lft forever 3: ens4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 0c:21:18:28:00:01 brd ff:ff:ff:ff:ff:ff altname enp0s4 inet 192.168.0.1/24 brd 192.168.0.255 scope global ens4 valid_lft forever preferred_lft forever inet6 fe80::e21:18ff:fe28:1/64 scope link valid_lft forever preferred_lft forever 4: tun0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 10.99.99.1 peer 10.99.99.2/32 scope global tun0 valid_lft forever preferred_lft forever inet6 fe80::8491:9eb9:104e:6bf7/64 scope link stable-privacy valid_lft forever preferred_lft forever Configuración de OpenVPN en el servidor 2 Asegúrate de tener activado el bit de forwarding en tu servidor :\ndebian@servidor2:~$ sudo sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 1 Vamos a editar el fichero /etc/default/openvpn y descomentaremos la siguiente linea para indicar que se inicien automaticamente todos los túneles vpn :\nAUTOSTART=\u0026#34;all\u0026#34; Crearemos un fichero de configuración para nuestro servidor , en mi caso mi configuración es la siguiente :\ndebian@servidor2:~$ sudo nano /etc/openvpn/servidor2.conf # Use a dynamic TUN device dev tun # Connect to server remote 90.0.0.2 # Set virtual point-to-point IP addresses ifconfig 10.99.99.0 255.255.255.0 pull # Use TCP for communicating with server proto tcp-client # Enable TLS and assume client role during TLS handshake tls-client # Certificado de la CA ca /etc/openvpn/keys/ca.crt # Certificado del cliente cert /etc/openvpn/keys/servidor2.crt # Clave privada del cliente key /etc/openvpn/keys/servidor2.key # Use fast LZO compression comp-lzo # Ping remote every 10sg and restart after 60sg passed without sign of life from remote keepalive 10 60 # Set output verbosity to normal usage range verb 3 # Output logging messages to openvpn.log file log /var/log/openvpn.log Ahora reinicia el servicio para que se apliquen los cambios y se levante la interfaz . Es posible que necesites reiniciar la maquina :\ndebian@servidor2:~$ sudo systemctl restart openvpn.service Y veremos que se ha levantado la interfaz tun0 :\ndebian@servidor2:~$ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 0c:82:67:88:00:00 brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 100.0.0.2/24 brd 100.0.0.255 scope global ens3 valid_lft forever preferred_lft forever inet6 fe80::e82:67ff:fe88:0/64 scope link valid_lft forever preferred_lft forever 3: ens4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 0c:82:67:88:00:01 brd ff:ff:ff:ff:ff:ff altname enp0s4 inet 192.168.1.1/24 brd 192.168.1.255 scope global ens4 valid_lft forever preferred_lft forever inet6 fe80::e82:67ff:fe88:1/64 scope link valid_lft forever preferred_lft forever 4: tun0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 10.99.99.6 peer 10.99.99.5/32 scope global tun0 valid_lft forever preferred_lft forever inet6 fe80::67f5:fd86:d948:132a/64 scope link stable-privacy valid_lft forever preferred_lft forever Comprobación de funcionamiento Ahora vamos a comprobar que desde servidor2 podemos acceder a las maquinas clientes de la red 192.168.0.0/24 .\ndebian@servidor2:~$ ip r default via 100.0.0.1 dev ens3 onlink 10.99.99.1 via 10.99.99.5 dev tun0 10.99.99.5 dev tun0 proto kernel scope link src 10.99.99.6 100.0.0.0/24 dev ens3 proto kernel scope link src 100.0.0.2 192.168.0.0/24 via 10.99.99.5 dev tun0 192.168.1.0/24 dev ens4 proto kernel scope link src 192.168.1.1 Como puedes ver tendremos conectividad desde el servidor hacia los equipos de la otra red.\ndebian@servidor2:~$ ping 192.168.0.2 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=63 time=16.4 ms 64 bytes from 192.168.0.2: icmp_seq=2 ttl=63 time=14.3 ms 64 bytes from 192.168.0.2: icmp_seq=3 ttl=63 time=19.1 ms ^C --- 192.168.0.2 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 14.308/16.582/19.060/1.945 ms También podremos conectarnos por ssh , me conectare hacia el cliente 1 :\ndebian@servidor2:~$ ssh debian@192.168.0.2 The authenticity of host \u0026#39;192.168.0.2 (192.168.0.2)\u0026#39; can\u0026#39;t be established. ED25519 key fingerprint is SHA256:zn2i5rAyilMi1i+Kqb6ys8GhldKuHKYZCDKbD1aXqjQ. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added \u0026#39;192.168.0.2\u0026#39; (ED25519) to the list of known hosts. debian@192.168.0.2\u0026#39;s password: Linux cliente1 6.1.0-15-cloud-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.66-1 (2023-12-09) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Jan 14 15:29:30 2024 debian@cliente1:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 192.168.0.2/24 brd 192.168.0.255 scope global ens3 valid_lft forever preferred_lft forever ","date":"March 28, 2024","hero":"/images/vpn/remoteaccess.png","permalink":"https://www.javiercd.es/posts/vpn/acceso_remoto_openvpn/accesoremoto_openvpn/","summary":"Uno de los dos equipos (el que actuará como servidor) estará conectado a dos redes Para la autenticación de los extremos se usarán obligatoriamente certificados digitales, que se generarán utilizando openssl y se almacenarán en el directorio /etc/openvpn, junto con los parámetros Diffie-Helman y el certificado de la propia Autoridad de Certificación. Se utilizarán direcciones de la red 10.99.99.0/24 para las direcciones virtuales de la VPN. La dirección 10.99.99.1 se asignará al servidor VPN.","tags":["VPN","CISCO","LINUX","DEBIAN","OPENVPN"],"title":"VPN de acceso remoto con OpenVPN y certificados x509"},{"categories":null,"contents":" Montando el escenario Para realizar este ejercicio he montado el siguiente escenario en GNS3 :\nConfiguración del router cisco Vamos a darle a cada interfaz la configuración de red correspondiente :\n# Interfaz que nos dará internet R1#configure terminal R1(config)#interface fastEthernet 0/0 R1(config-if)#ip add dhcp R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 1 R1(config)#interface fastEthernet 1/0 R1(config-if)#ip add 90.0.0.1 255.255.255.0 R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 2 R1(config)#interface fastEthernet 1/1 R1(config-if)#ip add 100.0.0.1 255.255.255.0 R1(config-if)#no shut R1(config-if)#exit # Ruta por defecto para internet R1(config)#ip route 0.0.0.0 0.0.0.0 192.168.122.1 # Guarda la configuración R1#write # Configuración de SNAT R1#conf term R1(config)#access-list 1 permit 90.0.0.0 0.0.0.255 R1(config)#access-list 1 permit 100.0.0.0 0.0.0.255 R1(config)# ip nat pool NAT-Pool 192.168.122.127 192.168.122.127 prefix-length 24 R1(config)#ip nat inside source list 1 pool NAT-Pool overload R1(config)#interface FastEthernet0/0 R1(config-if)#ip nat outside R1(config)#interface FastEthernet1/0 R1(config-if)#ip nat inside R1(config)#interface FastEthernet1/1 R1(config-if)#ip nat inside Configuración del Servidor 1 Configuración de red servidor 1 :\ndebian@servidor1:~$ cat /etc/network/interfaces auto lo iface lo inet loopback auto ens3 iface ens3 inet static address 90.0.0.2 netmask 255.255.255.0 gateway 90.0.0.1 dns-nameservers 8.8.8.8 auto ens4 iface ens4 inet static address 192.168.0.1 netmask 255.255.255.0 Ademas configuraremos el SNAT :\n#Activa el bit de forwarding debian@servidor1:~$ sudo nano /etc/sysctl.conf net.ipv4.ip_forward=1 # Regla SNAT debian@servidor1:~$ sudo iptables -t nat -A POSTROUTING -o ens3 -s 192.168.0.0/24 -j MASQUERADE # Te recomiendo que lo hagas permanente , configura iptables-persistent debian@servidor1:~$ sudo apt install iptables-persistent Configuración del Servidor 2 Configuración de red servidor 2 :\ndebian@servidor2:~$ cat /etc/network/interfaces auto lo iface lo inet loopback auto ens3 iface ens3 inet static address 100.0.0.2 netmask 255.255.255.0 gateway 100.0.0.1 dns-nameservers 8.8.8.8 auto ens4 iface ens4 inet static address 192.168.1.1 netmask 255.255.255.0 Ademas configuraremos el SNAT :\n#Activa el bit de forwarding debian@servidor2:~$ sudo nano /etc/sysctl.conf net.ipv4.ip_forward=1 # Regla SNAT debian@servidor2:~$ sudo iptables -t nat -A POSTROUTING -o ens3 -s 192.168.1.0/24 -j MASQUERADE # Te recomiendo que lo hagas permanente , configura iptables-persistent debian@servidor2:~$ sudo apt install iptables-persistent Comprobación enroutamiento Vamos a comprobar que hemos enroutado bien nuestro escenario , para ello desde los servidores haremos un ping al contrario y ha Internet .\nDesde servidor 1 :\ndebian@servidor1:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=37.4 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 37.374/37.374/37.374/0.000 ms debian@servidor1:~$ debian@servidor1:~$ ping 100.0.0.2 -c 1 PING 100.0.0.2 (100.0.0.2) 56(84) bytes of data. 64 bytes from 100.0.0.2: icmp_seq=1 ttl=63 time=18.6 ms --- 100.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 18.567/18.567/18.567/0.000 ms debian@servidor1:~$ Desde el servidor 2 :\ndebian@servidor2:~$ ping 90.0.0.2 -c 1 PING 90.0.0.2 (90.0.0.2) 56(84) bytes of data. 64 bytes from 90.0.0.2: icmp_seq=1 ttl=63 time=19.1 ms --- 90.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 19.099/19.099/19.099/0.000 ms debian@servidor2:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=112 time=160 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 160.147/160.147/160.147/0.000 ms debian@servidor2:~$ También comprobaremos desde los clientes ya que hay configurado un snat .\nDesde el cliente 1 :\ndebian@cliente1:~$ ping 100.0.0.2 -c 1 PING 100.0.0.2 (100.0.0.2) 56(84) bytes of data. 64 bytes from 100.0.0.2: icmp_seq=1 ttl=62 time=19.0 ms --- 100.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 18.968/18.968/18.968/0.000 ms debian@cliente1:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=61.6 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 61.598/61.598/61.598/0.000 ms Desde el cliente 3 :\ndebian@cliente3:~$ ping 90.0.0.2 -c 1 PING 90.0.0.2 (90.0.0.2) 56(84) bytes of data. 64 bytes from 90.0.0.2: icmp_seq=1 ttl=62 time=15.7 ms --- 90.0.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 15.656/15.656/15.656/0.000 ms debian@cliente3:~$ ping 8.8.8.8 -c 1 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=111 time=45.8 ms --- 8.8.8.8 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 45.760/45.760/45.760/0.000 ms Instalación de OpenVPN Instalaremos en ambos servidores el paquete openvpn\n# Servidor 1 debian@servidor1:~$ sudo apt install -y openvpn # Servidor 2 debian@servidor2:~$ sudo apt install -y openvpn Generación de claves y certificados Podemos generar los certificados manualmente, pero existe una herramienta llamada Easy RSA que automatiza este proceso. Además, Easy RSA facilita la generación de los módulos Diffie-Hellman, que son esenciales para el funcionamiento del servidor OpenVPN.\nNo es necesario que nos la descarguemos ya que esta viene con el paquete openvpn .\nPara OpenVPN necesitamos crear:\nUna clave privada y un certificado x509 para la autoridad certificante que firma (CA) Una clave privada y un certificado x509 firmado para el servidor. Una clave privada y un certificado x509 firmado para cada cliente. Un grupo Diffie-Hellman para el servidor. En el servidor 1, copiaremos el archivo de ejemplo de variables para evitar la solicitud repetitiva de información como organización, país, provincia, etc., por parte de EasyRSA.\ndebian@servidor1:/usr/share/easy-rsa$ sudo cp vars.example vars Editaremos el mismo y cambiaremos los siguientes valores :\ndebian@servidor1:/usr/share/easy-rsa$ sudo nano vars set_var EASYRSA_REQ_COUNTRY \u0026#34;ES\u0026#34; set_var EASYRSA_REQ_PROVINCE \u0026#34;Sevilla\u0026#34; set_var EASYRSA_REQ_CITY \u0026#34;Dos Hermanas\u0026#34; set_var EASYRSA_REQ_ORG \u0026#34;iesgn\u0026#34; set_var EASYRSA_REQ_EMAIL \u0026#34;contacto@javiercd.es\u0026#34; set_var EASYRSA_REQ_OU \u0026#34;Informatica\u0026#34; Una vez cambiado los valores por defecto por los nuestros , vamos a iniciar la infraestructura de clave pública (PKI) utilizando el script EasyRSA. Al ejecutar este comando, se crea un nuevo directorio PKI con la estructura necesaria para gestionar las claves y certificados.\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa init-pki * Notice: init-pki complete; you may now create a CA or requests. Your newly created PKI dir is: * /usr/share/easy-rsa/pki Generación de los parámetros Diffie-Hellman La clave de intercambio de Diffie-Hellman, es un método criptográfico que permite a dos partes acordar de forma segura una clave de sesión compartida sobre un canal no seguro. Así que vamos a generarla haciedo uso del siguiente comando :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-dh * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) Generating DH parameters, 2048 bit long safe prime ......... * Notice: DH parameters of size 2048 created at /usr/share/easy-rsa/pki/dh.pem Se nos habrá generado la clave en /usr/share/easy-rsa/pki/dh.pem , tal y como indica la salida del comando .\nGeneración del certificado de la CA Vamos a proceder a generar el certificado de nuestra CA :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa build-ca nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) Using configuration from /usr/share/easy-rsa/pki/52a64968/temp.25a8f31d You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [Easy-RSA CA]:ca.javiercd.es * Notice: CA creation complete and you may now import and sign cert requests. Your new CA certificate file for publishing is at: /usr/share/easy-rsa/pki/ca.crt Se nos habrá generado en /usr/share/easy-rsa/pki/ca.crt\nGeneración del certificado del servidor 1 Con el siguiente comando generaremos los certificados para el servidor 1 . Se generaran varios archivos :\nservidor1.req : Este archivo contiene la solicitud de certificado generada para el servidor servidor1.key : Este archivo contiene la clave privada debian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-req servidor1 nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) ....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*..+........+...+.+......+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+............+...+....+...+.....+...+...+......+....+.....+......+...+.+..+...+....+..+...............+......+.........+......+.......+.....+......+.+........+.+.....+......+...............+.+.....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ....+............+..+.+...+...........+....+...........+......+...+.+...+..+.+........+....+...+.....+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.........+............+...+.....+....+..+...+.+...............+.....+......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*......+........+..........+...+.................+.+..+....+.....+..........+...+......+.........+.....+.+............+..+..................+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [servidor1]: * Notice: Keypair and certificate request completed. Your files are: req: /usr/share/easy-rsa/pki/reqs/servidor1.req key: /usr/share/easy-rsa/pki/private/servidor1.key Ahora vamos a firmar el certificado del servidor1 con la clave privada de la CA .\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa sign-req server servidor1 * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a server certificate for 825 days: subject= commonName = servidor1 Type the word \u0026#39;yes\u0026#39; to continue, or any other input to abort. Confirm request details: yes Using configuration from /usr/share/easy-rsa/pki/e66a9d70/temp.40a6d9dd Check that the request matches the signature Signature ok The Subject\u0026#39;s Distinguished Name is as follows commonName :ASN.1 12:\u0026#39;servidor1\u0026#39; Certificate is to be certified until Apr 18 16:15:16 2026 GMT (825 days) Write out database with 1 new entries Database updated * Notice: Certificate created at: /usr/share/easy-rsa/pki/issued/servidor1.crt Como puedes ver tendremos los 3 ficheros referentes a nuestro servidor 1 generados :\n# Certificado firmado debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/issued | grep servidor1 -rw------- 1 root root 4637 Jan 14 16:15 servidor1.crt # Clave privada debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/private | grep servidor1 -rw------- 1 root root 1704 Jan 14 16:09 servidor1.key # Solicitud de firma del certificado debian@servidor1:/usr/share/easy-rsa$ sudo ls -la pki/reqs | grep servidor1 -rw------- 1 root root 891 Jan 14 16:09 servidor1.req Generación del certificado del servidor 2 Repetiremos el mismo proceso que hemos realizado para el servidor 1 , pero ahora para nuestro servidor 2 .\nGeneraremos la clave y el certificado :\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa gen-req servidor2 nopass * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) .+.+.................+...+...+.......+..+.+...........+.+..+.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*........+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+....+..+..........+....................+.......+.....+.......+...+..+................+..+.......+.........+...........+....+..+...+.+......+..+...+....+.....+.........+....+......+......+.........+..+...+............+...+.+...+..+....+............+...............+..+...+.............+............+.....+.......+.....+.+......+........+.....................+.+......+..+.+......+.....+.........+......+.........+.......+...+...............+.....+...............+.+....................+......+...+................+...+...+............+.....+...............+.......+......+........+......+....+......+........+.+.....+....+..+.+........+.+.....+.+.....+...........................+......+.+...+.....+......+....+..+....+......+........+.............+..+...+.........+....+..+...+....+...+...+...........+......+...................+.....+................+...+..+....+...+..+......+...+..........+..+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ..........+............+...+....+...+.....+...+......+.+.....+.......+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.........+.+......+..+.+..+...+.........+............+..................+.......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+...+...........+.+...+..+....+..............+......+...............+.+......+..............+....+......+..................+...+............+..+....+.....+.......+...+.........+..+......+...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Common Name (eg: your user, host, or server name) [servidor2]: * Notice: Keypair and certificate request completed. Your files are: req: /usr/share/easy-rsa/pki/reqs/servidor2.req key: /usr/share/easy-rsa/pki/private/servidor2.key Fíjate que ahora a este certificado a la hora de firmarlo diremos que es de tipo cliente . Ya que el servidor 2 \u0026ldquo;actuara como un cliente\u0026rdquo;:\ndebian@servidor1:/usr/share/easy-rsa$ sudo ./easyrsa sign-req client servidor2 * Notice: Using Easy-RSA configuration from: /usr/share/easy-rsa/vars * WARNING: Move your vars file to your PKI folder, where it is safe! * Notice: Using SSL: openssl OpenSSL 3.0.11 19 Sep 2023 (Library: OpenSSL 3.0.11 19 Sep 2023) You are about to sign the following certificate. Please check over the details shown below for accuracy. Note that this request has not been cryptographically verified. Please be sure it came from a trusted source or that you have verified the request checksum with the sender. Request subject, to be signed as a client certificate for 825 days: subject= commonName = servidor2 Type the word \u0026#39;yes\u0026#39; to continue, or any other input to abort. Confirm request details: yes Using configuration from /usr/share/easy-rsa/pki/8e1b2785/temp.504078d9 Check that the request matches the signature Signature ok The Subject\u0026#39;s Distinguished Name is as follows commonName :ASN.1 12:\u0026#39;servidor2\u0026#39; Certificate is to be certified until Apr 18 16:57:49 2026 GMT (825 days) Write out database with 1 new entries Database updated * Notice: Certificate created at: /usr/share/easy-rsa/pki/issued/servidor2.crt Generación de la clave TLS Este paso es opcional , pero es recomendable generar una clave compartida (también conocida como clave de parámetro adicional o clave ta.key) en el contexto de OpenVPN.)\nEn el contexto de OpenVPN, esta clave compartida (ta.key) se utiliza para firmar y verificar todos los paquetes de datos transmitidos a través de la conexión VPN. Su propósito principal es proporcionar una capa adicional de seguridad y autenticación, ayudando a prevenir ataques como el de replay.\ndebian@servidor1:/usr/share/easy-rsa$ sudo openvpn --genkey --secret ta.key Distribuir las claves Ahora tenemos que hacer llegar cada clave a su lugar correspondiente .\nEn el servidor 1 crearemos el directorio /etc/openvpn/keys y guardaremos los siguientes ficheros :\n# Creamos el directorio donde guardaremos las claves debian@servidor1:/usr/share/easy-rsa$ sudo mkdir /etc/openvpn/keys # Nos la copiamos al directorio creado debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/dh.pem /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/ca.crt /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/private/servidor1.key /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/pki/issued/servidor1.crt /etc/openvpn/keys debian@servidor1:~$ sudo cp /usr/share/easy-rsa/ta.key /etc/openvpn/keys # Comprobamos que tenemos todoos los ficheros necesarios debian@servidor1:~$ sudo ls -l /etc/openvpn/keys total 24 -rw------- 1 root root 1216 Jan 14 17:08 ca.crt -rw------- 1 root root 424 Jan 14 17:08 dh.pem -rw------- 1 root root 4637 Jan 14 17:08 servidor1.crt -rw------- 1 root root 1704 Jan 14 17:08 servidor1.key -rw------- 1 root root 636 Jan 14 17:08 ta.key Ahora haremos lo mismo para el servidor2 , pero tendremos que llevarnos las claves haciendo uso de SCP\n# Creamos el directorio donde guardaremos las claves debian@servidor2:~$ sudo mkdir /etc/openvpn/keys # Desde servidor1 pasare a servidor2 las claves debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/ca.crt debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/ta.key debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/private/servidor2.key debian@100.0.0.2:/home/debian debian@servidor1:~$ sudo scp /usr/share/easy-rsa/pki/issued/servidor2.crt debian@100.0.0.2:/home/debian # Las movemos a /etc/openvpn/keys debian@servidor2:~$ sudo mv * /etc/openvpn/keys # Nos aseguramos de tener los 4 ficheros que hemos enviado : debian@servidor2:~$ sudo ls -l /etc/openvpn/keys total 20 -rw------- 1 debian debian 1216 Jan 14 17:12 ca.crt -rw------- 1 debian debian 4515 Jan 14 17:14 servidor2.crt -rw------- 1 debian debian 1704 Jan 14 17:13 servidor2.key -rw------- 1 debian debian 636 Jan 14 17:13 ta.key Configuración de OpenVPN Configuración del servidor 1 [!NOTE] Este apartado lo esta comparando con el post de VPN de acceso remoto.\nComo ves los únicos parámetros que hemos cambiado en la configuración es la IP virtual y el parámetro route para generar la ruta hacia la red privada del otro extremo:\ndebian@servidor1:~$ sudo nano /etc/openvpn/servidor1.conf # Utilizar un dispositivo TUN dinámico dev tun # IP virtual ifconfig 10.99.99.1 10.99.99.2 # Ruta para llegar a la red del otro extremo route 192.168.1.0 255.255.255.0 # Habilitar TLS y asumir el rol de servidor tls-server # Parámetros de Diffie-Hellman dh /etc/openvpn/keys/dh.pem # Certificado de la Autoridad Certificadora ca /etc/openvpn/keys/ca.crt # Certificado del servidor cert /etc/openvpn/keys/servidor1.crt # Clave privada del servidor key /etc/openvpn/keys/servidor1.key # Utilizar compresión LZO rápida comp-lzo # Ping al remoto cada 10 segundos y reiniciar después de 60 segundos keepalive 10 60 # Establecer la verbosidad de salida en un rango de uso normal verb 3 Reinicia el servicio OpenVPN del servidor 1 :\ndebian@servidor1:~$ sudo systemctl restart openvpn Comprueba que se te ha generado la interfaz tun0 :\ndebian@servidor1:~$ ip a show tun0 9: tun0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 10.99.99.1 peer 10.99.99.2/32 scope global tun0 valid_lft forever preferred_lft forever inet6 fe80::a6be:e8ba:17e5:35e3/64 scope link stable-privacy valid_lft forever preferred_lft forever Y por ultimo comprueba que la ruta para llegar a la red del otro extremo es correcta , es decir que va a través de la interfaz tun0 :\ndebian@servidor1:~$ ip r default via 90.0.0.1 dev ens3 onlink 10.99.99.2 dev tun0 proto kernel scope link src 10.99.99.1 90.0.0.0/24 dev ens3 proto kernel scope link src 90.0.0.2 192.168.0.0/24 dev ens4 proto kernel scope link src 192.168.0.1 192.168.1.0/24 via 10.99.99.2 dev tun0 Configuración del servidor 2 debian@servidor2:~$ sudo nano /etc/openvpn/servidor2.conf # Utilizar un dispositivo TUN dinámico dev tun # Conectar al servidor remote 90.0.0.2 # Establecer direcciones IP virtuales punto a punto ifconfig 10.99.99.2 10.99.99.1 # Ruta para llegar a la red remota (local del servidor 1) route 192.168.0.0 255.255.255.0 # Habilitar TLS y asumir el rol de cliente durante el handshake de TLS tls-client # Certificado de la Autoridad Certificadora ca /etc/openvpn/keys/ca.crt # Certificado del cliente cert /etc/openvpn/keys/servidor2.crt # Clave privada del cliente key /etc/openvpn/keys/servidor2.key # Utilizar compresión LZO rápida comp-lzo # Hacer ping al remoto cada 10 segundos y reiniciar después de 60 segundos si no hay señal de vida del \u0026gt; keepalive 10 60 # Establecer la verbosidad de salida en un rango de uso normal verb 3 # Registrar mensajes en el archivo openvpn.log log /var/log/openvpn.log Reinicia el servicio OpenVPN en el servidor 2 para que se aplique la nueva configuración :\ndebian@servidor2:~$ sudo systemctl restart openvpn Comprueba que se te ha generado la interfaz tun0 :\ndebian@servidor2:~$ ip a show tun0 10: tun0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 10.99.99.2 peer 10.99.99.1/32 scope global tun0 valid_lft forever preferred_lft forever inet6 fe80::ded7:8620:c295:146a/64 scope link stable-privacy valid_lft forever preferred_lft forever Y por ultimo comprueba que la ruta para llegar a la red del otro extremo es correcta , es decir que va a través de la interfaz tun0 :\ndebian@servidor2:~$ ip r default via 100.0.0.1 dev ens3 onlink 10.99.99.1 dev tun0 proto kernel scope link src 10.99.99.2 100.0.0.0/24 dev ens3 proto kernel scope link src 100.0.0.2 192.168.0.0/24 via 10.99.99.1 dev tun0 192.168.1.0/24 dev ens4 proto kernel scope link src 192.168.1.1 Comprobación de funcionamiento Ahora, ambas redes privadas, tanto la 192.168.0.0/24 como la 192.168.1.0/24, contarán con conectividad gracias a los servidores VPN .\nPing desde cliente 1 hacia cliente 2 :\ndebian@cliente1:~$ ping 192.168.1.2 -c 1 PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data. 64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=15.6 ms --- 192.168.1.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 15.645/15.645/15.645/0.000 ms Ping desde cliente 2 hacia cliente 1 :\ndebian@cliente3:~$ ping 192.168.0.2 -c 1 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=62 time=17.3 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 17.345/17.345/17.345/0.000 ms Ping desde servidor 1 hacia servidor 2 :\ndebian@servidor1:~$ ping 192.168.1.1 -c 1 PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data. 64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=18.0 ms --- 192.168.1.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 17.988/17.988/17.988/0.000 ms Ping desde servidor 1 hacia servidor 2 :\ndebian@servidor2:~$ ping 192.168.0.1 -c 1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=12.6 ms --- 192.168.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 12.558/12.558/12.558/0.000 ms Por supuesto también podremos acceder a cualquier servicio en la otra red o conectarnos por SSH desde un extremo del túnel a otro :\ndebian@cliente3:~$ ssh 192.168.0.1 debian@192.168.0.1\u0026#39;s password: Linux servidor1 6.1.0-15-cloud-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.66-1 (2023-12-09) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Tue Jan 16 18:51:53 2024 from 192.168.1.2 debian@servidor1:~$ ip -4 a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: ens3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s3 inet 90.0.0.2/24 brd 90.0.0.255 scope global ens3 valid_lft forever preferred_lft forever 3: ens4: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 altname enp0s4 inet 192.168.0.1/24 brd 192.168.0.255 scope global ens4 valid_lft forever preferred_lft forever 9: tun0: \u0026lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500 inet 10.99.99.1 peer 10.99.99.2/32 scope global tun0 valid_lft forever preferred_lft forever Cliente Android [!TIP] En los post de redes encontraras una guia para instalar una maquina virtual de android en KVM y GNS3\nLa configuración de red del mismo se realiza desde el wifi :\nComprueba que desde la red local del mismo tienes conectividad con la ip asignada :\ndebian@cliente3:~$ ping 192.168.1.4 PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data. 64 bytes from 192.168.1.4: icmp_seq=1 ttl=64 time=0.534 ms ^C --- 192.168.1.4 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.534/0.534/0.534/0.000 ms Ademas este cuenta en las aplicaciones con un emulador de terminal que nos servirá para comprobar que tiene conectividad :\n","date":"March 28, 2024","hero":"/images/vpn/sitetosite.png","permalink":"https://www.javiercd.es/posts/vpn/site_to_site_openvpn/site_to_site_openvpn/","summary":"Montando el escenario Para realizar este ejercicio he montado el siguiente escenario en GNS3 :\nConfiguración del router cisco Vamos a darle a cada interfaz la configuración de red correspondiente :\n# Interfaz que nos dará internet R1#configure terminal R1(config)#interface fastEthernet 0/0 R1(config-if)#ip add dhcp R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 1 R1(config)#interface fastEthernet 1/0 R1(config-if)#ip add 90.0.0.1 255.255.255.0 R1(config-if)#no shut R1(config-if)#exit # Interfaz red Servidor 2 R1(config)#interface fastEthernet 1/1 R1(config-if)#ip add 100.","tags":["VPN","CISCO","LINUX","DEBIAN","OPENVPN"],"title":"VPN site to site con OpenVPN y certificados x509"},{"categories":null,"contents":" [!NOTE]\nVoy a partir del post de VPN acceso remoto con Wireguard , asi que es posible que haga referencia a este durante este articulo .\nGeneración de claves Lo primero que haremos sera instalarnos tanto en ambas maquinas el paquete Wireguard :\nroot@servidor1:~# sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard debian@servidor2:~$ sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard Vamos a generar los pares de claves que se utilizarán para cifrar la conexión. Necesitaremos una clave para el servidor y un par de claves adicionales por cada cliente.\nComenzaremos con el par de claves del servidor1:\ndebian@servidor1:~$ wg genkey | sudo tee /etc/wireguard/server_private.key | wg pubkey | sudo tee /etc/wireguard/server_public.key 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= # Puedes visualizar la clave privada posteriormente : debian@servidor1:~$ sudo cat /etc/wireguard/server_private.key 2Gg3EnKD+rdyMPEjMikZTwq2w0m78KrEcUsAJ/8icFA= # Puedes visualizar la clave publica posteriormente : debian@servidor1:~$ sudo cat /etc/wireguard/server_public.key 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= Nos desplazamos al servidor2 y les generamos las suyas :\n# Generamos el par de claves para el cliente de acceso remoto servidor2 debian@servidor2:~$ wg genkey | sudo tee /etc/wireguard/client_private.key | wg pubkey | sudo tee /etc/wireguard/client_public.key gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= # Puedes visualizar la clave privada posteriormente : debian@servidor2:~$ sudo cat /etc/wireguard/client_private.key 8IdsSwunfU5zJQzS5nZg4D//cFEbRa+27HGOQE1V90k= # Puedes visualizar la clave publica posteriormente : debian@servidor2:~$ sudo cat /etc/wireguard/client_public.key gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= Configuración de Wireguard Vamos a modificar el archivo de configuración en la máquina servidor1. La única modificación necesaria será en el parámetro \u0026ldquo;AllowedIPs\u0026rdquo;, donde debemos agregar la dirección de red a la que nos conectaremos. Además, incluiremos en el campo \u0026ldquo;Peer Endpoint\u0026rdquo; la dirección IP de la otra máquina, ya que ambas actuarán como servidores en esta configuración.\ndebian@servidor1:~$ sudo cat /etc/wireguard/wg0.conf [Interface] Address = 10.99.99.1 PrivateKey = 2Gg3EnKD+rdyMPEjMikZTwq2w0m78KrEcUsAJ/8icFA= ListenPort = 51820 [Peer] Publickey = gS2ED2zfzMHBttMpFhH3MvRpr8D4ALEDTumNcib8A2g= AllowedIPs = 10.99.99.2/32,192.168.1.0/24 PersistentKeepAlive = 25 Endpoint = 100.0.0.2:51820 Lo mismo para la maquina servidor2 , la configuración quedaría así:\ndebian@servidor2:~$ sudo cat /etc/wireguard/wg0.conf [Interface] Address = 10.99.99.2/24 PrivateKey = 8IdsSwunfU5zJQzS5nZg4D//cFEbRa+27HGOQE1V90k= ListenPort = 51820 [Peer] PublicKey = 2/RjGUbiQuaFR7atYaQ8lcczz2wXxO9aIwfzZEMPXCQ= AllowedIPs = 10.99.99.1/32,192.168.0.0/24 Endpoint = 90.0.0.2:51820 PersistentKeepalive = 25 Como yo tengo levantado los túneles del ejercicio anterior los bajaremos y los subiremos para que se aplique la nueva configuración :\ndebian@servidor1:~$ sudo wg-quick down wg0 debian@servidor2:~$ sudo wg-quick down wg0 debian@servidor1:~$ sudo wg-quick up wg0 debian@servidor1:~$ sudo wg-quick up wg0 Comprobaremos que en ambos servidores se ha creado la interfaz wg0 , que es la que nos corresponde por el nombre del fichero de configuración :\ndebian@servidor1:~$ sudo ip link show wg0 11: wg0: \u0026lt;POINTOPOINT,NOARP,UP,LOWER_UP\u0026gt; mtu 1420 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/none debian@servidor2:~$ sudo ip link show wg0 11: wg0: \u0026lt;POINTOPOINT,NOARP,UP,LOWER_UP\u0026gt; mtu 1420 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/none A continuación voy a mostrarte las tablas de enroutamiento de los 2 servidores para que veas que se han creado rutas para llegar a ambas redes privadas por la interfaz wg0:\ndebian@servidor1:~$ ip r default via 90.0.0.1 dev ens3 onlink 10.99.99.2 dev wg0 scope link 90.0.0.0/24 dev ens3 proto kernel scope link src 90.0.0.2 192.168.0.0/24 dev ens4 proto kernel scope link src 192.168.0.1 192.168.1.0/24 dev wg0 scope link debian@servidor2:~$ ip r default via 100.0.0.1 dev ens3 onlink 10.99.99.0/24 dev wg0 proto kernel scope link src 10.99.99.2 100.0.0.0/24 dev ens3 proto kernel scope link src 100.0.0.2 192.168.0.0/24 dev wg0 scope link 192.168.1.0/24 dev ens4 proto kernel scope link src 192.168.1.1 Comprobación de funcionamiento Ahora, ambas redes privadas están completamente conectadas, lo que nos permite acceder desde cualquiera de las dos a la otra. Vamos a llevar a cabo algunas pruebas desde los clientes para asegurarnos de que la conexión esté funcionando correctamente.\nVoy a hacer un ping desde la red 192.168.0.0 a la 192.168.1.0 con cliente1 :\n# cliente1 --\u0026gt; servidor2 debian@cliente1:~$ ping 192.168.1.1 -c 1 PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data. 64 bytes from 192.168.1.1: icmp_seq=1 ttl=63 time=17.6 ms --- 192.168.1.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 17.554/17.554/17.554/0.000 ms # Cliente1 --\u0026gt; Cliente 3 debian@cliente1:~$ ping 192.168.1.2 -c 1 PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data. 64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=12.9 ms debian@cliente1:~$ ping 192.168.1.1 -c 1 PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data. 64 bytes from 192.168.1.1: icmp_seq=1 ttl=63 time=17.8 ms --- 192.168.1.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 17.803/17.803/17.803/0.000 ms # Cliente1 --\u0026gt; Windows debian@cliente1:~$ ping 192.168.1.5 -c 1 PING 192.168.1.5 (192.168.1.5) 56(84) bytes of data. 64 bytes from 192.168.1.5: icmp_seq=1 ttl=126 time=19.9 ms --- 192.168.1.5 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 19.906/19.906/19.906/0.000 ms # Cliente1 --\u0026gt; Android debian@cliente1:~$ ping 192.168.1.4 -c 1 PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data. 64 bytes from 192.168.1.4: icmp_seq=1 ttl=62 time=20.8 ms --- 192.168.1.4 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 20.834/20.834/20.834/0.000 ms Como ves tengo conectividad desde cualquier cliente de la red 192.168.0.0 con la 192.168.1.0 .\nVamos a comprobarlo en la dirección contraria , es decir desde la red 192.168.1.0 hacia la 192.168.0.0 :\n# Cliente3 --\u0026gt; Servidor1 debian@cliente3:~$ ping 192.168.0.1 -c 1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 64 bytes from 192.168.0.1: icmp_seq=1 ttl=63 time=16.6 ms --- 192.168.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 16.581/16.581/16.581/0.000 ms # Cliente3 --\u0026gt; Cliente1 debian@cliente3:~$ ping 192.168.0.2 -c 1 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=62 time=21.0 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 21.031/21.031/21.031/0.000 ms # Cliente3 --\u0026gt; Cliente2 debian@cliente3:~$ ping 192.168.0.3 -c 1 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=62 time=16.1 ms --- 192.168.0.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 16.115/16.115/16.115/0.000 ms Para cerciorarnos de que el trafico esta pasando por el túnel en los 2 extremos vamos a hacer un traceroute desde las 2 redes :\nDesde la red 192.168.0.0 a la 192.168.1.0 :\ndebian@cliente1:~$ traceroute 192.168.1.2 traceroute to 192.168.1.2 (192.168.1.2), 30 hops max, 60 byte packets 1 192.168.0.1 (192.168.0.1) 0.629 ms 0.601 ms 0.595 ms 2 10.99.99.2 (10.99.99.2) 13.677 ms 13.667 ms 13.657 ms 3 192.168.1.2 (192.168.1.2) 13.649 ms 13.636 ms 13.626 ms Desde la red 192.168.1.0 a la 192.168.0.0 :\ndebian@cliente3:~$ traceroute 192.168.0.3 traceroute to 192.168.0.3 (192.168.0.3), 30 hops max, 60 byte packets 1 192.168.1.1 (192.168.1.1) 0.430 ms 0.399 ms 0.393 ms 2 10.99.99.1 (10.99.99.1) 19.343 ms 19.337 ms 19.329 ms 3 192.168.0.3 (192.168.0.3) 19.324 ms 19.320 ms 19.313 ms ","date":"March 28, 2024","hero":"/images/vpn/wireguard.png","permalink":"https://www.javiercd.es/posts/vpn/site_to_site_wireguard/site_to_site_wireguard/","summary":"[!NOTE]\nVoy a partir del post de VPN acceso remoto con Wireguard , asi que es posible que haga referencia a este durante este articulo .\nGeneración de claves Lo primero que haremos sera instalarnos tanto en ambas maquinas el paquete Wireguard :\nroot@servidor1:~# sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard debian@servidor2:~$ sudo apt update \u0026amp;\u0026amp; sudo apt install wireguard Vamos a generar los pares de claves que se utilizarán para cifrar la conexión.","tags":["VPN","CISCO","LINUX","DEBIAN","WIREGUARD"],"title":"VPN site to site Wireguard"},{"categories":null,"contents":" En este post voy a montar una VPN IPSEC usando routers cisco .\n[!NOTE]\nEn este post se detalla la configuración de los routers R2 y R3 , sin embargo R1 esta explicado en el post de \u0026ldquo;VPN acceso remoto OpenVPN\u0026rdquo; . Si quieres ver la configuración de este ultimo mírate el apartado preparando el escenario .\nConfiguración del escenario Como he cambiado de escenario , hay que configurar los 2 nuevos routers en la red R2 y R3 .\nComenzare por R2 :\nR2(config)#interface FastEthernet0/0 R2(config-if)# ip address 192.168.0.1 255.255.255.0 R2(config-if)#no shut R2(config)#interface FastEthernet1/0 R2(config-if)# ip address 90.0.0.2 255.255.255.0 R2(config-if)# no shutdown R2(config)#ip route 0.0.0.0 0.0.0.0 90.0.0.1 #SNAT R2(config)#$ ip nat pool NAT-Pool 90.0.0.2 90.0.0.2 prefix-length 24 R2(config)#ip nat inside source list 1 pool NAT-Pool overload R2(config)#interface FastEthernet0/0 R2(config-if)#ip nat inside R2(config-if)#interface FastEthernet1/0 R2(config-if)#ip nat outside Lo mismo pero con R3 :\nR3(config)#Interface FastEthernet0/0 R3(config-if)#ip address 192.168.1.1 255.255.255.0 R3(config-if)#no shut R3(config-if)#exit R3(config)#Interface FastEthernet1/0 R3(config-if)#ip address 100.0.0.2 255.255.255.0 R3(config-if)#no shut R3(config-if)#exit R3(config)#ip route 0.0.0.0 0.0.0.0 100.0.0.1 R3(config)#ip nat pool NAT-Pool 100.0.0.2 100.0.0.2 prefix-length 24 R3(config)#ip nat inside source list 1 pool NAT-Pool overload R3(config)#interface FastEthernet0/0 R3(config-if)#ip nat inside R3(config-if)#interface FastEthernet1/0 R3(config-if)#ip nat outside Configuración VPN IPSEC Cisco Una vez tenemos configurado el escenario como en los ejercicios anteriores pero ahora todos los routers del escenario son cisco vamos a proceder con la configuración de la VPN IPSEC . Lo ideal es que compruebes que el escenario esta bien enrutado , para no hacer mas largo este documento voy a omitirlo .\nRouter 2 A continuación te describo paso a paso la configuración que hay que realizar en R2 , haciendo uso de comentarios te indicare que estamos haciendo en cada momento :\n# Entramos en el modo de configuración R2#conf term # Creamos una política ISAKMP , en mi caso con un número de secuencia de 10. R2(config)#crypto isakmp policy 10 # Establecemos el algoritmo de cifrado AES para la política ISAKMP. R2(config-isakmp)# encryption aes # Configuramos el algoritmo de hash SHA para la política ISAKMP. R2(config-isakmp)# hash sha # Configuramos la autenticación precompartida (pre-shared key) para la política ISAKMP. R2(config-isakmp)# authentication pre-share # Establecemos el grupo de difie-hellman con 2048 bits para la política ISAKMP. R2(config-isakmp)# group 14 # Configuramos la clave precompartida para autenticación con el par remoto 100.0.0.2. R2(config-isakmp)#crypto isakmp key TuClavePrecompartida address 100.0.0.2 # Creamos un conjunto de transformación para la fase 2 (IPsec) con cifrado AES y hash SHA. R2(config)#crypto ipsec transform-set myset esp-aes esp-sha-hmac # Creamos una lista de acceso (ACL) para especificar el tráfico a proteger con IPsec. R2(cfg-crypto-trans)# access-list 100 permit ip 192.168.1.0 0.0.0.255 192.168.0.0 0.0.0.255 # Creamos un mapa criptográfico asociado a ISAKMP e IPsec con número de secuencia 10. R2(config)#crypto map mymap 10 ipsec-isakmp # Especificamos la dirección IP del peer remoto. R2(config-crypto-map)# set peer 100.0.0.2 # Asociamos el conjunto de transformación al mapa criptográfico. R2(config-crypto-map)# set transform-set myset # Asociamos la lista de acceso al mapa criptográfico para identificar el tráfico a proteger. R2(config-crypto-map)# match address 100 # Entramos a la interfaz FastEthernet1/0 (PUBLICA) y le asignamos el mapa criptografico para que envie por esta el trafico de la VPN . R2(config-crypto-map)#interface FastEthernet1/0 R2(config-if)# crypto map mymap Router 3 A continuación te describo paso a paso la configuración que hay que realizar en R3 , haciendo uso de comentarios te indicare que estamos haciendo en cada momento :\n# Entramos en el modo de configuración R3#conf term # Creamos una política ISAKMP , en mi caso con un número de secuencia de 10. R3(config)#crypto isakmp policy 10 # Establecemos el algoritmo de cifrado AES para la política ISAKMP. R3(config-isakmp)# encryption aes # Configuramos el algoritmo de hash SHA para la política ISAKMP. R3(config-isakmp)# hash sha # Configuramos la autenticación precompartida (pre-shared key) para la política ISAKMP. R3(config-isakmp)# authentication pre-share # Establecemos el grupo de difie-hellman con 2048 bits para la política ISAKMP. R3(config-isakmp)# group 14 # Configuramos la clave precompartida para autenticación con el par remoto 100.0.0.2. R3(config-isakmp)#crypto isakmp key TuClavePrecompartida address 90.0.0.2 # Creamos un conjunto de transformación para la fase 2 (IPsec) con cifrado AES y hash SHA. R3(config)#crypto ipsec transform-set myset esp-aes esp-sha-hmac # Creamos una lista de acceso (ACL) para especificar el tráfico a proteger con IPsec. R3(cfg-crypto-trans)#access-list 100 permit ip 192.168.1.0 0.0.0.255 192.168.0.0 0.0.0.255 # Creamos un mapa criptográfico asociado a ISAKMP e IPsec con número de secuencia 10. R3(config)#crypto map mymap 10 ipsec-isakmp # Especificamos la dirección IP del peer remoto. R3(config-crypto-map)# set peer 90.0.0.2 # Asociamos el conjunto de transformación al mapa criptográfico. R3(config-crypto-map)# set transform-set myset # Asociamos la lista de acceso al mapa criptográfico para identificar el tráfico a proteger. R3(config-crypto-map)# match address 100 # Entramos a la interfaz FastEthernet1/0 (PUBLICA) y le asignamos el mapa criptografico para que envie por esta el trafico de la VPN . R3(config-crypto-map)#interface FastEthernet1/0 R3(config-if)# crypto map mymap Comprobaciones Una vez aplicada la configuración vamos a ver que en ambos extremos la configuración sea correcta , viendo que los túneles estén levantados :\nR3#show crypto session Crypto session current status Interface: FastEthernet1/0 Session status: UP-ACTIVE Peer: 90.0.0.2 port 500 IKE SA: local 100.0.0.2/500 remote 90.0.0.2/500 Active IPSEC FLOW: permit ip 192.168.1.0/255.255.255.0 192.168.0.0/255.255.255.0 Active SAs: 2, origin: crypto map R2#show crypto session Crypto session current status Interface: FastEthernet1/0 Session status: UP-ACTIVE Peer: 100.0.0.2 port 500 IKE SA: local 90.0.0.2/500 remote 100.0.0.2/500 Active IPSEC FLOW: permit ip 192.168.0.0/255.255.255.0 192.168.1.0/255.255.255.0 Active SAs: 2, origin: crypto map Ya viendo esto podemos cerciorarnos de que la VPN esta levantada pero existen mas comandos que nos brindan diferente información :\n**show crypto isakmp sa : ** Para comprobar las asociaciones ISAKMP **show crypto ipsec sa : ** **Para comprobar las asociaciones IPsec Prueba de conectividad Vamos a comprobar que los distintos clientes de la red 192.168.0.0 pueden comunicarse con los otros de la red 192.168.1.0 :\n# Cliente 1 --\u0026gt; R3 debian@cliente1:~$ ping -c 1 192.168.1.1 PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data. 64 bytes from 192.168.1.1: icmp_seq=1 ttl=254 time=89.2 ms --- 192.168.1.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 89.167/89.167/89.167/0.000 ms # Cliente1 --\u0026gt; Cliente 3 debian@cliente1:~$ ping -c 1 192.168.1.2 PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data. 64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=46.4 ms --- 192.168.1.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 46.412/46.412/46.412/0.000 ms Vamos a comprobar que los distintos clientes de la red 192.168.1.0 pueden comunicarse con los otros de la red 192.168.0.0 :\n# Cliente 3 --\u0026gt; R2 debian@cliente3:~$ ping -c 1 192.168.0.1 PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. 64 bytes from 192.168.0.1: icmp_seq=1 ttl=254 time=54.4 ms --- 192.168.0.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 54.440/54.440/54.440/0.000 ms # Cliente 3 --\u0026gt; Cliente 1 debian@cliente3:~$ ping -c 1 192.168.0.2 PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data. 64 bytes from 192.168.0.2: icmp_seq=1 ttl=62 time=33.5 ms --- 192.168.0.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 33.498/33.498/33.498/0.000 ms ","date":"March 28, 2024","hero":"/images/vpn/ipsec_cisco.png","permalink":"https://www.javiercd.es/posts/vpn/ipsec_cisco/ipsec_cisco/","summary":"En este post voy a montar una VPN IPSEC usando routers cisco .\n[!NOTE]\nEn este post se detalla la configuración de los routers R2 y R3 , sin embargo R1 esta explicado en el post de \u0026ldquo;VPN acceso remoto OpenVPN\u0026rdquo; . Si quieres ver la configuración de este ultimo mírate el apartado preparando el escenario .\nConfiguración del escenario Como he cambiado de escenario , hay que configurar los 2 nuevos routers en la red R2 y R3 .","tags":["VPN","LINUX","CISCO"],"title":"VPN sitio a sitio con IPsec Cisco"},{"categories":null,"contents":" En este post voy a montar una VPN IPSEC usando cortafuegos Fortinet , para ello los visualizaré en GNS3 .\nPreparación del escenario Para crear la VPN añadiré al escenario un nuevo Fortigate .\nAsí que vamos a proceder a configurarlo , lo primero sera conocer la IP que le ha dado el DHCP :\nFortiGate-VM64-KVM login: admin Password: You are forced to change your password. Please input a new password. New Password: Confirm Password: Welcome! FortiGate-VM64-KVM # get system interface physical port1 == [onboard] ==[port1] mode: dhcp ip: 192.168.122.22 255.255.255.0 ipv6: ::/0 status: up speed: 1000Mbps (Duplex: full) FEC: none FEC_cap: none Esta IP que me ha dado por DHCP se la configurare como estática .\nEn cuanto a la red local del nuevo FortiNet , va a tener la red 192.168.30.0 :\nPor ultimo configurare en este la ruta por defecto hacia la dirección IP de de la nube NAT la 192.168.122.1/24 :\nUna vez hecho esto vamos a ver que tenemos conectividad entre ambos cortafuegos , desde FGT \u0026ndash;\u0026gt; FTG2 :\nY al revés desde FTG2 \u0026ndash;\u0026gt; FTG :\nVPN site to site Nos dirigimos primero al FortiGate FTG que es el que contiene los clientes de Odin,Loki,Thor y Hela . Y iremos a IPsec Wizard , le pondré un nombre significativo con el nombre de los hosts :\nEn el siguiente paso vamos a indicar la IP del FortiGate FTG2 , la interfaz por donde saldrá el trafico y por ultimo una \u0026ldquo;llave\u0026rdquo; compartida entre los dos extremos , esta ultima parte puede sustituirse por certificados :\nA continuación indicaremos las redes locales de ambos extremos donde queremos tener conectividad :\nNos saldrá un panel con los distintos objetos que se van a crear y le daremos a crear :\nRepetiremos el mismo proceso en el otro Fortigate , crearemos un túnel site to site :\nLe diremos la IP publica del otro extremo y pondremos la misma clave compartida :\nAhora le diremos cual es nuestra red local y la red remota :\nPor ultimo nos dirá los objetos que se van a crear y le damos a crear :\nAhora si accedemos a los paneles de IPsec Tunnels veremos que en unos segundos ambos túneles se levantaran :\nComprobación de funcionamiento Una vez llegado a este punto veremos que la VPN esta funcionando . Podemos hacer un ping en ambas direcciones :\ndebian@cliente1:~$ ping 192.168.100.4 -c 1 PING 192.168.100.4 (192.168.100.4) 56(84) bytes of data. 64 bytes from 192.168.100.4: icmp_seq=1 ttl=62 time=1.22 ms --- 192.168.100.4 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.220/1.220/1.220/0.000 ms debian@thor:~$ ping 192.168.30.2 -c 1 PING 192.168.30.2 (192.168.30.2) 56(84) bytes of data. 64 bytes from 192.168.30.2: icmp_seq=1 ttl=62 time=1.52 ms --- 192.168.30.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.516/1.516/1.516/0.000 ms Como vemos tenemos conectividad entre las 2 redes privadas a través de la VPN .\nSi nos paramos a ver los objetos que nos ha creado cada túnel , este nos ha creado un total de 4 , los cuales tendremos que borrar si deseamos eliminar el túnel :\nPor defecto la política que nos ha creado permite TODO el trafico en ambas direcciones , estas 2 políticas la tenemos creada en cada cortafuegos y modificando estas o añadiendo nuevas podemos limitar el trafico que pasa por la VPN en función de nuestras necesidades .\nAdemas nos habrá creado una ruta para encaminar el trafico hacia la red privada del otro extremo :\n","date":"March 28, 2024","hero":"/images/cortafuegos/fortinet.png","permalink":"https://www.javiercd.es/posts/vpn/site_to_site_fortinet/site_to_site_fortinet/","summary":"En este post voy a montar una VPN IPSEC usando cortafuegos Fortinet , para ello los visualizaré en GNS3 .\nPreparación del escenario Para crear la VPN añadiré al escenario un nuevo Fortigate .\nAsí que vamos a proceder a configurarlo , lo primero sera conocer la IP que le ha dado el DHCP :\nFortiGate-VM64-KVM login: admin Password: You are forced to change your password. Please input a new password.","tags":["VPN","LINUX","FORTINET"],"title":"VPN sitio a sitio con IPsec Fortinet"},{"categories":null,"contents":" Instalación pila LAMP en Debian 12 Si estás utilizando Debian 12, sigue los pasos a continuación para instalar un servidor web LAMP completo en Debian GNU/Linux 12 \u0026ldquo;Bookworm\u0026rdquo; (Stable). Ten en cuenta que Debian 12 incluye PHP 8.2 en sus repositorios, lo que puede ser diferente de versiones anteriores de Debian.\nInstalación del servidor web Lo primero en un servidor LAMP es la \u0026ldquo;A\u0026rdquo; de Apache. Para instalar Apache, ejecuta los siguientes comandos:\njaviercruces@IWEB:~$ sudo apt install apache2 javiercruces@IWEB:~$ sudo systemctl enable apache2 \u0026amp;\u0026amp; sudo systemctl start apache2 Con estos comandos, habrás instalado y activado el servidor web Apache. Puedes verificarlo escribiendo la IP del servidor en tu navegador favorito y debería mostrarte la página de inicio de Apache por defecto.\nInstalación de PHP Por lo general, necesitarás instalar algunos paquetes específicos para PHP, llamados módulos en función de la base de datos que utilices. Puedes instalarlos con el siguiente comando:\njaviercruces@IWEB:~$ sudo apt install php8.2 libapache2-mod-php8.2 php8.2-mysql Si instalas CMS como WordPress, Moodle o Prestashop en tu servidor, es posible que te pidan paquetes adicionales para su correcto funcionamiento. Estas aplicaciones suelen indicar claramente qué paquetes necesitas instalar.\nPara que Apache aplique los cambios y active PHP, reinicia el servicio con el siguiente comando:\njaviercruces@IWEB:~$ sudo systemctl restart apache2 Instalación y configuración de MariaDB Puedes usar indistintamente MariaDB o Mysql , en mi caso usare MariaDB :\njaviercruces@IWEB:~$ sudo apt install mariadb-server javiercruces@IWEB:~$ sudo systemctl enable mysql \u0026amp;\u0026amp; sudo systemctl start mysql Durante la instalación, se te pedirá establecer una contraseña para el usuario root de MySQL. Una vez que haya finalizado la instalación, ejecuta el siguiente comando para asegurar tu instalación de MariaDB:\njaviercruces@IWEB:~$ sudo mysql_secure_installation Sigue las instrucciones para asegurar tu instalación de MariaDB, como configurar la contraseña del usuario root y eliminar usuarios anónimos y bases de datos de prueba.\nDespués de completar estos pasos, habrás configurado MariaDB y podrás conectarte a través de la terminal:\njaviercruces@IWEB:~$ sudo mysql -u root -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 32 Server version: 10.11.4-MariaDB-1~deb12u1 Debian 12 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. MariaDB [(none)]\u0026gt; Con esto ya tendrías instalada la pila LAMP en debian 12\n","date":"October 28, 2023","hero":"/images/iweb/lamp/portada_lamp.png","permalink":"https://www.javiercd.es/posts/iaw/lamp/lamp/","summary":"Instalación pila LAMP en Debian 12 Si estás utilizando Debian 12, sigue los pasos a continuación para instalar un servidor web LAMP completo en Debian GNU/Linux 12 \u0026ldquo;Bookworm\u0026rdquo; (Stable). Ten en cuenta que Debian 12 incluye PHP 8.2 en sus repositorios, lo que puede ser diferente de versiones anteriores de Debian.\nInstalación del servidor web Lo primero en un servidor LAMP es la \u0026ldquo;A\u0026rdquo; de Apache. Para instalar Apache, ejecuta los siguientes comandos:","tags":["WordPress","CMS","IWEB","AW","debian","LAMP"],"title":"Instalación pila LAMP en debian 12"},{"categories":null,"contents":" Instalación pila LEMP en debian 12 con PHP-8 En esta guía, te explicare los pasos necesarios para instalar una pila LEMP (Linux, Nginx, MariaDB y PHP) en un servidor con Debian 12. La configuración incluirá PHP 8.2 como versión principal. La pila LEMP es esencial para alojar sitios web y aplicaciones web basadas en PHP, como WordPress u otras aplicaciones dinámicas. Sigue los pasos detallados a continuación para configurar tu servidor LEMP con PHP 8.2.\nRequisitos previos Antes de comenzar, asegúrate de que cumples con los siguientes requisitos:\nUn servidor Linux. Un usuario no root con privilegios sudo. Un nombre de dominio completo que apunte al servidor. Primero, actualiza y actualiza los paquetes del sistema:\njaviercruces@IWEB:~$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade Además, asegúrate de que los siguientes paquetes estén instalados en tu sistema , ya que los utilizaremos mas adelante :\njaviercruces@IWEB:~$ sudo apt install wget nano unzip tar -y Instalación PHP Debian 12 incluye PHP 8.2 por defecto. Puedes instalarlo ejecutando el siguiente comando:\njaviercruces@IWEB:~$ sudo apt install php-fpm php-cli php-mysql php-mbstring php-xml php-gd Hemos instalado las extensiones MySQL, CLI, GD, Mbstring y XML de PHP. Puedes instalar cualquier extensión adicional según tus necesidades. Para verificar la instalación de PHP, puedes ejecutar:\njaviercruces@IWEB:~$ php --version PHP 8.2.7 (cli) (built: Jun 9 2023 19:37:27) (NTS) Copyright (c) The PHP Group Zend Engine v4.2.7, Copyright (c) Zend Technologies with Zend OPcache v8.2.7, Copyright (c), by Zend Technologies javiercruces@IWEB:~$ Instalación MariaDB Puedes usar indistintamente MariaDB o Mysql , en mi caso usare MariaDB :\njaviercruces@IWEB:~$ sudo apt install mariadb-server javiercruces@IWEB:~$ sudo systemctl enable mysql \u0026amp;\u0026amp; sudo systemctl start mysql Durante la instalación, se te pedirá establecer una contraseña para el usuario root de MySQL. Una vez que haya finalizado la instalación, ejecuta el siguiente comando para asegurar tu instalación de MariaDB:\njaviercruces@IWEB:~$ sudo mysql_secure_installation Sigue las instrucciones para asegurar tu instalación de MariaDB, como configurar la contraseña del usuario root y eliminar usuarios anónimos y bases de datos de prueba.\nDespués de completar estos pasos, habrás configurado MariaDB y podrás conectarte a través de la terminal .\nSi te has saltado lanzar el script de la instalación segura , el usuario root de la base de datos no tiene contraseña asi que pulsa espacio para iniciar sesión una vez lanzado el comando .\njaviercruces@IWEB:~$ sudo mysql -u root -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 32 Server version: 10.11.4-MariaDB-1~deb12u1 Debian 12 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. MariaDB [(none)]\u0026gt; Instalar Nginx Primero, asegurémonos de que Nginx esté instalado en tu servidor:\njaviercruces@IWEB:~$ sudo apt install nginx Una vez que Nginx esté instalado, procederemos a configurar un socket TCP para trabajar con PHP-FPM.\nAbre el archivo de configuración de PHP-FPM para realizar la configuración necesaria:\njaviercruces@IWEB:~$ sudo nano /etc/php/8.2/fpm/pool.d/www.conf Dentro del archivo, busca la sección que define la dirección en la que PHP-FPM acepta solicitudes FastCGI.\nComenta la línea que comienza con listen y reemplázala por la siguiente línea para configurar un socket TCP en la dirección 127.0.0.1 y el puerto 9000:\n; The address on which to accept FastCGI requests. ; Valid syntaxes are: ; \u0026#39;ip.add.re.ss:port\u0026#39; - to listen on a TCP socket to a specific IPv4 address on ; a specific port; ; \u0026#39;[ip:6:addr:ess]:port\u0026#39; - to listen on a TCP socket to a specific IPv6 address on ; a specific port; ; \u0026#39;port\u0026#39; - to listen on a TCP socket to all addresses ; (IPv6 and IPv4-mapped) on a specific port; ; \u0026#39;/path/to/unix/socket\u0026#39; - to listen on a Unix socket. ; Note: This value is mandatory. ;listen = /run/php/php8.2-fpm.sock --\u0026gt; Comenta esta linea listen = 127.0.0.1:9000 Guarda los cambios y cierra el archivo.\nAhora vamos a editar la configuración del sitio virtual por defecto para hacerlo funcionar con fpm .\nPara lograrlo, vamos a modificar el contenido dentro de la sección location en la configuración del servidor. Aquí te proporciono un ejemplo de archivo de configuración que puedes utilizar:\nserver { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.php index.htm index.nginx-debian.html ; server_name _; location / { try_files $uri $uri/ =404; } location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; #fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } Ahora vamos a reiniciar los servicios tanto de php como de Nginx para asegurar de que sea aplicado la configuración , pero primero vamos a comprobar si tienes errores de sintaxis en ambos ficheros .\nPara comprobar errores de sintaxis en Nginx :\njaviercruces@IWEB:~$ sudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful Si la salida es correcta continua comprobando si has cometido errores de sintaxis en la configuración de PHP-FPM :\njaviercruces@IWEB:~$ sudo php-fpm8.2 -t [02-Nov-2023 17:33:02] NOTICE: configuration file /etc/php/8.2/fpm/php-fpm.conf test is successful Una vez las dos salidas de estos comandos no contienen errores , vamos a reiniciar ambos servicios para que se aplique la configuración :\njaviercruces@IWEB:/etc/nginx$ sudo systemctl restart php8.2-fpm nginx.service Comprobación de funcionamiento Para asegurarnos de que el servidor está funcionando correctamente con PHP-FPM, vamos a crear un archivo llamado info.php que mostrará información sobre la configuración de PHP en el servidor. A continuación, te mostraré cómo crear el archivo:\njaviercruces@IWEB:~$ sudo nano /var/www/html/info.php Dentro del archivo info.php, agrega el siguiente contenido:\n\u0026lt;?php phpinfo(); ?\u0026gt; Guarda y cierra el archivo\nEste archivo PHP mostrará información detallada sobre la configuración de PHP en tu servidor. Puedes acceder a él en tu navegador visitando http://tudominio.com/info.php (reemplaza tudominio.com con tu nombre de dominio real) o también puedes acceder al mismo poniendo en el navegador la IP de tu maquina.\nUna vez hecho esto , ya tienes instalado la pila LEMP para que la utilices en tus CMS.\n","date":"October 28, 2023","hero":"/images/iweb/lamp/portada_lemp.png","permalink":"https://www.javiercd.es/posts/iaw/lemp/lemp/","summary":"Instalación pila LEMP en debian 12 con PHP-8 En esta guía, te explicare los pasos necesarios para instalar una pila LEMP (Linux, Nginx, MariaDB y PHP) en un servidor con Debian 12. La configuración incluirá PHP 8.2 como versión principal. La pila LEMP es esencial para alojar sitios web y aplicaciones web basadas en PHP, como WordPress u otras aplicaciones dinámicas. Sigue los pasos detallados a continuación para configurar tu servidor LEMP con PHP 8.","tags":["WordPress","CMS","IWEB","AW","debian","LEMP"],"title":"Instalación pila LEMP en debian 12 con PHP-8"},{"categories":null,"contents":" Instalación WordPress en Debian 12 con pila LAMP PHP-8 WordPress es un sistema de gestión de contenidos (CMS, por sus siglas en inglés) de código abierto muy popular que se utiliza para crear y administrar sitios web y blogs. Fue lanzado por primera vez en 2003 y desde entonces ha ganado una amplia base de usuarios y una comunidad activa de desarrolladores y diseñadores.\nPreparación Antes de empezar con la instalación de WordPress vamos a dejar claro en una lista cual es el ecosistema de nuestro servidor para que todo funcione correctamente:\nServidor LAMP completo: Apache + MySQL -o MariaDB- y PHP 8.x. Configurado un VirtualHost para nuestro dominio. Creación de base de datos con usuario. Si no tienes instalado la pila LAMP sigue puedes hacerlo en este enlace.\nCreación del VirtualHost Copiamos el archivo de configuración predeterminado de Apache y lo renombramos a wordpress.conf\njaviercruces@IWEB:/etc/apache2/sites-available$ sudo cp 000-default.conf wordpress.conf Configuramos el sitio virtual , recuerda cambiar el ServerName y DocumentRoot\n\u0026lt;VirtualHost *:80\u0026gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request\u0026#39;s Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. ServerName wordpress.fjcd.es ServerAdmin webmaster@localhost DocumentRoot /var/www/wordpress # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \u0026#34;a2disconf\u0026#34;. #Include conf-available/serve-cgi-bin.conf \u0026lt;/VirtualHost\u0026gt; Habilitamos el sitio virtual wordpress.conf\njaviercruces@IWEB:/etc/apache2/sites-available$ sudo a2ensite wordpress.conf Enabling site wordpress. To activate the new configuration, you need to run: systemctl reload apache2 Recargamos Apache para aplicar la nueva configuración\njaviercruces@IWEB:/etc/apache2/sites-available$ sudo systemctl reload apache2 Para acceder a este VirtualHost , en la maquina donde vayas a acceder al wordpress , al no tener servidor dns recuerda poner en el fichero host la ip de tu servidor con el ServerName :\njaviercruces@HPOMEN15:~$ cat /etc/hosts #Añade la IP de tu servidor y el ServerName correspondiente (wordpress.fjcd.es) #Ponlo al final del fichero y no modifiques las lineas existentes en tu fichero 192.168.125.27 wordpress.fjcd.es Creación de la base de datos con un usuario. Te recomiendo que apuntes los datos introducidos a continuación ya que los necesitaras mas adelante . Nos conectamos a la base de datos :\njaviercruces@IWEB:~$ sudo mysql -u root -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 31 Server version: 10.11.4-MariaDB-1~deb12u1 Debian 12 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. #Creamos una base de datos : MariaDB [(none)]\u0026gt; CREATE DATABASE fjcd_wordpress; Query OK, 1 row affected (0,001 sec) #Nos creamos el usuario para nuestra base de datos MariaDB [(none)]\u0026gt; CREATE USER \u0026#39;fjcd-wordpress\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;tu_contraseña\u0026#39;; Query OK, 0 rows affected (0,013 sec) #Le damos permisos sobre la base de datos que hemos creado: MariaDB [(none)]\u0026gt; GRANT ALL PRIVILEGES ON fjcd_wordpress.* TO \u0026#39;fjcd-wordpress\u0026#39;@\u0026#39;localhost\u0026#39;; Query OK, 0 rows affected (0,010 sec) #Actualizamos los permisos: MariaDB [(none)]\u0026gt; FLUSH PRIVILEGES; Query OK, 0 rows affected (0,000 sec) #Nos salimos de la CLI de mysql MariaDB [(none)]\u0026gt; EXIT; Bye Instalación de WordPress Lo primero que haremos será descargarnos WordPress, podemos hacerlo usando wget o si lo tenemos descargado en nuestro anfitrión pasarlo haciendo uso de SCP o FTP .\njaviercruces@IWEB:~$ wget https://wordpress.org/latest.tar.gz --2023-10-27 12:33:17-- https://wordpress.org/latest.tar.gz Resolviendo wordpress.org (wordpress.org)... 198.143.164.252 Conectando con wordpress.org (wordpress.org)[198.143.164.252]:443... conectado. Petición HTTP enviada, esperando respuesta... 200 OK Longitud: 23465047 (22M) [application/octet-stream] Grabando a: «latest.tar.gz» latest.tar.gz 100%[=====================================\u0026gt;] 22,38M 14,8MB/s en 1,5s 2023-10-27 12:33:19 (14,8 MB/s) - «latest.tar.gz» guardado [23465047/23465047] Y descomprimiremos el fichero y copiaremos los ficheros dentro del DocumentRoot de nuestro VirtualHost:\njaviercruces@IWEB:~$ sudo mkdir /var/www/wordpress/ javiercruces@IWEB:~$ sudo tar -zxf latest.tar.gz -C /var/www/ Entramos a la ruta del WordPress para realizar poner correctamente el esquema de permisos :\njaviercruces@IWEB:~$ cd /var/www/ Cambiamos usuario y grupos:\njaviercruces@IWEB:/var/www$ sudo chown -R www-data:www-data wordpress/ Una vez hemos configurado todo esto, ahora ya podemos acceder con nuestro navegador a nuestro dominio para iniciar la instalación de WordPress.\nInstalación Web Accedemos a la url que hemos puesto en el ServerName de nuestro sitio virtual y posteriormente hemos configurado en el fichero hosts .\nLo primero sera seleccionar el idioma :\nA continuación nos dará una breve explicación de que es el CMS WordPress :\nAhora deberás de introducir los datos referente a los usuarios y el nombre de la base de datos que has creado con anterioridad\nUna vez introducidos los datos correctos continuaremos con la instalación :\nAhora deberás de introducir los datos para tu wordpress , como el nombre del sitio asi como la creación de un usuario administrador para que posteriormente puedas acceder a wp-admin:\nListo !! Ya has instalado wordpress\nAhora para acceder al panel de administración de wordpress deberás de introducir la siguiente url en tu navegador e inicia sesión con el usuario que has creado:\nListo !! Asi se ve el panel de administración de wordpress:\n","date":"October 28, 2023","hero":"/images/iweb/wordpress/portada_wordpress.png","permalink":"https://www.javiercd.es/posts/iaw/wordpress/instalacion_wordpress/","summary":"Instalación WordPress en Debian 12 con pila LAMP PHP-8 WordPress es un sistema de gestión de contenidos (CMS, por sus siglas en inglés) de código abierto muy popular que se utiliza para crear y administrar sitios web y blogs. Fue lanzado por primera vez en 2003 y desde entonces ha ganado una amplia base de usuarios y una comunidad activa de desarrolladores y diseñadores.\nPreparación Antes de empezar con la instalación de WordPress vamos a dejar claro en una lista cual es el ecosistema de nuestro servidor para que todo funcione correctamente:","tags":["WordPress","CMS","IWEB","AW","debian"],"title":"Instalación WordPress en Debian 12 con pila LAMP PHP-8"},{"categories":null,"contents":" Instalación WordPress en Debian 12 con pila LEMP PHP-8 WordPress es un sistema de gestión de contenidos (CMS, por sus siglas en inglés) de código abierto muy popular que se utiliza para crear y administrar sitios web y blogs. Fue lanzado por primera vez en 2003 y desde entonces ha ganado una amplia base de usuarios y una comunidad activa de desarrolladores y diseñadores.\nRequisitos previos Servidor con Linux: Debes disponer de un servidor que ejecute Linux , la guía esta pensada para Debian 12 . Usuario con permisos de superusuario: Debes tener acceso a un usuario con privilegios sudo en el servidor para poder llevar a cabo las tareas de instalación y configuración. Nombre de Dominio Completo (FQDN): Si deseas acceder a tu sitio WordPress a través de un dominio personalizado, asegúrate de tener configurado y apuntando un nombre de dominio completo (FQDN) al servidor. Acceso a Internet: Necesitas acceso a Internet para descargar paquetes y realizar actualizaciones durante el proceso de instalación. Asegúrate de cumplir con todos estos requisitos antes de comenzar con la instalación de WordPress en tu servidor .\nSi no tienes instalado la pila LEMP sigue puedes hacerlo en este enlace.\nCreación de un VirtualHost en Nginx La creación de un VirtualHost en Nginx te permite configurar múltiples sitios web en un único servidor. Sigue estos pasos para crear un VirtualHost en Nginx.\nCopia el archivo de configuración por defecto de Nginx para usarlo como ejemplo y nómbralo como quieras. En este ejemplo, lo nombraremos \u0026ldquo;wordpress\u0026rdquo; , ya que vamos a instalarlo sin embargo el nombre es meramente informativo.\njaviercruces@IWEB:~$ sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/wordpress Vamos a editar el contenido del mismo , para ello :\njaviercruces@IWEB:~$ sudo nano /etc/nginx/sites-available/wordpress Aquí te dejo el ejemplo del fichero de configuración de mi sitio , asegúrate de definir el nombre del servidor (tu dominio) y el directorio raíz del sitio.\nserver { listen 80; root /var/www/wordpress; # Cambia esta linea por la ubicación del directorio root de tu wordpress index index.php index.html index.htm; server_name wordpress.fjcd.es; # Cambia esta linea y pon el FQDN , a traves de este accederás a tu wordpress client_max_body_size 500M; location / { try_files $uri $uri/ /index.php?$args; } location = /favicon.ico { log_not_found off; access_log off; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log_not_found off; } location = /robots.txt { allow all; log_not_found off; access_log off; } location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } Para hacer esta configuración activa vamos a crear un enlace simbólico\njaviercruces@IWEB:~$ sudo ln -s /etc/nginx/sites-available/wordpress /etc/nginx/sites-enabled/ Ahora vamos a reiniciar nginx , para que se apliquen los cambios :\njaviercruces@IWEB:~$ sudo systemctl reload nginx Para acceder a este VirtualHost , en la maquina donde vayas a acceder al wordpress , al no tener servidor dns recuerda poner en el fichero host la ip de tu servidor con el ServerName :\njaviercruces@HPOMEN15:~$ cat /etc/hosts #Añade la IP de tu servidor y el ServerName correspondiente (wordpress.fjcd.es) #Ponlo al final del fichero y no modifiques las lineas existentes en tu fichero 192.168.125.27 wordpress.fjcd.es Creación de la base de datos con un usuario. Te recomiendo que apuntes los datos introducidos a continuación ya que los necesitaras mas adelante . Nos conectamos a la base de datos :\njaviercruces@IWEB:~$ sudo mysql -u root -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 31 Server version: 10.11.4-MariaDB-1~deb12u1 Debian 12 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. #Creamos una base de datos : MariaDB [(none)]\u0026gt; CREATE DATABASE fjcd_wordpress; Query OK, 1 row affected (0,001 sec) #Nos creamos el usuario para nuestra base de datos MariaDB [(none)]\u0026gt; CREATE USER \u0026#39;fjcd-wordpress\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;tu_contraseña\u0026#39;; Query OK, 0 rows affected (0,013 sec) #Le damos permisos sobre la base de datos que hemos creado: MariaDB [(none)]\u0026gt; GRANT ALL PRIVILEGES ON fjcd_wordpress.* TO \u0026#39;fjcd-wordpress\u0026#39;@\u0026#39;localhost\u0026#39;; Query OK, 0 rows affected (0,010 sec) #Actualizamos los permisos: MariaDB [(none)]\u0026gt; FLUSH PRIVILEGES; Query OK, 0 rows affected (0,000 sec) #Nos salimos de la CLI de mysql MariaDB [(none)]\u0026gt; EXIT; Bye Instalación de WordPress Lo primero que haremos será descargarnos WordPress, podemos hacerlo usando wget o si lo tenemos descargado en nuestro anfitrión pasarlo haciendo uso de SCP o FTP .\njaviercruces@IWEB:~$ wget https://wordpress.org/latest.tar.gz --2023-10-27 12:33:17-- https://wordpress.org/latest.tar.gz Resolviendo wordpress.org (wordpress.org)... 198.143.164.252 Conectando con wordpress.org (wordpress.org)[198.143.164.252]:443... conectado. Petición HTTP enviada, esperando respuesta... 200 OK Longitud: 23465047 (22M) [application/octet-stream] Grabando a: «latest.tar.gz» latest.tar.gz 100%[=====================================\u0026gt;] 22,38M 14,8MB/s en 1,5s 2023-10-27 12:33:19 (14,8 MB/s) - «latest.tar.gz» guardado [23465047/23465047] Y descomprimiremos el fichero y copiaremos los ficheros dentro del DocumentRoot de nuestro VirtualHost:\njaviercruces@IWEB:~$ sudo mkdir /var/www/wordpress/ javiercruces@IWEB:~$ sudo tar -zxf latest.tar.gz -C /var/www/ Entramos a la ruta del WordPress para realizar poner correctamente el esquema de permisos :\njaviercruces@IWEB:~$ cd /var/www/ Cambiamos usuario y grupos:\njaviercruces@IWEB:/var/www$ sudo chown -R www-data:www-data wordpress/ Una vez hemos configurado todo esto, ahora ya podemos acceder con nuestro navegador a nuestro dominio para iniciar la instalación de WordPress.\nInstalación Web Accedemos a la url que hemos puesto en el ServerName de nuestro sitio virtual y posteriormente hemos configurado en el fichero hosts .\nLo primero sera seleccionar el idioma :\nA continuación nos dará una breve explicación de que es el CMS WordPress :\nAhora deberás de introducir los datos referente a los usuarios y el nombre de la base de datos que has creado con anterioridad\nUna vez introducidos los datos correctos continuaremos con la instalación :\nAhora deberás de introducir los datos para tu wordpress , como el nombre del sitio asi como la creación de un usuario administrador para que posteriormente puedas acceder a wp-admin:\nListo !! Ya has instalado wordpress\nAhora para acceder al panel de administración de wordpress deberás de introducir la siguiente url en tu navegador e inicia sesión con el usuario que has creado:\nListo !! Asi se ve el panel de administración de wordpress:\n","date":"October 28, 2023","hero":"/images/iweb/wordpress/portada_wordpress.png","permalink":"https://www.javiercd.es/posts/iaw/wordpress_lemp/instalacion_wordpress_lemp/","summary":"Instalación WordPress en Debian 12 con pila LEMP PHP-8 WordPress es un sistema de gestión de contenidos (CMS, por sus siglas en inglés) de código abierto muy popular que se utiliza para crear y administrar sitios web y blogs. Fue lanzado por primera vez en 2003 y desde entonces ha ganado una amplia base de usuarios y una comunidad activa de desarrolladores y diseñadores.\nRequisitos previos Servidor con Linux: Debes disponer de un servidor que ejecute Linux , la guía esta pensada para Debian 12 .","tags":["WordPress","CMS","IWEB","AW","debian"],"title":"Instalación WordPress en Debian 12 con pila LEMP PHP-8"},{"categories":null,"contents":"\rA lo largo de esta guía, exploraremos la configuración de un escenario básico utilizando redes IPv6 tanto en sistemas Linux como en dispositivos Cisco. Además, abordaremos la configuración de un servidor Apache aprovechando las capacidades de IPv6.\nLinux Autoconfiguración IPV6 Conecta dos máquinas Linux al mismo switch y comprueba que tienen conectividad con IPv6 usando la dirección de enlace local.\nComprobaremos las IPV6 que tienen los distintos pcs . El PC1 tiene –\u0026gt; fe80::ef7:42ff:fe92:0/64\nMientras que el PC2 tiene –\u0026gt; fe80::e5f:61ff:feee:0/64\nEstas dos direcciones se denominan de enlace local y se asignan automáticamente a cada interfaz de red . Este tipo solo nos permitirá comunicarnos con los dispositivos de nuestra red local y tienen el prefijo –\u0026gt; FE80::/10\nSi hacemos un ping desde uno de estos a otros con la dirección de enlace local podremos comunicarnos :\nSLAAC Añade a la misma red una tercera máquina Linux y configúrala como router de forma que dé direcciones IPv6 globales a las otras dos usando SLAAC. No olvides instalar RADVD. Comprueba que tienen conectividad.\nLo primero que haremos sera configurar la interfaz de red por ipv6 de nuestro router en este caso le asignare el prefijo 3333:db7::\nCalculamos la parte fija de nuestra dirección :\nR1 –\u0026gt; 0c:01:30:a0:00:00 –\u0026gt; 0c:01:30:ff:fe:a0:00:00 –\u0026gt; 0E:01:30:FF:FE:A0:00:00\nEditamos el interfaces y aplicamos la configuración de nuestra tarjeta de red :\nReiniciamos al servicio y tendríamos una direccion global :\nSLAAC(Stateless Address Autoconfiuration) es un mecanismo de configuración único para IPV6 no existe un equivalente en IPV4. El cual nos permite que los nodos de nuestra red se configuren automáticamente .\nA partir de la dirección de enlace local que tienen todos los host , mediante el protocolo neighbour discovery solicita si hay algún router dentro de la red local le facilite los parámetros de configuración de la red\nLo primero que haremos para configurar SLAAC sera instalar el paquete radvd :\nSi miramos el estado del demonio este nos dirá que no encuentra su fichero de configuración :\nAsí que le generaremos uno indicándole la interfaz que va a repartir direcciones y además le diremos el comportamiento que tendrá en nuestra red :\nMinRtrAdvInterval : Indica el tiempo mínimo en segundos por el cual el router mandara un mensaje en segundos .\nMaxRtrAdvInterval: Indica el tiempo máximo en segundo por el cual el router mandara un mensaje .\nAdvSendAdvert: Indica si por la interfaz se mandaran avisos o no .\nAdvManagedFlag: Indica si queremos que el servicio utilice DHCPv6(on) o no (off) .\nPrefix: Indica el prefijo de red que usara SLAAC para asignar direcciones .\nAdvValidLifetime: Indica el tiempo en segundos que una dirección IPV6 sera valida.\nAdvPreferredLifetime: Indica el tiempo en segundos que una dirección generada a partir del prefijo sera preferida en lugar de otras direcciones .\nUna vez hecho esto reiniciamos el servicio y el demonio comenzara a configurar a nuestros clientes :\nAdemás deberemos de configurar el bit de forwarding para ipv6 en nuestro router , al igual que con ipv4 editamos el archivo /etc/sysctl.conf :\nMensajes de SLAAC Podemos ver como se ha configurado el PC1 usando SLAAC :\nTambién el PC2 se ha configurado :\nVamos a estudiar los mensajes que han intervenido en esta configuración de SLAAC , si los numeramos como en esta captura de Wireshark :\nRouter solicitation (RS) (No aparece en la captura) : El PC le envía un mensaje de RS a todos los routers para indicar que necesita un RA , este mensaje se envía si no recibe ningún RA pasado un tiempo. Router Advertisement (RA): Una vez el router recibe el RS o periódicamente envía un RA en el cual se incluye el prefijo de la red y su longitud . El mensaje RA se envía a la dirección IPv6 de multidifusión de todos los nodos, FF02::1, con la dirección link-local del router como la dirección IPv6 de origen. (N0 6 y 12). Multicast Listener Report Message v2:Indica que el dispositivo x ha iniciado una sesión de escucha para trafico multicast (No 7 y 9). Neighbor Solicitation (NS): Se utiliza para conocer la dirección MAC de un dispositivo de tu red , es similar al protocolo ARP .(No 10,11,613). Neighbor Advertisement (NA) : Es el mensaje de respuesta de un NS (No 614). Una vez que el cliente a recibido un RA , este procede a configurar su dirección IPV6 , con un prefijo de red de 64 bits pero necesita una IID(Interface Identifier) .\nHay dos maneras en las que los clientes pueden crear su propia IID única:\nEUI-64: mediante el proceso EUI-64, la PC1 crea una IID utilizando su dirección MAC de 48 bits. De generación aleatoria: la IID de 64 bits puede ser un número aleatorio generado por el sistema operativo cliente. Dado que SLAAC es un proceso sin estado, para que los clientes pueda utilizar esta dirección IPv6 creada recientemente, debe verificar que sea única. El cliente enviara un NS con su propia dirección como la dirección IPv6 de destino. Si ningún otro dispositivo responde con un mensaje de anuncio de vecino, la dirección es única y puede ser utilizada por el cliente. Si este recibe un NA, la dirección no es única, y el sistema operativo debe determinar una nueva ID de interfaz para utilizar.\nEste proceso forma parte de la detección de vecinos ICMPv6 y se conoce como “detección de direcciones duplicadas (DAD)”.\nEsta imagen explica la configuración de una interfaz por SLAAC. Ahora vamos a comprobar que los distintos clientes tienen conectividad entre si :\nPC1 –\u0026gt; 3333:db7::ef7:42ff:fe92:0 PC2 –\u0026gt; 3333:db7::e5f:61ff:feee:0\nR1 –\u0026gt; 3333:db7::e01:30ff:fea0:0\nRouter 1 :\nPC2:\nTenemos que tener en cuenta que estas “concesiones” de direcciones no se almacenan en ningún sitio , es decir en el servidor no almacenamos las configuraciones que ha realizado el servicio .\nDHCPv6 con SLAAC Cambia la configuración para que utilice DHCPv6 en vez de SLAAC enviando también los servidores DNS. Comprueba que las máquinas tienen conectividad.\nPara ello nos instalamos el servidor DHCPv6 , el paquete es el mismo para ipv4 :\nEditamos el fichero de configuración para IPV6 –\u0026gt; sudo nano /etc/dhcp/dhcpd6.conf:\nEn el fichero /etc/default/isc-dhcp-server indicaremos no solo la interfaz que queremos repartir direcciones si no también especificaremos que el servidor funcionara por IPV6 :\nReiniciamos el servicio y comprobamos que esta funcionando con los parámetros que le hemos asignado en la configuraron :\nVamos a comprobar que los clientes se configuraran usando ipv6 , para ello la configuración en el network interfaces es bastante similar a IPV4 :\nReiniciamos el servicio networking.service y obtendremos la configuración por DHCP en la tarjeta :\nAdemás también podemos ver las concesiones el fichero de concesiones , en el servidor en la siguiente ruta /var/lib/dhcp/dhcpd6.leases :\nNo lo he mencionado anteriormente pero para que al producirse la configuración el cliente obtenga los parámetros que hemos configurado por DHCPv6 tendremos que poner este parámetro a ON en el fichero de configuración de SLAAC :\nComo podemos ver el único parámetro que hemos especificado en el servidor DHCP a sido el DNS de google ha sido correctamente configurado en nuestro cliente :\nMensajes DHCPv6 con SLAAC Acabamos de configurar SLAAC y DHCPv6 sin estado , esto significa que :\nUsa SLAAC para obtener una dirección IPV6 de tipo global unicast , además de la puerta de enlace . Usa el servidor DHCPv6 sin estado, para el resto de parámetros de configuración de nuestra red . Es decir hemos configurado la segunda opción de la siguiente imagen :\nLas capturas que verás a continuación NO están recortadas debido a que se ven pixeladas. Los mensajes de la comunicación están en orden. Si observamos la captura de Wireshark y la comparamos con la configuración única de SLAAC :\nOperaciones de SLAAC:\nPodemos ver que el PC1 a solicitado un RS , a todos los routers de la red (Multicast) R1 le responde a PC1 con un RA(Indica si necesitara comunicarse con un DHCPv6 con estado o sin estado) NS , para comprobar que la dirección asignada no esta duplicada Operaciones de DHCPv6:\nSolicit a todos los servidores DHCPv6 de la red (Multicast a ff02::1:2) incluye un identificador de cliente CID. Advertise : Es la respuesta del servidor DHCPv6 a un solicit , este incluye las opciones de configuración oportunos , incluido una IPv6 . También incluye un CID y un XID(Id transacción). Request: El cliente envía este mensaje a todos los servidores DHCPv6 para indicar que desea los parámetros ofertados en el Adverstise . También incluyen CID y XID. Reply: El servidor DHCPv6 responde y confirma que la dirección ha sido asignada así como todos los parámetros adicionales de configuración .También incluyen CID y XID. Aquí te dejo una imagen en la que se observa el orden de los mensajes que hemos recibido y una breve descripción del mismo , además nos indica si los mensajes son unicast o multicast :\nApache en IPV6 Para las versiones de Apache superiores a 2.X tienen soporte para IPV6 habilitado por defecto así que al instalar el servicio ya estaremos escuchando por este protocolo sin necesidad de realizar ninguna configuración adicional en el servicio .\nPodemos comprobar si al instalarlo nuestro servidor esta escuchando por ese puerto :\nEn el caso de que creemos un virtualhost podemos especificar como queremos que trabajen si usando ambos protocolos IPV6 y IPV4 o solo uno de ellos . Vemos que ssh también utiliza ipv6 por defecto .\nAcceso al servidor web desde dentro de la red Vamos a acceder desde las maquinas de nuestra red en mi caso lo he montado en el router ya que es el único que tiene acceso a internet en este escenario .\nMe conectare a el utilizando la direccion global pero podríamos usar la local sin problema ya que pertenecemos a la misma red local .\nAcceso desde PC2:\nAcceso al servidor web desde fuera de la red Para esto deberemos de configurar R1 y ‘PC3’ en la misma red usando IPV6 :\nPC3:\nR1:\nLe haremos la petición a PC1 desde PC3 que esta fuera de esa red local , como vemos no es necesario hacer NAT .\nIncluso puedo hacerle ping a un host desde otra red :\nSi analizamos estas peticiones con Wireshark podemos ver que en ningún momento se produce NAT:\nFuera de la red :\nDentro de la red:\nPor supuesto un host de nuestra red local puede acceder al servidor web :\nCISCO Configuración de un router cisco en IPV6 Lo primero que haremos sera calcular la direccion IPV6 que le corresponden a las MACS :\nF 0/0 –\u0026gt; CA:01:6C:FA:00:00 –\u0026gt; CA:01:6C:FF:FE:FA:00:00 –\u0026gt; C801:6CFF:FEFA:0\nF 1/0 –\u0026gt; CA:01:6C:FA:00:1C-→ CA:01:6C:FF:FE:FA:00:1C –\u0026gt; C801:6CFF:FEFA:001C\nPara que nuestro router se configure usando SLACC y no tengamos que hacer esto manualmente introduciremos los siguientes comandos para cada una de las interfaces que queramos que se configuren por SLAAC :\nTambién deberemos de indicarle no shut para que se levante la interfaz .\nCon el siguiente comando comprobaremos que nuestro router se ha configurado correctamente automáticamente usando SLAAC :\nYa con las direcciones de enlace local tendremos conectividad con el router :\nSLAAC Ahora vamos a hacer que el router configure a los clientes usando SLAAC .\nVamos a configurar una dirección global a nuestro router en la interfaz que da a la red que queremos darle este servicio , con el prefijo de red : 3333:db7::\nVamos a utilizar EUI-64 para configurar nuestras interfaces :\nFastEthernet 0/0 –\u0026gt; 3333::C801:6CFF:FEFA:0/64\nFastEthernet 1/0 –\u0026gt; 2222::C801:6CFF:FEFA:1C/64\nComprobamos las direcciones IPV6 se han “generado” correctamente :\nPara que el router nos configure a los clientes deberemos de introducir el siguiente comando este , hará que nuestro router mande RA y conteste a las peticiones de RS:\nUna vez hecho esto nuestros clientes se habrán configurado correctamente :\nPC1:\nPC2:\nLos mensajes que se han producido al configurar los clientes :\nRouter solicitation (RS): El PC le envía un mensaje de RS a todos los routers para indicar que necesita un RA , este mensaje se envía si no recibe ningún RA pasado un tiempo.\nRouter Advertisement (RA): Una vez el router recibe el RS o periódicamente envía un RA en el cual se incluye el prefijo de la red y su longitud . En el caso de que el router responda a un RS este le envía un RA especifico al host que lo ha solicitado . En el caso de que sea un mensaje RA periódico se envía a la dirección IPv6 de multidifusión de todos los nodos, FF02::1, con la dirección link-local del router como la dirección IPv6 de origen.\nNeighbor Solicitation (NS): Se utiliza para conocer la direccion MAC de un dispositivo de tu red , es similar al protocolo ARP .\nNeighbor Advertisement (NA) : Es el mensaje de respuesta de un NS .\nDHCPv6 con SLAAC Configurar un servidor de DHCPv6 con estado es similar a configurar un servidor sin estado. La diferencia más importante es que un servidor con estado también incluye información de direccionamiento IPv6 de manera similar a un servidor DHCPv4.\nLo primero que tendremos que hacer sera para habilitar el routing IPv6. Este comando no es necesario para que el router sea un servidor de DHCPv6 con estado, pero se requiere para que el router origine los mensajes RA ICMPv6.\n–\u0026gt; ipv6 unicast-routing\nLo tenemos configurado en el apartado anterior así que no lo volveremos a hacer . Configuraremos un pool DHCPV6 :\nCon DHCPv6 con estado, todos los parámetros de direccionamiento y otros parámetros de configuración deben ser asignados por el servidor de DHCPv6. El comando address prefix se utiliza para indicar el conjunto de direcciones que debe asignar el servidor. La opción lifetime indica el tiempo de arrendamiento válido y preferido en segundos. Al igual que con DHCPv6 sin estado, el cliente utiliza la dirección IPv6 de origen del paquete que contenía el mensaje RA.\nLe indicamos el prefijo de red y el tiempo de vida de cada dirección :\nAhora le indicamos los servidores DNS :\nAun podemos configurar mas parámetros como el nombre del dominio pero en mi caso solo me interesa esto , así que procederemos a indicarle en que interfaz tiene que funcionar el servicio :\nAhora comprobaremos que el servidor DHCP , esta funcionado en nuestra interfaz :\nVeremos como en el cliente se ha asignado el servido DNS:\nY la concesión en el servidor DHCP :\nOperaciones de SLAAC:\nPodemos ver que el PC2 a solicitado un RS , a todos los routers de la red (Multicast) R1 le responde a PC1 con un RA(Indica si necesitara comunicarse con un DHCPv6 con estado o sin estado) Operaciones de DHCPv6:\nSolicit a todos los servidores DHCPv6 de la red (Multicast a ff02::1:2) incluye un identificador de cliente CID. Advertise : Es la respuesta del servidor DHCPv6 a un solicit , este incluye las opciones de configuración oportunos , incluido una IPv6 . También incluye un CID y un XID(Id transacción). Request: El cliente envía este mensaje a todos los servidores DHCPv6 para indicar que desea los parámetros ofertados en el Adverstise . También incluyen CID y XID. Reply: El servidor DHCPv6 responde y confirma que la dirección ha sido asignada así como todos los parámetros adicionales de configuración .También incluyen CID y XID. Acceso al servidor web desde dentro de la red Desde nuestra red local podremos hacer la petición al servidor web usando tanto la dirección local de enlace como la dirección global :\nAcceso al servidor web desde fuera de la red SWEB –\u0026gt; 3333:db7::ef7:42ff:fe92:0\nVemos que con la configuración anterior que teníamos en apache podemos acceder sin problema al servidor web desde una maquina de fuera de nuestra red :\nConfiguración básica de apache para IPV6 Como comentaba antes no es necesario a partir de la version 2.X en adelante de configurar nada adicionalmente en apache para que nuestro servidor funcione usando el protocolo IPV6 ya por defecto este escucha en IPV4 y IPV6 .\nSin embargo podemos configurar para que este solo escuche por IPV6 , para ello deberemos de realizar una simple configuración en el servicio . Accederemos al fichero –\u0026gt; /etc/apache2/ports.conf\nComentaremos la linea Listen 80 ya que hace referencia a IPV4 y le añadiremos la referente a ipv6.\nCon esta configuración escucharemos todas las peticiones de cualquier dirección IPV6 , en los corchetes podemos especificar una dirección para responderle peticiones solo a esta .\nAhora accederemos a nuestro host virtual y cambiaremos la declaración de este , al igual que hemos hecho arriba modificando la etiqueta que hace referencia a todas las direcciones IPV4 y la cambiaremos por esta para hacer referencia a todas las direcciones IPV6 por el puerto 80 :\nAhora reiniciaremos el servicio apache y comprobaremos que el estado del mismo es exitoso :\nCon esto ya nuestro servidor apache funcionaria solo en IPV6 :\nBibliografía ¿Que es SLAAC?-Alberto Molina Mensajes de SLAAC Montar un servidor DHCPv6 Debian Mensajes DHCPv6 con SLAAC Apache IPV6 ","date":"October 8, 2023","hero":"/images/redes/escenario_ipv6_basico/portada.jpg","permalink":"https://www.javiercd.es/posts/redes/escenario_ipv6_basico/escenario_ipv6_basico/","summary":"A lo largo de esta guía, exploraremos la configuración de un escenario básico utilizando redes IPv6 tanto en sistemas Linux como en dispositivos Cisco. Además, abordaremos la configuración de un servidor Apache aprovechando las capacidades de IPv6.\nLinux Autoconfiguración IPV6 Conecta dos máquinas Linux al mismo switch y comprueba que tienen conectividad con IPv6 usando la dirección de enlace local.\nComprobaremos las IPV6 que tienen los distintos pcs . El PC1 tiene –\u0026gt; fe80::ef7:42ff:fe92:0/64","tags":["Redes","Enrutamiento","IPV6"],"title":"Escenario IPv6 Básico"},{"categories":null,"contents":"\rEn este post, exploraremos cómo configurar un entorno de Active Directory en un servidor Ubuntu utilizando herramientas como Kerberos y Samba. Active Directory es una solución integral de Microsoft para la gestión de identidades y el control de acceso en redes empresariales. A través de esta guía, aprenderemos paso a paso cómo implementar un servidor Ubuntu como controlador de dominio, establecer la autenticación basada en Kerberos y configurar servicios de directorio mediante Samba.\nIntroducción Se quiere configurar un servidor Linux (Ubuntu Server 20.04 LTS) para dar servicio a un conjunto de equipos clientes (Windows y Linux).\nAprovecharé que el escenario lo tenemos montado de las anteriores actividades de clase y restauraré las instantáneas para disponer de las máquinas limpias .\nPreparación del entorno 1. El servidor Linux no tendrá entorno gráfico. Tendrá al menos las particiones: raiz, home y de intercambio. Aquí podemos ver que no tengo instalado entorno gráfico , podemos ver que el servicio está activo, sin embargo, no se lanza ningún entorno . Además, si buscamos algún proceso con los nombres de escritorio más conocidos no nos lanza ningún resultado .\nAquí te muestro las particiones que tiene mi servidor Ubuntu (raíz , boot , home y swap):\n2.El servidor debe estar preparado para que pueda administrarse de forma remota (a partir de este momento toda la gestión se hará remotamente desde otro equipo de la red). Para administrarlo de forma remota utilizaré ssh, para ello lo instalamos en el servidor :\nUna vez que se instale lo tendremos funcionando , no es necesario realizar ninguna configuración .\nSi consultamos el estado del servicio podemos ver que ha tomado la configuración por defecto :\nPara conectarnos remotamente necesitaremos saber la IP del equipo o el nombre :\nEn mi caso me conectaré desde la red externa a nuestro servidor (enp0s3) , previamente hemos configurado la red con netplan :\nY hemos aplicado los cambios :\nUna vez conociendo estos datos nos conectaremos por ssh desde una máquina de nuestra red para seguir con los demás apartados, en mi caso utilizaré mi máquina host, para ello me he instalado el paquete openssh-client previamente:\n3. Crea los usuarios y grupos siguientes Grupos: profesores, alumnos, smr, asir. Creo los grupos : Usuario a crear : profedesiree, profejose , proferaul , erik, manu, oliver, sandra, fabio y domi Creo los usuarios :\nLos he creado con directorio home y les he asignado la contraseña 1234:\nUsuarios del grupo profesores: profedesiree, profejose y proferaul. Los añadimos : Podemos comprobar que se han añadido con el siguiente comando :\nUsuarios del grupo alumnos: erik, manu, oliver, sandra, fabio y domi. Los añadimos :\nComprobamos que se han añadido :\nUsuarios del grupo smr: profedesiree, profejose, proferaul, erik, manu y oliver. Los añadimos:\nComprobamos que se han añadido :\nUsuarios del grupo asir: sandra, fabio y domi. Comprobamos que se han añadido :\n4. Todos los usuarios serán usuarios Samba. Para ello deberemos tener instalado samba : Para añadir un usuario samba debemos de introducir el siguiente comando y asignarle una contraseña :\nEsto lo haremos con los 9 usuarios , una vez añadidos podemos utilizar este comando para listar los usuarios samba que tenemos :\nControlador de dominio samba 5. Crea y configura un controlador de dominio Samba en el Servidor. Antes de comenzar con la instalación debemos de tener en cuenta una serie de datos :\nNombre del controlador de dominio de Active Directory: FJCD\nNombre DNS del dominio de Active Directory: javiercruces.local Nombre del Reino Kerberos: javiercruces.local Nombre NetBIOS del dominio: javiercruces Dirección IP fija del servidor: 192.168.0.1 Rol del servidor: Domain Controller (DC) Reenviador DNS:192.168.0.1 Una vez con estos datos claros comenzaremos con la instalación , lo primero será actualizar el sistema :\nA continuación deberemos de cambiar el nombre de nuestro servidor para estar acorde con los datos que hemos seleccionado anteriormente, para ello yo he seleccionado mis iniciales , para ello editamos el fichero /etc/hostname :\nAhora será necesario que reiniciemos el equipo para que se apliquen los cambios , perderemos la conexión por ssh :\nRetomamos el control remoto por ssh en unos minutos cuando haya reiniciado :\nComo puedes observar nos hemos conectado usando el antiguo nombre que tenia nuestro servidor , esto es porque el archivo /etc/hosts, contiene una relación de direcciones IP con sus correspondientes nombres lógicos. Este archivo contenía una referencia al nombre antiguo del propio servidor, que cambiaremos para que haga referencia al nuevo nombre :\nUna vez hemos aplicado estos dos cambios , antes de continuar solo nos quedara asegurarnos de que nuestro servidor tiene correctamente configurada la red . En nuestro escenario disponemos de dos tarjetas de red en nuestro servidor :\nenp0s3 (Tarjeta externa , nos da acceso a internet) enp0s8 (Tarjeta interna , es la que se comunica con nuestra red local) Debido a esto la primera está configurada por DHCP, ya que no nos importa la configuración que se le asigne , sin embargo, la segunda está configurada estáticamente, ya que debemos de controlar la configuración de la misma para que tengamos control sobre la misma y posteriormente unir los equipos al dominio .\nUna vez aclarado esto , al principio del documento indico como se configuraran las interfaces , aquí dejo un pantallazo para recordar las direcciones :\nAhora necesitaremos disponer de unos paquetes que deberán de estar instalados antes de comenzar ,estos son :\nsamba: servidor de archivos, impresión y autenticación para SMB/CIFS. smbclient: clientes de línea de comandos para SMB/CIFS. krb5-config: Archivos de configuración para Kerberos Version 5. winbind: Servicio para resolver información sobre usuarios y grupos de servidores Windows NT. Podremos hacer la instalación de estos cuatro paquetes con un simple comando :\nKerberos, nos preguntará por el reino (nombre de dominio ) durante la instalación de los paquetes, en nuestro caso será javiercruces.local :\nAquí introduciremos el nombre de nuestro equipo servidor :\nAquí volveremos a introducir el nombre de nuestro servidor :\nDespués de esto, la instalación continuará un poco más, pero sin necesitar que aportemos más información:\nAhora configuraremos samba , pero antes de hacerlo le cambiaremos el nombre al archivo de configuración smb.conf para que no lo use mientras que lo configuramos y así además tendremos una copia del archivo original :\nUsaremos el comando samba-tool domain provision, para que sea el propio comando sea el que nos solicite los valores que necesite y, cuando sea posible, nos sugiera sus valores predeterminados. Así, si estos coinciden con los que nosotros esperamos, será muy probable que los pasos anteriores hayan sido los correctos:\nComo puedes observar es muy intuitivo hacerlo, ya que salvo la IP de forwarder y la contraseña de administrador hemos elegido las respuestas que el mismo comando nos ofrece . Esta debe cumplir unos requisitos de complejidad mínimos :\n8 caracteres como mínimo 1 mayúscula 1 numero o símbolo Con esto, además de configurarse Samba , se ha generado un archivo de configuración para Kerberos en la ruta /var/lib/samba/private/krb5.conf. Asi que lo copiaremos a /etc :\nLo siguiente será configurar la resolución de nombres, para ello comenzaremos deteniendo los servicios implicados :\nTambién quitaremos que se inicien automáticamente al reiniciar el equipo :\nA continuación, nos aseguraremos de que el servicio samba-ad-dc se podrá iniciar sin dificultades, evitando cualquier enmascaramiento que pueda existir:\nDespués, eliminamos el archivo resolv.conf que, en realidad, será un enlace a stub-resolv.conf. Así que lo eliminamos y creamos uno nuevo para sustiruirlo:\nAhora introducimos los valores adecuados en función de nuestro dominio , para mi caso :\nGuardamos los cambios y salimos del fichero.\nIniciaremos el servicio de samba-ad-dc y lo habilitaremos para que se inicie al reiniciar el equipo :\nComprobar la instalación Si hemos conseguido llegar hasta aquí , tenemos todas las papeletas para que nuestra instalación haya sido correcta . Pero nunca está de más hacer unas comprobaciones\nConsultar el nivel del dominio y crear un nuevo usuario Para saber nuestro nivel de dominio simplemente introducimos este comando :\nAl hacerlo, comprobamos que el nivel del dominio, y del bosque donde se encuentra, equivale a una instalación Windows Server 2008 R2\nProbaremos a crear una nueva cuenta de usuario en el dominio con el comando(deberemos de tener en cuenta la política de contraseñas):\nConfirmar que el servidor DNS funciona de forma adecuada Lo primero será comprobar el servicio LDAP sobre el protocolo TCP, para lo que escribiremos la siguiente orden:\nSi tenemos una respuesta parecida a esa, todo funciona como debe.\nA continuación, comprobaremos el registro SRV para el protocolo Kerberos sobre UDP, para lo que usamos la siguiente orden:\nLa respuesta debe ser parecida a la anterior, si es así registro SRV es correcto.\nPor último, comprobamos la resolución del nombre de nuestro servidor:\nComprobar el funcionamiento de Kerberos Para comprobar el funcionamiento podemos, por ejemplo, usar el comando smbclient para comprobar los servicios que puede obtener un determinado usuario. Para ello utilizaremos el siguiente comando :\nSi la autenticación es correcta , ya sabremos que Kerberos está haciendo su trabajo . Si queremos, incluso podemos iniciar sesión en el servidor empleando la cuenta de administrador. Para lograrlo, usaremos una sintaxis como esta:\nYa hemos verificado todo así que podemos empezar a unir clientes a nuestro dominio .\nUnir clientes al dominio 6. Integra al menos un cliente con Windows en el dominio Samba. Cliente Windows Lo primero que haremos será configurar la red de nuestro cliente :\nIP : 192.168.0.10 Mascará de subred : /24 Puerta de enlace 192.168.0.1 DNS 192.168.0.1 Ambas tarjetas (Interna del servidor y la de Windows cliente ) deberán de estar en red interna para que se comuniquen .\nUna vez configurada la tarjeta le haremos un ping al servidor para comprobar la conectividad:\nAhora accedemos a panel de control → sistema y seguridad → sistema → configuración avanzada del sistema → nombre de equipo → id de red . Seleccionamos la primera opción para unirnos al dominio\nSeleccionaremos la primera opción, ya que nuestra red tiene un dominio :\nAhora deberemos de introducir los datos del usuario administrador y el nombre de nuestro dominio :\nEl usuario administrador que se crea por defecto en samba se llama administrator\nUna vez introducido los datos nos preguntará si queremos crear una cuenta de dominio en este equipo , yo seleccionare que no :\nY para que se apliquen los cambios deberemos de reiniciar :\nUna vez reiniciado podremos iniciar sesión con los diferentes usuarios de nuestro dominio :\nPodemos ver que podemos iniciar sesión en el equipo con las cuentas de nuestro dominio:\nCliente Linux Lo primero será configurar la red, para ello le he asignado la dirección IP 192.168.0.2\nAhora deberemos añadir a nuestro servidor en el fichero hosts, una línea en la que ira la dirección IP de nuestro servidor seguido del nombre de este y el nombre completo del dominio de nuestro servidor :\nPara comprobar este cambio que hemos realizado le haremos un ping al servidor usando su nombre :\nAhora actualizaremos el equipo para poder descargar las versiones más recientes desde los repositorios :\nPara tener internet en el cliente he configurado previamente NAT en el servidor .\nUna vez actualizado el sistema instalaremos los siguientes paquetes :\nsssd (System Security Services Daemon): Administra los mecanismos de autenticación y el acceso a directorios remotos. Sustituye al clásico Winbind aportando más velocidad y estabilidad. heimdal-clients: Se trata de una implementación libre de Kerberos 5 creada con la intención de ser compatible con el protocolo Kerberos implementado por el MIT. msktutil: La utilidad que obtiene y administra los keytabs de Kerberos en un entorno de Microsoft Active Directory. Podemos hacerlo con 1 comando :\nMientras instalamos nos solicitara el nombre de nuestro servidor de active directory asi que lo introducimos :\nAhora nos preguntará el nombre del equipo que actúa como servidor en nuestro caso es :\nPor último nos preguntará por el servidor administrativo que en nuestro caso es el mismo:\nUna vez hecho esto, la instalación continuará sin que tengamos que introducir más datos.\nAhora vamos a añadir en Kerberos unos datos adicionales para asegurarnos que se comporte correctamente. Comenzaremos por cambiar el nombre del archivo de configuración, para poder volver a los parámetros originales si fuese preciso:\nAhora utilizaremos nano para editar la configuración del archivo , este estará vacío así que añadiremos lo siguiente :\nUna vez rellenado con los datos de nuestro dominio, guardamos el archivos y comprobaremos si podemos iniciarnos sesión en el dominio :\nSi la salida no nos ofrece ningún tipo de error, es porque el proceso de autenticación ha funcionado correctamente.\nProcederemos a unirnos al dominio, para ello utilizaremos el siguiente comando :\nEste comando deberemos de rellenarlo conforme a los datos de nuestro dominio , en el caso de que no nos salga ninguna salida , nos habremos unido al dominio .\nPara completar la tarea, eliminaremos los tickets de autorización de kerberos que activamos al ejecutar kinit. Para lograrlo, basta con utilizar el comando kdestroy.\nCompartir carpetas 7. Se necesitan carpetas personales en el servidor para cada usuario. También habrá una carpeta para cada grupo, a la que solo podrán acceder y escribir los miembros de cada grupo. Vamos a crear los directorios en la partición raíz para cada usuario y uno para cada grupo. Estos los crearé con el nombre del grupo o usuario:\nTenemos que tener en cuenta que los usuarios samba que hemos generado al principio del documento se han eliminado al instalar el dominio y deberemos de producirlos nuevamente.\nVamos a compartir estas carpetas a través de samba, para ello editamos el fichero /etc/samba/smb.conf :\nPara indicar que pueda acceder un grupo deberemos de poner una @ delante dele nombre del grupo :\nSolo nos quedaría asignar correctamente los permisos locales adecuados para nuestros recursos y cambiar los propietarios de las carpetas para que los usuarios puedan escribir en ellas :\nEsto sería lo correcto, pero si le asignamos los permisos 775 no podremos escribir en la carpeta, así que le asignaremos todos los permisos :\nAhora repetiremos esto con todos los directorios , primero le daré los permisos:\nY por último cambiaremos los propietarios de las carpetas y haremos a cada usuario o grupo sus respectivos dueños :\nVamos a asegurarnos de que hemos aplicado correctamente estos cambios :\nVamos a comprobar que podemos acceder a los recursos compartidos desde el usuario oliver , accederemos a la carpeta Oliver y a crear un directorio dentro :\n8. Desde Windows acceder a estas carpetas a través de unidades de red. Desde el explorador de archivos podremos ver todos los recursos compartidos en la red .Ahora vamos a crear unidades de red, así que por ejemplo vamos a añadir la carpeta Oliver al usuario Oliver como unidad de red, para esto , hacemos clic derecho en la carpeta \u0026gt; conectar a unidad de red :\nY seleccionaremos una letra para asignarle a la unidad de red :\nAhora esta unidad nos aparecerá en este equipo :\nPerfiles móviles 9. Definir perfiles móviles en el servidor Linux mediante Samba, de forma que los usuarios se puedan autentificar en diferentes máquinas Windows, manteniendo su configuración. Para realizar esto vamos a instalarlos RSAT (Remote Server Administration Tools) que nos permitirá administrar nuestro controlador de dominio samba de forma idéntica a windows server . Para añadirlas buscaremos en la búsqueda de Windows *Añadir características opcionales una vez aquí le daremos a añadir característica :\nUna vez aquí buscaremos las siguientes características con RSAT y las instalaremos :\nUna vez instaladas se nos creará una aplicación similar a la de un Windows server llamada herramientas administrativas :\nSe nos abrirá una carpeta con las herramientas de administración :\nY buscaremos administración de usuarios y equipos de active directory o escribimos en ejecutar dsa.msc , esto lo haremos con el usuario administrador de nuestro dominio para poder acceder a esta:\nAntes de crear nuestro usuario móvil crearemos un recurso de red al igual que hemos hecho anteriormente llamado perfiles y le daremos permisos al grupo móviles para que estos puedan escribir en ellos :\nPara que nuestro usuario pueda escribir en este directorio lo añadiremos al grupo :\nAhora nos vamos a la configuración de nuestro usuario y le cambiamos la ruta del perfil . Pondremos la ruta de nuestra carpeta compartida perfiles seguida de %username% :\nGuardamos y ya tendríamos hecho nuestro perfil móvil creado .\nVamos a demostrar el funcionamiento del perfil móvil , para ello le he cambiado el fondo y he creado dos carpetas :\nAhora vamos a cerrar sesión e iniciarla en el Windows de la derecha :\nVemos que se ha realizado correctamente el perfil móvil .\nNFS 10. Mediante NFS, se compartirán en el servidor las carpetas: proyectos, documentación, programas_y_drivers. De la primera solo se podrá leer; en las dos últimas también se podrá escribir. Los equipos Linux montarán las carpetas automáticamente en el arranque. Lo primero que haremos será instalarnos los siguientes paquetes :\nAhora crearemos en la raíz los directorios que vamos a compartir :\nY le cambiaremos el propietario y los permisos a estos directorios :\nDespués de esto, debemos editar el archivo /etc/exports. Este es el archivo donde se indican a NFS las carpetas que vamos a compartir . La primera será solo de lectura y las dos últimas se podrán escribir :\nPara poder acceder a estos recursos en el servidor vamos a instalarlos los siguientes paquetes :\nAhora vamos a crear los directorios donde montaremos nuestras carpetas :\nPara montarlas manualmente en Linux haremos el siguiente comando :\nVamos a comprobar que en proyectos no podremos escribir :\nMientras que en las otras dos si podremos escribir :\nSi queremos acceder a estos recursos en Windows \u0026ndash;\u0026gt; \\192.168.0.1\\documentacion\n\\192.168.0.1\\proyectos (directorio de solo lectura)\n\\192.168.0.1\\programas_y_drivers\nPara poder visualizarlos será necesario tener instalados las siguientes características en Windows (Podemos acceder a este programa a través del buscador de Windows escribiendo características de Windows)\nPara finalizar con este punto vamos a configurar que los equipos Linux monten automáticamente al arrancar los directorios . Editaremos el fichero /etc/fstab añadiendo las siguientes líneas :\nUna vez hecho esto reiniciamos y veremos que se nos habrán montado automáticamente:\nCuotas 11. La carpeta /home del servidor tendrá un sistema de cuotas para evitar la saturación con archivos de los usuarios (100 MB por usuario). Lo primero que haremos será instalar los paquetes para implementar cuotas :\nAhora permitiremos las cuotas en la partición /home añadiendo esto al fstab de nuestro servidor :\nRemontamos la partición home para que se apliquen estos cambios :\nY aplicamos cuotas en la partición /home\nComprobaremos que en la raíz de la partición se nos ha creado dos archivos (aquota.group y aquota.user):\nAhora le aplicaremos la cuota de 100Mb a oliver usando edquota :\nAhora usaremos una herramienta la cual es gawk, el cual nos permitirá concatenándolo con este comando, aplicarle la cuota que le acabamos de crear a Oliver a todos nuestros usuarios :\nLa orden que acabamos de lanzar ha extraído una lista de todos los usuarios y ha aplicado la cuota de Oliver a todos usuarios con un UID mayor a 499 .\nAhora revisaremos las cuotas para ver como han quedado :\nPara comprobar que funciona vamos a agotar la cuota del usuario proferaul , para ello crearemos un archivo de 30 MB :\nAhora lo moveremos al directorio home de él y le haremos propietario del archivo :\nVemos que se actualiza el espacio usado en el directorio del usuario :\nWebmin 12. Instala Webmin en el servidor para tener la posibilidad de gestionarlo gráficamente desde un cliente. Demuestra alguna de sus funcionalidades. Webmin es un panel de control web moderno que le permite administrar su servidor Linux a través de una interfaz basada en navegador.\nNecesitaremos instalar apache para poder instalar webmin en nuestro servidor :\nAhora deberemos de añadir el repositorio de webmin , así que editaremos el sources.list y lo añadiremos :\nGuardamos el archivo y haremos un apt update para actualizar los repositorios , nos saldrá un error advirtiéndonos de que el repositorio no es fiable .\nAsí que ahora descargaremos la clave PGP de Webmin y la añadiremos a nuestro sistema :\nVolvemos a hacer un apt update y veremos que ahora el repositorio es fiable\nA continuación descargaremos el paquete webmin :\nLas últimas líneas de la instalación nos dará los datos para acceder vía web a este servicio :\nAsí que en un cliente vamos al navegador y accedemos a esta url :\nNos dirá que la conexión no es privada , para saltarnos esta advertencia Configuración avanzada \u0026gt; acceder\nTendremos un portal donde deberemos entrar con un usuario administrador de nuestro servidor :\nLo primero que veremos en la interfaz web será un monitor de recursos, así como datos de nuestro equipo :\nPodremos ver un histórico del monitor de recursos, el cual nos mostrara las horas y el porcentaje de uso de nuestro hardware, así como información del sistema :\nTenemos más apartados como el de logins recientes o interfaces de red , el cual nos dará información de quien se ha conectado y las configuraciones de las mismas respectivamente :\nPara finalizar con el panel tendremos una última ventana la cual nos dirá el uso del disco y particiones :\nUna vez que hemos echado un vistazo a la página principal vamos a aprovechar una funcionalidad que tiene que nos permite ver los directorios compartidos por nfs , para acceder aquí vamos a networking \u0026gt; NFS exports :\nVamos, que además nos permite editar los directorios compartidos actuales, así como añadir o eliminar estos .\nAdemás, esta herramienta nos permite configurar un Firewall con iptables , lo cual hoy día es de vital importancia disponer de seguridad en nuestra red :\nIncluso dispone de una terminal web para que podamos administrar el servidor desde un cliente , para acceder a esta desplegamos el menú y pulsamos sobre el símbolo de terminal o pulsamos Alt + K :\nVemos que usara ssh con el usuario conectado en la aplicación , en mi caso javiercruces :\nWebmin incluye muchas más funciones de administración que nos ayuda a trabajar con el servidor de forma gráfica para hacer más ameno la administración del mismo ,desde actualizar paquetes hasta configurar un Firewall . Además, usa https, por lo que nuestro tráfico viajara cifrado , lo que nos permitiría configurar nat para poder acceder desde un dispositivo que este fuera de nuestra red , sin que un snifer pueda descifrar nuestro trafico fácilmente. Es aconsejable que cambiemos el certificado auto-firmado que usa webmin por uno propio que podemos generar con Let`s encrypt, por ejemplo .\nCUPS 13. Habrá un servidor de impresión CUPS, que se administrará desde un cliente Ubuntu. Lo primero que deberemos de hacer es instalar en el servidor cups : Una vez hecho esto vamos a configurar el servicio para permitir ser administrado desde nuestro cliente Ubuntu , para ello editamos el siguiente fichero :\nAhora añadiremos los siguientes parámetros :\nListen 192.168.0.1:631 allow 192.168.0.0/24 Para permitir que nuestro cliente Ubuntu sea capaz de administrar el servicio\nAhora solo nos quedaría reiniciar el servicio :\nNos desplazaremos al cliente y en el navegador introduciremos la ip de nuestro servidor seguido de dos puntos y 631 :\nCon esto hemos comprobado que el cliente puede administrar cups .\n14. Configura una impresora en red para todos los usuarios, con límites de páginas diarias para todos los usuarios. Para compartir nuestra impresora en red , accedemos al panel web y en el apartado de administración marcamos compartir impresoras conectadas a este sistema :\nAntes de establecer los límites vamos a habilitar que el servicio registre el nombre de los usuarios al mandar archivos , para ello en el fichero cupsd.conf cambiamos este valor de default a none :\nAhora reiniciaremos el servicio :\nPara establecer un límite diario para cada usuarios de 20 páginas por ejemplo , aplicaríamos el siguiente comando para nuestra impresora .\nUna vez aplicado este comando los usuarios solo podrán imprimir el número indicado de páginas ,cuando supere el límite los trabajos se mandaran a cups , pero este los desechara de la cola y no los imprimirá :\nEs decir, el trabajo 21 en este ejemplo no se creará hasta qué pasen 24 horas .\nBibliografía Como saber que escritorio tengo Montar controlador de dominio samba Configurar la red con netplan Unir cliente linux a dominio parte 1 Unir cliente linux a dominio parte 2 Administrar dominio con RSAT Acceder carpetas compartidas w10 Cuotas Instalación y uso de webmin Comandos CUPS ","date":"September 20, 2023","hero":"/images/sistemas/ad_ubuntu/portada.jpeg","permalink":"https://www.javiercd.es/posts/sistemas/ad_ubuntu/ad_ubuntu/","summary":"En este post, exploraremos cómo configurar un entorno de Active Directory en un servidor Ubuntu utilizando herramientas como Kerberos y Samba. Active Directory es una solución integral de Microsoft para la gestión de identidades y el control de acceso en redes empresariales. A través de esta guía, aprenderemos paso a paso cómo implementar un servidor Ubuntu como controlador de dominio, establecer la autenticación basada en Kerberos y configurar servicios de directorio mediante Samba.","tags":["Debian 12","Sistemas","ISO","ASO"],"title":"Active Directory en Ubuntu"},{"categories":null,"contents":"\rLa gestión eficiente de tareas programadas es esencial para los administradores de sistemas, ya que facilita la ejecución automática de procesos rutinarios. En este contexto, contar con un conjunto sólido de comandos en Linux para programar y controlar tareas se convierte en una herramienta fundamental.\nComando sleep El comando sleep pausa la ejecución en la terminal durante un intervalo de tiempo especificado antes de regresar a la línea de comandos. Puedes indicar el tiempo en segundos, minutos, horas o días. Este comando se encuentra en el paquete coreutils.\ns : segundos m : minutos h : horas d : días Ej: sleep 10m –\u0026gt; esperar 10 min\nPor si solo no tiene ninguna utilidad , sin embargo es muy útil en Scripts . Aquí un pequeño ejemplo :\ndate +\u0026quot;%H:%M:%S\u0026quot;;sleep 5;date +\u0026quot;%H:%M:%S\u0026quot;\nComando watch La utilidad watch es parte del paquete procps (o procps-ng) que está preinstalado en casi todas las distribuciones Gnu/Linux.\nCuando se usa sin argumentos, esta utilidad ejecutará el comando especificado cada dos segundos:\nPodemos especificar el tiempo de repetición utilizando el parámetro -n , especificando el parámetro en segundos :\nwatch -n 5 date –\u0026gt; Cada 5 segundos\nSi queremos eliminar el encabezado , es decir que nos muestre cada cuanto tiempo se repite , utilizamos el parámetro -t :\nSi queremos poner un mensaje de error en caso de que el comando no pueda ejecutarse utilizamos el parámetro -e seguido del mensaje de error :\nwatch -e ‘error’\nLa opción -b de watch emite un pitido cada vez que el comando sale con un código de estado distinto de cero.\nwatch -b\nCon el parámetro -d nos señala los cambios que han ocurrido en la ejecución del comando : watch -d\nComando at Este comando se usa para ejecutar comandos a una determinada hora , principalmente se usa para programar tareas periódicas como puedes ser , copias de seguridad .\nLos principales parámetros son :\nV :imprime el número de versión en el error estándar y sale con éxito.\nm :Enviar correo al usuario cuando el trabajo haya finalizado aunque no haya habido salida. -M: Nunca envía correo al usuario.\nf :archivo Lee el trabajo desde un archivo en lugar de la entrada estándar.\nt :time Ejecuta el trabajo a la hora, dada en el formato [[CC]YY]MMDDhhmm[.ss]\nl :Es un alias para atq.\nr :Es un alias para atrm.\nd: Es un alias para atrm.\nb: Es un alias para batch.\nv: Muestra el tiempo que se ejecutará el trabajo antes de leerlo.\nLos tiempos mostrados estarán en el formato \u0026ldquo;Thu Feb 20 14:50:00 1997\u0026rdquo;.\nc recoge los trabajos listados en la línea de comandos en la salida estándar.\nPodemos programar tareas desde la linea de comandos , con echo :\necho \u0026ldquo;sh copia-seguridad.sh\u0026rdquo; | at 10:00 PM\nHa esta tarea se le asignara un numero automáticamente , para listar las tareas que tenemos invocamos el comando at sin ningún parámetro\nSi queremos borrar una tarea programada , utilizamos el parámetro -c seguido con el numero de la tarea a eliminar .\nAlgunos ejemplos para programar tareas son :\nDentro de 30 min : at now + 30 minutes 11AM del próximo 14 abril : at 11:00 AM April 14 Comando crontab El comando crontab se utiliza en sistemas UNIX para programar la ejecución de otros comandos, es decir, para automatizar tareas. Podemos ver los crontabs que se están programados y también editarlos, lógicamente.\nPara verlos, utilizamos este comando: sudo crontab -l Para editarlos: sudo crontab -e\nLas tareas cron siguen una determinada sintaxis. Tienen 5 asteriscos seguidos del comando a ejecutar. Ahora explicaré para qué sirve cada cosa.\n* * * * * /bin/ejecutar/script.sh\nLos 5 asteriscos , de izquierda a derecha, los asteriscos representan:\nMinutos: de 0 a 59. Horas: de 0 a 23. Día del mes: de 1 a 31. Mes: de 1 a 12. Día de la semana: de 0 a 6, siendo 0 el domingo. Si se deja un asterisco, quiere decir \u0026ldquo;cada\u0026rdquo; minuto, hora, día de mes, mes o día de la semana.\nSi queremos que un archivo se ejecute a las 5 de la mañana todos los días : 0 5 * * * ruta_absoluta_del_script\nPara que se ejecute dos veces al día a las 6 AM Y a las 6 PM: 0 6,18 * * * ruta_absoluta_del_script\nMuchas veces tenemos palabras reservadas para facilitar el uso de programas o lenguajes de programación. Cron no podía ser menos, así que tenemos algunas que suelen ser las más comunes. Ya cada uno que lo configure conforme a sus necesidades. Aquí van:\n@reboot: se ejecuta una única vez al inicio. @yearly/@annually: ejecutar cada año. @monthly: ejecutar una vez al mes. @weekly: una vez a la semana. @daily/@midnight: una vez al día. @hourly: cada hora. También debemos conocer los usos de los parámetros :\ncrontab archivo.cron (establecerá el archivo.cron como el crontab del usuario)\ncrontab -e (abrirá el editor preestablecido donde se podrá crear o editar el archivo crontab) crontab -l (lista el crontab actual del usuario, sus tareas de cron)\ncrontab -r (elimina el crontab actual del usuario)\nCuando hagamos algún cambio deberemos de reiniciar el servicio para asegurarnos de que nuestros cambios surtan efecto :\nservice crond restart\nEstos comandos nos dará la posibilidad de automatizar procesos , haciendo mas cómoda y amena la administración de nuestros sistemas .\nBibliografía Comando watch Comando crontab ","date":"September 20, 2023","hero":"/images/sistemas/programacion_tareas/portada.png","permalink":"https://www.javiercd.es/posts/sistemas/programacion_tareas/programacion_tareas/","summary":"La gestión eficiente de tareas programadas es esencial para los administradores de sistemas, ya que facilita la ejecución automática de procesos rutinarios. En este contexto, contar con un conjunto sólido de comandos en Linux para programar y controlar tareas se convierte en una herramienta fundamental.\nComando sleep El comando sleep pausa la ejecución en la terminal durante un intervalo de tiempo especificado antes de regresar a la línea de comandos.","tags":["Debian 12","Sistemas","ISO","ASO"],"title":"Comandos programación de tareas en Linux"},{"categories":null,"contents":"\rSamba es una implementación libre y de código abierto del protocolo Server Message Block (SMB), que se utiliza para compartir archivos e impresoras en redes de computadoras. El protocolo SMB es un protocolo de red que permite que los sistemas operativos Windows se comuniquen con otros dispositivos de red, como servidores de archivos, impresoras y otros recursos compartidos.\nSamba facilita la interoperabilidad entre sistemas Windows y sistemas operativos basados en Unix/Linux al permitir que los sistemas Unix compartan archivos y recursos con sistemas Windows utilizando el protocolo SMB/CIFS. Esto significa que un servidor Samba puede actuar como un servidor de archivos para clientes Windows, permitiéndoles acceder y compartir archivos como si estuvieran en un entorno Windows.\n1.Instalación Lo primero sera instalarnos el servidor samba :\nEn el fichero /etc/samba/smb.conf realizaremos la configuración de nuestra carpeta :\nNos crearemos un usuario de samba para poder acceder a los recursos :\nReiniciaremos el servicio para que se aplique la configuración :\n2.Acceso desde Windows Ahora podemos acceder desde un cliente Windows con el usuario que acabamos de crear -–\u0026gt; \\IP\\DIRECTORIO\\COMPARTIDO\nNos pedirá que nos autentiquemos :\nPodremos ver el contenido y crear :\n3.Acceso desde Linux Nos instalamos el paquete smbclient para poder conectarnos a unidades compartidas con samba:\nListar los directorios compartidos :\nNos conectamos al recurso compartido\nCreare un directorio y comprobare que existe :\nBibliografía -Habilitar el acceso de invitado\n","date":"September 20, 2023","hero":"/images/sistemas/samba_debian/portada.png","permalink":"https://www.javiercd.es/posts/sistemas/samba_debian/samba_debian/","summary":"Samba es una implementación libre y de código abierto del protocolo Server Message Block (SMB), que se utiliza para compartir archivos e impresoras en redes de computadoras. El protocolo SMB es un protocolo de red que permite que los sistemas operativos Windows se comuniquen con otros dispositivos de red, como servidores de archivos, impresoras y otros recursos compartidos.\nSamba facilita la interoperabilidad entre sistemas Windows y sistemas operativos basados en Unix/Linux al permitir que los sistemas Unix compartan archivos y recursos con sistemas Windows utilizando el protocolo SMB/CIFS.","tags":["Debian 12","Sistemas","ISO","ASO"],"title":"Instalar y configurar samba en Debian"},{"categories":null,"contents":"\rDocumento en el cual se detallan los principales comandos a la hora de detectar incidencias en redes y lograr solucionarlos .\nComandos en Windows Explica el significado de los distintos parámetros a configurar en las Propiedades de TCP/IP en Windows Tenemos que tener en cuenta que cada configuración que hagamos es independiente para cada uno de nuestros adaptadores de red .\nPara acceder a configurar estos parámetros seguiremos la siguiente ruta en nuestro sistema :\nPanel de control \u0026gt;Redes e Internet \u0026gt; Centro de redes y recursos compartidos \u0026gt; Cambiar configuración del adaptador :\nUna vez aquí le daremos Clic derecho \u0026gt; Propiedades \u0026gt; Protocolo de version 4 (TCP/IP)\nUna vez aquí veremos dos pestañas a la cual podemos dirigirnos para configurar nuestra tarjeta , en la pestaña general podemos observar los siguiente apartados :\nEl primer apartado (General) relacionado con nuestra dirección ip :\nObtener una dirección ip automáticamente : Marcaremos esta opción cuando queramos que se use el servicio DHCP para asignar mediante el servicio dirección IP , mascara de subred y la puerta de enlace predeterminada . Usar la siguiente dirección IP : Aquí introduciremos nosotros manualmente la configuración de red deseada : Dirección IP: es una etiqueta numérica que identifica a nuestra maquina de manera única en nuestra red , no puede estar repetida . Mascara de subred : conjunto numérico cuya función es indicar a los dispositivos qué parte de la dirección IP es el número de la red incluyendo la subred, y qué parte es la correspondiente al host. Puerta de enlace predeterminada : Es la dirección ip predeterminada que se le asigna a un equipo para enviar los paquetes a otras redes . En el segundo apartado de esta pestaña realizaremos la configuración referente a los servidores DNS los cuales permitirán traducirnos nombres a direcciones IP para poder navegar .\nObtener la dirección del servidor DNS automáticamente : Esta opción hará que la dirección se obtenga del servidor DHCP que tengamos configurado en nuestra red . Usar la siguientes direcciones del servidor DNS : Esta opción nos sirve para manualmente seleccionar la dirección ip de nuestros servidores DNS: Servidor DNS preferido : La dirección que pongamos aquí sera la primera en consultar en caso de que necesite hacer una resolución Servidor DNS alternativo : Si el servidor primario fallase o estuviera caído en ese momento pasaríamos a utilizar el secundario . En la pestaña configuración alternativa , esta pensado para equipos que necesiten usarse en mas de una red , suele verse en entornos profesionales :\nDirección ip privada automática : Hará uso del servidor DHCP para configurarse . Configurada por el usuario : Nos permitirá introducirla manualmente la configuración (omitiré los campos explicados anteriormente ) : WINS preferido : es un servidor de nombres de Microsoft para NetBIOS, que mantiene una tabla con la correspondencia entre direcciones IP y nombres NetBIOS de ordenadores . WINS alternativo : Si el servidor primario fallase o estuviera caído en ese momento pasaríamos a utilizar el secundario . Utilidad del comando ping Ping es un comando o una herramienta de diagnóstico que permite hacer una verificación del estado de una determinada conexión de un host local con al menos un equipo remoto contemplado en una red de tipo TCP/IP , es la herramienta de diagnostico de redes mas conocida .\nLos usos mas comunes de esta herramienta son :\nComprobar la conectividad de una red. Medir la latencia que tardan en comunicarse dos puntos . Conocer la dirección IP utilizada por un nombre de dominio. Scripts que permiten llevar un registro de la disponibilidad de un servidor remoto. Scripts que permiten conocer cuando existe conexión en un equipo. Para hacer uso de este abriremos una cmd , pulsaremos WIN + R y escribiremos cmd .\nUso general de Ping La sintaxis mas simple de ping es la siguiente : ping [Parámetros] [IP/Nombre]\nSi nos fijamos en la salida del comando vemos que nos permite conoces :\nDirección IP que corresponde al nombre de la máquina remota. El número de secuencia ICMP (“Código que nos devuelve , ej : 0=red inaccesible”). TTL: Tiempo de vida en segundos; como este valor se decrementa en cada máquina en la cual es procesado, debe ser al menos igual o mayor que el número de saltos que dará .Si alguna vez este número es cero, el router interpretará que el paquete está viajando en círculos, por lo tanto, finaliza el proceso. **Latencia :**corresponde al lapso de tiempo en milisegundos que se necesita para dar una vuelta entre las máquinas fuente y destino. Como regla general, la demora de un paquete no debe ser mayor a 200 ms. Estadísticas del ping : Nos reúne toda la información mostrándonos los paquetes perdidos , enviados y recibidos . Además nos muestra el paquete con menor latencia y con mayor así como una media aritmética . PING -T Este parámetro nos permitirá hacer un ping infinito es decir no finalizara hasta que matemos el proceso , si no lo pusiésemos por defecto solo se enviaran 4 trazas . Para finalizar este la ejecución de este comando pulsaremos CTRL + C .\nCuando detengamos la ejecución nos mostrara las estadísticas que ha recopilado , paquetes enviados, paquetes recibidos y paquetes perdidos así como los tiempos medios de ida y vuelta .\nPING -A Este parámetro sirve para que nos resuelva una ip en un nombre de host ,imprimiendo una linea indicando el nombre de host al cual le estamos dirigiendo las trazas , lo que nos permite identificar mas fácilmente las maquinas :\nPING -N Este parámetro sirve para especificar el numero de solicitudes echo que deseemos al enviar paquetes , este lo indicaremos con un numero comprendido entre 1 – 4294967295 .\nPor ejemplo si queremos enviar 10 trazas el comando seria el siguiente :\nPodemos comprobar en la parte inferior que ha enviado en numero que le hemos indicado .\nPING -L Nos permite modificar el tamaño en bytes de los paquetes enviados , deberemos especificar un numero entre 0 y 65000 .\nPING -F Este parámetro sirve para evitar que los paquetes se fragmenten , el tamaño máximo de los paquetes sin fragmentar es de 1472 bytes .\nPodemos ver que si superamos este numero , nos dará un error informándonos que es necesario fragmentar el paquete :\nPING -I Este parámetro nos permite especificar el numero máximo que se pueden dar hasta alcanzar al destino , el valor máximo que podemos introducir 255 .\nCuando especificamos un TTL esto fija el número máximo de saltos, al pasar por un nuevo dispositivo (un router) este descuenta 1 al TTL especificando hasta que llega a 0, en este caso el destino se mostrará como inalcanzable, de esta forma se evita que un paquete viaje por la red indefinidamente buscando un destino que puede que no exista.\nPING -4 -6 Ping -4 : Fuerza la respuesta del host especificado con una dirección IPv4. Es necesario que tanto el equipo que lanza el ping como el destino tengan una configuración IPv4 correcta.\nPing -6 : Fuerza la respuesta del host especificado con una dirección IPv6. Es necesario que tanto el equipo que lanza el ping como el destino tengan una configuración IPv6 correcta.\nComprobar conectividad en una red Vamos a efectuar una serie de pruebas para verificar el funcionamiento y encontrar errores . Lo primero sera hacernos ping a nosotros mismos para ello :\nSi la salida es correcta esto demuestra que nuestro adaptador de red funciona correctamente .\nVamos a hacerle ping a una maquina de nuestra red local , así demostraremos que las conexiones físicas son correctas :\nVamos a hacerle ping a la puerta de enlace , de tener éxito demuestra que existe conexión con el equipo que suministra internet :\nHaremos ping a un sitio de internet usando ip , para comprobar que tenemos conexión a internet :\nPor ultimo hacer ping a un dominio en internet ,de tener éxito demuestra que existe conexión a internet y los servidores DNS configurados en la conexión funcionan correctamente:\nUso general del comando ipconfig Este comando se usa para ver la configuración actual de los adaptadores de red de nuestro equipo , un ejemplo de uso general del comando es el siguiente :\nEste nos muestra la siguiente información :\nDescripción del adaptador : Nombre del adaptador o tarjeta de red utilizado en la conexión. Dirección IPV4: Es la dirección IP asignada al equipo en la red local. Puerta de enlace predeterminada: Es la dirección IP del equipo proporciona acceso a internet. Servidores DNS: Dirección ip del encargado de resolver nombre de dominio a dirección IP de las paginas solicitadas. Generalmente son dos, el principal y el secundario. Estado de DHCP: Configuración dinámica de host, en el caso del equipo mostrado se encuentra habilitada, eso significa que siempre se utilizará una dirección IP asignada por este servicio . A partir de estos parámetros podemos consultar la información del adaptador o identificar una incoherencia en la configuración del mismo .\nIPCONFIG /ALL Nos devolverá toda la información disponible de los adaptadores de red , es una salida mas detallada que si omitimos este parámetro , con este podemos consultar los servidores DNS y las direcciones MAC .\nIPCONFIG /RELEASE Se utiliza para liberar una dirección ip en el servicio DHCP , no se nos volverá a asignar una hasta que ejecutemos ipconfig /renew\nPodemos especificar el adaptador del cual queremos que se libere la ip escribiéndolo a continuación, si omitimos el nombre los aplicara a todos .\nEJ: ipconfig /release Ethernet0 –\u0026gt; Solo liberara la ip del adaptador Ethernet0 *****Si queremos liberar una dirección ipv6 utilizaremos el parámetro /release6\nIPCONFIG /RENEW Una vez ejecutado el comando anterior deberemos de ejecutar este para solicitar al servidor DHCP una nueva concesión de dirección IP .\nPodemos especificar el adaptador del cual queremos que se renueve la oferta DHCP escribiéndolo a continuación.\nEJ: ipconfig /renew Ethernet0 –\u0026gt; Solo renovara la concesión del adaptador Ethernet0 *****Si queremos renovar una dirección ipv6 utilizaremos el parámetro /renew6\nIPCONFIG /FLUSHDNS Se utiliza para vaciar la cache de resolución DNS de nuestro equipo local , suele utilizarse cuando queremos comprobar el correcto funcionamiento del servidor DNS .\nIPCONFIG /REGISTERDNS Actualiza todas las concesiones DHCP y vuelve a registrar los nombres DNS. Este comando esta orientado al trabajo en entornos de dominio y a la actualización de los registros dinámicos del servidor de DNS del sistema en el que se esta ejecutando, teniendo en cuenta que si esta bloqueada de alguna forma la actualización dinámica no se efectuará.\nIPCONFIG /DISPLAYDNS Este comando simplemente nos muestra las consultas DNS que se están almacenados en la caché de nuestro sistema de la forma que se muestran en la imagen, muestran datos de registros del protocolo IPv4 como de IPv6.\nIPCONFIG /SHOWCLASSID Este comando nos permite comprobar las clases de usuario configuradas en nuestro servidor DHCP y que estarán disponibles para los diferentes clientes.\n*Si queremos comprobarlo para IPV6 utilizaremos el parámetro /showclassid6 .\nUso general ARP El comando arp muestra y modifica las tablas de conversión de direcciones IP en direcciones\nMAC que utiliza el protocolo de resolución de direcciones (ARP).\nARP -A Pide los datos de protocolo actuales y muestra las entradas ARP actuales. Si se especifica inet_addr, solo se muestran las direcciones IP y física del equipo especificado. Si existe más de una interfaz de red que utilice ARP, se muestran las entradas de cada tabla ARP.\n* La opción -g hace la misma función :\nComo se muestra en la captura de pantalla el comando arp –a enumera todos los dispositivos que se encuentran actualmente en la caché ARP del host, lo cual incluye la dirección IPv4, la dirección física y el tipo de direccionamiento (estático/dinámico) para cada dispositivo.\nSi queremos borrar la cache arp utilizaremos la opción -d seguida del comodín * para borrar todas las entradas en esta tabla , si solo quisiéramos eliminar una consulta pondríamos la dirección IP .\nPodemos solicitar la MAC de una dirección usando arp + IP del dispositivo y posteriormente verla en nuestra tabla con arp -a .\nUso general netstat El comando netstat genera visualizaciones que muestran el estado de la red y estadísticas de protocolo. El estado de los protocolos TCP, SCTP y los puntos finales de UDP puede visualizarse en formato de tabla. También puede visualizarse información sobre la tabla de enrutamiento e información de interfaces.\nNETSTAT -A Muestra las todas conexiones y puertos de escucha de nuestro equipo , así como el estado del puerto y la dirección remota la cual esta usando el mismo :\nNETSTAT -B Muestra el archivo ejecutable implicado en la creación de cada conexión o puerto de escucha.\nNETSTAT -E Nos muestra estadísticas sobre las interfaces de red , sirve para ver la actividad que ha tenido esta:\nNETSTAT -R Nos muestra la tabla de enrutamiento , así podemos ver los sitios a los cual nuestro equipo es capaz de llegar a través de la red :\nNETSTAT -N Nos muestra las conexiones activas con un formato de tabla , similar al parámetro -a solo que este nos indica el numero de puerto en lugar del nombre .\nNETSTAT -O Similar al parámetro anterior pero este nos añade el PID del proceso :\nNETSTAT -P Nos permite filtrar las conexiones según el protocolo (TCP, UDP, tcpv6 o tcpv4…)\nNETSTAT -T Muestra el estado de descarga de la conexión actual :\nNetstat es muy interesante para ver datos estadísticos de la conexión, pero también va a ser muy útil para analizar los puertos abiertos en un momento determinado y así identificar problemas. Es esencial para determinadas aplicaciones y poder lograr un rendimiento óptimo .\nUso general nslookup Es una aplicación incluida en todos los sistemas Windows, para consultar, obtener información, probar y solucionar problemas con los servidores DNS .\nAl invocarlo sin especificar ningún parámetro, devolverá el nombre del servidor DNS predeterminado y su dirección IP :\nEl comando dispone de dos modos de uso , el tradicional a través de linea de comandos y el interactivo . Podemos usarlo para resolver nombres de direcciones desde la terminal poniendo nslookup seguido del nombre que queramos resolver :\nTambién podemos hacer consultas inversas , es decir que a través de la ip nos diga el nombre :\nPor ejemplo podemos seleccionar el tipo de registros DNS para hacer peticiones los cuales son :\nA: para buscar registros A que son los relacionados con la dirección IPv4.. AAAA: para buscar registros AAAA que son los relacionados con la dirección IPv6. Si una web utiliza direccionamiento IPv6 y nosotros también, entonces tendremos que indicar este registro DNS. PTR: para buscar registros reversos. MX :para buscar los registros Mail Exchange del correo. TXT:, para buscar registros de texto como SPF o DKIM. CNAME: para buscar alias del dominio, esto también se conoce como subdominios, por ejemplo, el «www» siempre es un subdominio del principal» o el típico «ftp.» que es también un subdominio. Para cambiar el tipo de registro utilizamos la orden set type=Nombre del registro , por ejemplo :\nTambién podemos elegir el servidor desde el cual realizamos las consultas de la siguiente manera :\nUso general tracert Sirve para trazar la ruta que hace un paquete entrante que viene desde un host o punto de red hasta tu ordenador , así conocemos por donde viaja nuestro viaje .\nDiciendo uno a uno todos los nodos y routers por los que pasa el mensaje de prueba que has enviado, sus direcciones IP y la latencia de cada uno de ellos hasta llegar a su destino.\nHay algunos nodos que no son capaces de respondernos por eso las entradas de tiempo de espera agotado .\nTenemos algunos parámetros interesantes como :\n-d : No convierte direcciones en nombres de host -h : Nos permite seleccionar el numero máximos de saltos -4 o -6 : Fuerza usar IPV4 o IPV6 : -w : Nos permite especificar el tiempo de espera en milisegundos : Uso general route print El comando Route se utiliza para visualizar y modificar la tabla de enrutamiento. Route print muestra una lista con las rutas actuales conocidas por IP para el host. Route add se utiliza para añadir rutas a la tabla, y route delete se utiliza para borrar rutas de la tabla.\nAsí podemos especificar el camino para llegar a una red o dispositivo .\nLa sintaxis es la siguiente : route [-f] [-p] [comando [destino]] [MASK máscara de red]\nComando route print sin parámetros para mostrar todo el contenido de la tabla de enrutamiento :\nSi deseamos borrar la tabla de enrutamiento deberemos de utilizar el parámetro -f :\nAdemás podemos añadir , rutas manuales de la siguiente manera :\n→ route add IP_Destino Mascara_Destino Puerta_de_enlace métrica interfaz\nSi queremos cambiar una ruta , la sintaxis es la misma que el comando anterior cambiando la orden add por change :\nCuando solo queramos eliminar una ruta , utilizaremos la orden delete seguida del destino :\n¿Cómo puedes averiguar la IP pública de tu router? Hay muchas forma de saber esto desde Windows , podemos utilizar el comando curl para pedir la siguiente web y que nos devuelva la ip :\nOtra forma desde la linea de comandos es hacer una consulta dns con nslookup al servicio opendns :\nSi tenemos un navegador podemos usar una de las muchas webs que nos dicen la dirección ip publica del router , yo uso la siguiente https://ipchicken.com/ :\nLinux Configurar una interfaz de red Para configurar una tarjeta de red en Linux podemos hacerlo desde la interfaz gráfica o desde linea de comandos .\nDesde interfaz gráfica nos dirigimos a Configuración \u0026gt; Inalámbrica o Red . Una vez aquí encenderemos la tarjeta y le daremos al engranaje .\nUna vez aquí podemos configurar manualmente la configuración de red de nuestra tarjeta .\nEsto mismo podremos hacerlo desde la linea de comandos editando el fichero /etc/network/interfaces con permisos de superusuario .\nDentro de este podemos indicar la configuración de nuestros adaptadores de red , aquí te indico con lineas comentadas los parámetros básicos que podemos indicar en este archivo .\nUna vez hayamos configurado nuestras interfaces los cambios no se aplicaran automáticamente , para hacer esto tenemos varias formas , la mas cómodas es reiniciar el servicio :\nOtra forma de cambiar los servidores DNS que se utilizan es a través del fichero /etc/resolf.conf\nAquí seguido de nameserver pondremos la dirección ip o nombre de nuestro servidor DNS\nUso general ifconfig Explica la utilidad del comando ifconfig a partir de una captura real. ¿Hay alguna información de las que se obtiene con ipconfig /all que no aparezca? Trata de conseguirla de otra forma.\nEs similar a ifconfig y esta enfocado a las mismas funciones , este comando también se utiliza para ver, cambiar y administrar todas las configuraciones actuales de la red informática.\nEsta se instala con el paquete net-tools , para instalarlo:\nPara utilizar esta herramienta necesitaremos hacerlo como superusuario , con su uso mas simple nos mostrara la configuración básica TCP/IP de nuestra tarjeta de red así como unas estadísticas de la misma :\nPor ejemplo con ipconfig /all podemos ver los servidores DNS configurados cosa que con ifconfig no podremos ver .\nAsí que tendremos que ver el fichero /etc/resolf.conf\nUn uso común de este comando es configurar rápidamente una interfaz de red , por ejemplo :\nEsto podemos ponerlo en una sola linea\nAdemás también podremos levantar y bajar la tarjeta de red\nUso general dhclient Este utiliza el protocolo de configuración dinámica de host para configurar dinámicamente los parámetros de red de la interfaz de red.\nEl siguiente comando indicará a dhclient que libere la concesión actual que tiene del servidor DHCP ,es decir que queremos liberar la ip actual . Utilizaremos los parámetros -r y -v\nSi queremos volver a pedir una configuración de red al comando dhcp utilizaremos solamente el parámetro -v .\nPrincipalmente este comando se usa para esto , para solucionar problemas con la configuración del servicio DHCP .\nAlgunos parámetros que no he mencionado y pueden resultar útil son :\n-6 : Sirve para indicar que quieres IPV6 -p: Sirve para indicar otro puerto para hacer la consulta -s : Sirve para indicar la dirección del servidor DHCP Diferencias de los comandos netstat y ping respecto a los empleados en Windows netstat muestra información sobre el subsistema de red en nuestro equipo al igual que Windows . Si nos fijamos en el manual nos indica que Esta aplicación está parcialmente obsoleta. El reemplazo de netstat es ss, para netstat -r tiene ip route, para netstat -i puede usar ip -s link y para netstat -g dispone de ip maddr.\nSi lanzamos el parámetro podemos ver a simple vista que nos muestra mas información sin indicar ningún parámetro , por lo demás estos son los mismo que en Windows .\nMientras que el comando ping la diferencia es que es por defecto infinito , a diferencia de Windows este no acabara hasta que lo detengamos nosotros .\nEn este los parámetros con respecto a Windows cambia su “letra ” , aquí serian :\n-i : Indicar el intervalo para enviar el siguiente paquete en segundos (por defecto es 1 ) -s : Cambiar el tamaño del paquete en bytes -f : inundación , para probar el rendimiento de la red bajo una carga pesada (envía una gran cantidad de paquetes lo más rápido posible) -c : Indicar el numero de trazas enviadas -w: Dejara de imprimir los resultados después de los segundos indicados -q: Elimina la salida del comando , opción silenciosa -a : hace un sonido cuando hay una respuesta -V indica la version del comando La utilidad de este sigue siendo la misma , solucionar problemas de accesibilidad de hosts en una red. Esto nos ayuda a comprender por qué un sitio web no se carga.\nUso general comando dig Dig es un comando que permite realizar consultas a servidores DNS para obtener información relacionada con este servicio. Para instalarlo en nuestro sistema , haremos un apt install dnsutils .\nPodemos hacer una consulta dns , por ejemplo al instituto para comprobar si somos capaces de obtener su dirección ip :\nUtilizando la opción +trace realiza consultas iterativas para resolver la búsqueda de nombres. Consultará los nombres de servidores a partir de la raíz y posteriormente atravesará el árbol del espacio de nombres mediante consultas iterativas siguiendo las referencias en el camino:\nTambién podemos realizar consultas inversas con la opción -x :\nDiferencias del comando traceroute de Linux con el comando tracert de Windows La herramienta traceroute es exactamente la misma que el tracert, pero se denomina de otra forma, aunque internamente puede hacer uso de diferentes protocolos, ya que en algunos sistemas operativos se hace uso del protocolo ICMP Echo Request/reply, y en otros de hace uso de mensajes UDP directamente para comprobar cuantos saltos hay de un host a otro .\nEstas se usan para detectar donde esta el error a la hora de acceder a un determinado equipo y saber en que nodo se produce el “error” .\nAlgunos parámetros que pueden interesarnos son :\n-f, :Establece la distancia entre el primer salto y el siguiente salto. -g,: nos permite indicar la puerta de enlace. -I : Usa ICMP ECHO -m, :Establece el número de saltos; el valor predeterminado es 64. -M, :las rutas de seguimiento se realizan con ICMP o UDP; el método predeterminado es UDP. -p: Define el puerto de red; el valor predeterminado es 33434. -q: Define el numero de paquetes por salto. –resolve-hostnames: puede usar esta sintaxis para corregir los nombres de host. -w, : Define el tiempo de espera en segundos. Uso general wget Wget es una herramienta informática creada por el Proyecto GNU. Puedes usarlo para recuperar contenido y archivos de varios servidores web. El nombre es una combinación de World Wide Web y la palabra get. Admite descargas a través de FTP, SFTP, HTTP y HTTPS.\nPara instalarlo usamos el comando apt install wget .\nUn ejemplo es para descargar archivos , por ejemplo una iso . Pondríamos el comando seguido de la url :\nEste nos descargara el archivo en el directorio actual de trabajo .\nPodemos utilizar el comando -o para indicar un nombre diferente al descargar el archivo :\nAlgunos parámetros interesantes son :\n-P : Indicar el directorio donde queremos guardar el archivos \u0026ndash;limit-rate : sirve para limitar la velocidad de descarga -tries : nos permite indicar el numero de reintentos de la descarga -b : Realizara la descarga en segundo plano -c para indicar que se reanude una descarga Si quisiéramos descargar archivos desde un servidor ftp utilizaríamos la siguiente sintaxis : wget –ftp-user=usuario\u0026ndash;ftp-password=contraseña\nUso general de tcpdump Tcpdump es una herramienta para línea de comandos cuya utilidad principal es analizar el tráfico que circula por la red. Permite al usuario capturar y mostrar en tiempo real los paquetes transmitidos y recibidos por la red a la cual el ordenador está conectado\nLos parámetros mas comunes son :\n-i Permite especificar la interfaz de red en la que vamos a atender el tráfico. -c Permite limitar la cantidad de paquetes capturados en un número determinado. -n Evita la resolución de puertos y direcciones ip a nombres. -e Muestra las cabeceras ethernet además del paquete ip. -t No imprime la estampa de tiempo de captura de cada paquete. -x Muestra el contenido hexadecimal de la trama capturada. -xx Idem a -x, pero además muestra el contenido de la cabecera Ethernet. -X Muestra el contenido hexadecimal y en ASCII de la trama capturada. -A Solo muesta el contenido ASCII del paquete capturado. -s Muestra solo los primeros bytes desde el principio del paquete. -vv Muestra información adicional, incluyendo parámetros de las cabeceras de protocolo. -w file Permite guardar la salida en un archivo con formato pcap. -r file Permite leer los paquetes previamente capturados y almacenados en un archivo pcap. Por ejemplo podemos hacer una captura de nuestra red de un máximo de 50 paquetes :\nComo ves la salida es indescifrable , para leerla usaremos el comando ngrep para buscar coincidencias sin tener en cuenta mayúsculas y minúsculas .\nUso general del comando arp El comando arp nos permitirá interactuar con la cache de resolución arp , modificándola por ejemplo .\nTambién podemos averiguar la dirección MAC de un dispositivo , buscándolo en la tabla :\nLos parámetros son los mismo que podemos encontrar en Windows :\n-a : Encontrar una determinada dirección en la tabla -v : Muestra todas las entradas -n : Muestra todas las entradas de forma numérica -d : elimina una resolución determinada También podemos hacer esto mismo con el comando ip :\nPara este la sintaxis básica es de la siguiente forma :\nadd : Añadir resolución del : Eliminar resolución change : Cambiar una resolución replace : Remplazar una resolución Por ejemplo para añadir una tabla :\nComando ip Podremos ver y configurar direcciones IP, ver y configurar tablas de enrutamiento, ver y configurar túneles IP, y también ver y configurar la interfaz física .\nEste se le añade un “segundo comando ” para indicar su funcion , son los siguientes :\nlink: nos sirve para configurar las interfaces de red físicas o lógicas, por ejemplo, para ver el estado de todas las interfaces de red. address: permite ver y configurar las direcciones IPv4 y IPv6 asociadas a las diferentes interfaces de red. Cada interfaz debe tener al menos, una dirección IP configurada. addrlabel: permite añadir una etiqueta neighbour: permite ver los enlaces de vecindad, es decir, se puede ver la tabla ARP del sistema operativo. rule: permite ver y configurar políticas de enrutado y cambiarlas, esto se utiliza sobre todo cuando vas a configurar varias tablas de enrutamiento. route: permite ver y configurar las tablas de enrutamiento, tanto de la tabla de enrutamiento principal, como de las «secundarias» que configures. tunnel: permite ver los túneles IP y también configurarlos. maddr: permite ver y configurar las direcciones multienlace. mroute: permite ver y configurar la tabla de enrutamiento multicast. mrule: permite ver y configurar políticas de enrutamiento de direcciones multicast. monitor: permite monitorizar el estado de las tarjetas de red de manera continua, también direcciones IP y rutas. ntable: gestiona el caché de neighbour (ARP) tuntap: gestiona las interfaces TUN/TAP, orientado a las VPN como OpenVPN o WireGuard. maddress: configuración de las direcciones multicast xfrm: gestiona las políticas IPsec. netns: administrar espacios de nombres de red l2tp: configuración de L2TP tcp_metrics: gestiona métricas TCP. token: gestiona los identificadores con token de las interfaces. Bibliografía Cambiar configuración TCP/IP Información general sobre comandos Información protocolo ICMP\nComando PING\nComando NSLOOKUP\nDescripción parámetros de los comandos Configuración red debian Comando ifconfig\nComando ip\n","date":"September 8, 2023","hero":"/images/redes/comando_de_supervision_de_redes/comando_de_supervision_de_redes.webp","permalink":"https://www.javiercd.es/posts/redes/comandos_de_supervision_de_redes/comandos_de_supervisi%C3%B3n_de_redes/","summary":"Documento en el cual se detallan los principales comandos a la hora de detectar incidencias en redes y lograr solucionarlos .\nComandos en Windows Explica el significado de los distintos parámetros a configurar en las Propiedades de TCP/IP en Windows Tenemos que tener en cuenta que cada configuración que hagamos es independiente para cada uno de nuestros adaptadores de red .\nPara acceder a configurar estos parámetros seguiremos la siguiente ruta en nuestro sistema :","tags":["Redes","comandos"],"title":"Comandos de supervisión de redes"},{"categories":null,"contents":"\rLa tecnología NFS (Network File System) ha sido una pieza fundamental en la compartición de archivos en entornos de red. Desarrollada por Sun Microsystems, NFS permite a sistemas operativos Unix y Linux compartir recursos de archivos de manera transparente, brindando acceso a archivos y directorios remotos como si estuvieran almacenados localmente.\n1.Instalación y configuración NFS Instalamos el paquete nfs-kernel-server.\nCrearemos el directorio que vamos a compartir y le cambiamos los dueños y los permisos del mismo :\nEn el fichero etc/exports indicaremos cual es nuestro directorio y sus respectivos permisos :\nro: permiso de solo lectura del directorio rw: permiso de lectura y escritura del directorio subtree_check: especifica la verificación de subdirectorios no_subtree_check: previene verificación de subdirectorios sync: Escribe todos los cambios en el disco antes de aplicarlo Async: ignora la verificación de sincronización para mejorar la velocidad Aplicamos los cambios y reiniciamos el servicio :\n2.Visualizarlo en un cliente debian Nos instalaremos el siguiente paquete :\nLa montamos en nuestro cliente :\nTambién podemos hacerlo de forma permanente en el fstab :\nPodemos visualizar el contenido :\nVamos a crear un archivo y a comprobar que se ha creado en el servidor :\n3.Visualización en Windows Nos descargamos la característica de cliente NFS:\nMapeamos la unidad de red :\nCreamos un fichero de forma remota y comprobamos que se ha creado .\nLo comprobamos también en el servidor :\n","date":"September 8, 2023","hero":"/images/sistemas/nfs/portada.png","permalink":"https://www.javiercd.es/posts/sistemas/nfs_debian/nfs/","summary":"La tecnología NFS (Network File System) ha sido una pieza fundamental en la compartición de archivos en entornos de red. Desarrollada por Sun Microsystems, NFS permite a sistemas operativos Unix y Linux compartir recursos de archivos de manera transparente, brindando acceso a archivos y directorios remotos como si estuvieran almacenados localmente.\n1.Instalación y configuración NFS Instalamos el paquete nfs-kernel-server.\nCrearemos el directorio que vamos a compartir y le cambiamos los dueños y los permisos del mismo :","tags":["Linux","Sistemas","ISO","ASO"],"title":"Compartir directorios con NFS en debian"},{"categories":null,"contents":"\rEn el entorno empresarial, la capacidad de compartir recursos en red es esencial para la colaboración y la eficiencia operativa. En este artículo, exploraremos cómo compartir directorios en un entorno Windows Server, abordando los métodos tanto a través de la interfaz gráfica como mediante cmd y PowerShell.\nDesde la interfaz gráfica Podemos compartir un directorio de nuestro servidor , accediendo a las propiedades del mismo . Una vez aquí pulsamos sobre el menú compartir :\nAhora le daremos permisos a los usuarios que deseemos que tengan acceso a este :\nUna vez compartido nos mostrara la ruta que tendremos que poner para acceder a este recurso , que podemos modificarla a nuestro gusto en uso compartido avanzado :\nDesde un cliente podemos ver los recursos que esta compartiendo nuestro servidor usando net view :\nPodemos mapear la unidad de red desde la linea de comandos usando net use :\nVamos a crear un directorio y comprobar que se ha creado :\nVemos que en el servidor se ha creado :\nTambién podemos hacer esto desde la administración de usuarios y grupos de active directory :\nCompartir recursos desde cmd Ahora vamos a usar net share para compartir un recurso en red a traves de la linea de comandos :\nSi desde otro cliente vemos los recursos que comparte el server core , lo veremos :\nSi queremos cambiar los permisos de un recurso compartido podemos usar los comandos cacls y icacls . También tenemos la posibilidad de hacerlo usando la interfaz gráfica con las RSAT.\nComandos powershell Crearemos el recurso compartido\nNew-SmbShare -Name JCD\\_comp -Path \u0026#34;C:\\compartir\\\u0026#34; -FullAccess \u0026#34;Administrador\u0026#34; Si queremos añadir permisos específicos a un grupo a la hora de crear el recurso compartido seria :\nNew-SmbShare -Name \u0026lt;Nombre-de-la-carpeta\u0026gt; -Path \u0026lt;Ruta-de-la-carpeta\u0026gt; -ReadAccess \u0026#34;\u0026lt;Grupo-o-usuario-que-tiene-acceso-de-lectura\u0026gt;\u0026#34; -FullAccess \u0026#34;\u0026lt;Grupo-o-usuario-que-tiene- acceso-total\u0026gt;\u0026#34; Si después de esto queremos añadirle o quitarle permisos a algún usuario o grupo al directorio samba compartido :\nSet-SmbPathAcl -Path \u0026#34;C:\\compartir\u0026#34; -AceType Allow -AccessType Write -AccountName UsuariosCompartidos Si por el contrario queremos eliminar permisos al usuario o grupo :\nRemove-SmbPathAcl -Path \u0026#34;C:\\compartir\u0026#34; -AceType Allow -AccessType Write -AccountName UsuariosCompartidos Para montar este directorio compartido en otro host Windows :\nNew-PSDrive -Name J -PSProvider FileSystem -Root [\\\\172.22.9.143\\JCD_comp](file://172.22.9.143/JCD_comp) Además podemos listar para ver si se ha montado correctamente :\nListaremos el contenido del mismo para ver si tenemos acceso a el :\n","date":"September 8, 2023","hero":"/images/sistemas/compartir_directorios_win/portada.jpg","permalink":"https://www.javiercd.es/posts/sistemas/comparticion_de_directorios_en_windows/comparticion_de_directorios_en_windows/","summary":"En el entorno empresarial, la capacidad de compartir recursos en red es esencial para la colaboración y la eficiencia operativa. En este artículo, exploraremos cómo compartir directorios en un entorno Windows Server, abordando los métodos tanto a través de la interfaz gráfica como mediante cmd y PowerShell.\nDesde la interfaz gráfica Podemos compartir un directorio de nuestro servidor , accediendo a las propiedades del mismo . Una vez aquí pulsamos sobre el menú compartir :","tags":["Windows","Sistemas","ISO","ASO"],"title":"Compartir recursos en red en Windows Server"},{"categories":null,"contents":" Instalar un servidor web Apache para el uso en una Intranet Para instalar el servidor debemos ejecutar como root el siguiente comando:\nCrea dentro del directorio /var/www/html un fichero llamado entrada.html en el que pongáis un mensaje de bienvenida\nAhora lo meteré dentro de la ruta :\nA continuación vamos a publicar una página más completa en nuestro servidor, para ello\nutiliza tu sitio web de aplicaciones web.\nAdemas debemos de darle permisos de lectura a otros para que podamos visualizarla :\nAccede desde los clientes, poniendo en un navegador la siguiente URL:\nDesde debian cliente :\nA continuación vamos a publicar una página más completa en nuestro servidor, para ello utiliza tu sitio web de aplicaciones web:\nResolución local de nombres : modifica los ficheros necesarios en el servicio BIND y accede usando el nombre que has indicado :\nComo ya tenia echo el dns anteriormente he utilizado este nombre :\nConfiguración de sitios web virtuales usando Apache La primera web tendrá el directorio base será /var/www/iesgn y contendrá una página llamada index.html, donde sólo se verá una bienvenida a la página del instituto Gonzalo Nazareno .\nLa segunda web tendrá el directorio base será /var/www/departamentos. En este sitio sólo tendremos una página inicial index.html, dando la bienvenida a la página de los departamentos del instituto.\nNecesitamos tener dos ficheros para realizar la configuración de los dos sitios virtuales, para ello vamos a copiar el fichero 000-default.conf\nUna vez hayamos creado los ficheros añadiremos dentro de cada uno el siguiente contenido :\nAhora deberemos crear un enlace simbólico en el directorio /etc/apache2/sites-enabled.\nPara que se apliquen estos cambios debemos reiniciar el servicio :\nAhora deberemos de actualizar el dns :\nUna vez reiniciado el dns podremos acceder a ambos sitios desde el navegador :\nAcceso autentificado al servidor web Apache Para activar la autentificación básica debemos de añadir las siguientes lineas a nuestro archivo de configuración del sitio :\nAhora creamos el archivo de las contraseñas , con el usuario previamente creado :\nReiniciamos el servicio y nos conectamos :\nAhora vamos ha hacer que a la pagina departamentos solo acceda el director y el profesor , ademas que a dirección solo acceda el director , para eso añadimos en departamentos:\nAhora vamos a añadir los usuarios de las zonas para eso , utilizamos este comando :\nUsuario profesor a departamentos : Usuario director a departamentos : Usuario director a zona dirección : Ahora reiniciaremos el servicio y comprobaremos que podemos acceder :\nAccederemos a departamentos :\nAhora a la zona equipo directivo :\n","date":"September 8, 2023","hero":"/images/servicios/apache/portada-apache.jpg","permalink":"https://www.javiercd.es/posts/servicios/apache/apache/","summary":"Instalar un servidor web Apache para el uso en una Intranet Para instalar el servidor debemos ejecutar como root el siguiente comando:\nCrea dentro del directorio /var/www/html un fichero llamado entrada.html en el que pongáis un mensaje de bienvenida\nAhora lo meteré dentro de la ruta :\nA continuación vamos a publicar una página más completa en nuestro servidor, para ello\nutiliza tu sitio web de aplicaciones web.\nAdemas debemos de darle permisos de lectura a otros para que podamos visualizarla :","tags":["Servicios","NAT","SMR","IPTABLES","SNAT","SSH","FORWARDING","APACHE"],"title":"Configuración Apache bajo debian"},{"categories":null,"contents":"\rEn este artículo, exploraremos la configuración de SNAT (Source Network Address Translation) y DNAT (Destination Network Address Translation) en escenarios con direcciones públicas, haciendo uso de routers en entornos Linux y dispositivos Cisco.\nEscenario con maquinas debian Preparación del entorno Instalación de paquetes Una vez colocadas las maquinas deberemos de descargarnos apache para los servidores web , para realizar esto conectaremos ambos servidores a un switch y este a la nube NAT para disponer de acceso a internet .\nAhora actualizaremos los repositorios haciendo un apt update :\nA continuación ya podremos descargar los paquetes , para los servidores instalaremos apache :\nY para el router de casa descargaremos el servidor DHCP :\nAl acabar la instalación saltara un código de error similar a este , esto es debido a que no hay una configuración valida en el servicio :\nPor ahora ignoraremos esto y posteriormente configuraremos el servidor DHCP .\nCon esto habríamos instalado todos los paquetes necesarios para instalar la practica así que podemos montar el escenario .\nConfiguración de las tarjetas de red Nos encontraremos con un pequeño obstáculo a la hora de hacer el escenario ya que necesitamos que algunos routers tengan mas de una tarjeta de red .\nPara añadir mas de una tarjeta con el dispositivo apagado y sin estar conectado a nadie , hacemos sobre el clic derecho y pulsamos sobre configure \u0026gt; network , y seleccionamos el numero de adaptadores que necesitamos tener en cada uno , por ejemplo para el router de casa necesito tener dos adaptadores :\nUna vez hecho esto con las maquinas que necesitan mas de una tarjeta , montaremos el escenario y procederemos a configurar sus tarjetas .\nPara modificar la configuración de las tarjetas de red lo haremos editando el fichero /etc/network/interfaces .Para que se aplique la configuración de las tarjetas de red que hemos realizado tenemos varias opciones .\nSubir y bajar la tarjeta que hemos modificado :\nTambién podemos ahorrar tiempo y reiniciar el servicio de networking , esto funcionara para todas las tarjetas simultáneamente así que nos ahorrara tiempo :\nRouter CASA:\nRouter R1:\nRouter ISP:\nRouter R2:\nAsí seria la relación de ips que tienen las tarjetas de red de los routers . Para aplicar esta configuración a las tarjetas de red tendremos que reiniciar la misma como indico al principio de este apartado .\nPara que el escenario funcione debemos activar el bit de forwarding para estos 4 routers , en este caso lo haré de forma permanente para ello editamos el fichero /etc/sysctl.conf y descomentamos esta linea :\nRutas necesarias Para mi esquema actual las rutas que necesitamos en los routers son :\nRouter R1:\nRouter ISP:\nRouter R2:\nRouter CASA:\nComprobación de conectividad Vamos a hacer ping desde cada uno de los routers a su extremos “mas lejanos” para asegurarnos de que hemos realizado correctamente el enrutamiento .\nRouter R1 –\u0026gt; R2\nRouter R1 –\u0026gt; CASA\nRouter R2 –\u0026gt; R1\nRouter R2 –\u0026gt; CASA\nRouter CASA –\u0026gt; R1\nRouter CASA –\u0026gt; R2\nVemos que todos los dispositivos que tiene direcciónes ips publicas tienen conectividad entre si pero que pasa con los que tienen direcciónamiento privado en nuestro escenario , estos no tendrán conectividad ya que no se enrutan direcciónes privadas en los routers de internet .\nEs decir si lanzamos un ping hacia una dirección privada que sea de otra red , por ejemplo del servidor1 al servidor2 este no llegara , ya que en las tablas de enrutamiento del router del ISP no existen rutas para direcciónes privadas .\nPor lo que sera imposible alcanzar una red privada diferente a la que pertenezcamos .\nPor ejemplo desde casa si le hacemos ping a google se lo hacemos a la dirección PUBLICA 8..8.8.8 no a la dirección privada que tiene el servidor , puede ser la 172.22.1.15\nConfiguración del servicio DHCP en router CASA Retomando lo que habíamos hecho anteriormente en el apartado de instalación de paquetes ya hemos descargado el servidor DHCP para debian (isc-dhcp-server). Así que ahora vamos a configurarlo .\nLo primero que necesitamos hacer es decirle a nuestro servidor a través de que tarjeta de red queremos que este reparta direcciónes ip , en nuestro caso es la tarjeta ens5 .\nPara ello editaremos el fichero /etc/default/isc-dhcp-server y añadiremos el nombre de la tarjeta en la sección de IPV4 :\nAhora vamos a indicarle a nuestro servidor DHCP que configuración queremos que le asigne a nuestros clientes para ello editamos el fichero /etc/dhcp/dhcpd.conf , podemos aprovechar uno de los ejemplos que vienen comentados y aplicar nuestra configuración :\nEste es un ejemplo muy sencillo de un servidor dhcp pero con esto es suficiente para nuestro escenario .\nLos campos significan :\nsubnet : dirección de red de la cual queremos repartir direcciónes ip con este servicio . netmask : Mascara de red de la red la cual queremos configurar los dispositivos. range: Rango de direcciónes de la cual queremos repartir ips siendo la primera la inicial y la ultima la final . option routers: Seria la puerta de enlace de nuestra red option broadcast-address : dirección de broadcast de nuestra red . Una vez configurado con los parámetros de nuestra red reiniciaremos el servicio :\nY comprobaremos que el servicio esta activo :\nAhora para que los clientes puedan recibir una dirección utilizando este servicio deberemos de configurar las tarjetas de red de PC1 y PC2 de la siguiente manera :\nReiniciamos el servicio para que esta se aplique y el servidor nos asigne automáticamente la configuración de red :\nComprobamos que efectivamente nos ha asignado la configuración de la red :\nTambién podemos hacer un seguimiento de a quien le hemos asignado la ip través del servidor viendo el siguiente archivo /var/lib/dhcp/dhcpd.leases el cual guarda las concesiones que hemos realizado .\nPodemos ver cuando empieza así como a quien se le ha asignado viendo su dirección MAC.\nConfiguración de NAT Router CASA Vamos a configurar el SNAT en el router de casa viendo el esquema actual la regla para hacer esto es :\nSin embargo así se eliminaría cuando reiniciase la maquina así que en este caso voy a añadirla al /etc/network/interfaces :\nAsí podemos ver que se han aplicado después de reiniciar el servicio networking :\nVamos a comprobar que funciona la regla viendo si lanzo un ping a otra red (R1) si este cambia mi dirección IP :\nVemos que haciendo la captura este me ha cambiado la dirección privada de la maquina por la publica del router de casa por lo que la regla de SNAT estaría funcionando correctamente .\nRouter R2 Vamos a configurar SNAT y DNAT para ello añadiré las reglas al /etc/network/interfaces :\nReiniciamos el servicio networking y vemos si se ha aplicado :\nComprobaremos que funciona el SNAT haciendo ping del servidor hacia fuera a una dirección publica :\nVemos que esta funcionando correctamente la regla de SNAT :\nYa que nos ha cambiado la dirección ip privada por la publica correspondiente al router . En los apartados posteriores probare el DNAT .\nRouter R1 Para este router vamos a realizar la creación de las reglas de una forma diferente , para ella crearemos un servicio que se encargue de levantar las reglas de DNAT y SNAT cuando la maquina se reinicie para evitar añadirlas al fichero interfaces .\nLas reglas de DNAT y SNAT para esta maquina son :\nLo primero que tendremos que hacer sera crear un script con nuestras reglas , así que las volcare con el comando iptables-save \u0026gt; /etc/iptables/rules.v4 para volcar las reglas existentes .\nAhora crearemos un script en en el cual restauraremos las reglas que hemos volcado y lo crearemos en la siguiente ruta /usr/local/bin/ :\nNos tendremos que asegurar que tiene permisos de ejecución :\nCrearemos un archivo de servicio de Systemd , este archivo debe tener permisos de lectura y escritura solo para root, por lo que se debe ejecutar el siguiente comando como root:\nDentro de este añadiremos el siguiente contenido , solo tendrías que añadir la ruta donde se encuentre tu script de iptables que restaura las reglas :\nLe diremos al servicio que se inicie automáticamente al reiniciar la maquina :\nY lo iniciamos :\nSi queremos asegurarnos de que ha realizado su cometido correctamente miraremos el estado del servicio :\nVeremos que las reglas se han añadido automáticamente :\nComprobaremos que nos ha realizado el SNAT correctamente lanzando un ping :\nVemos que nos ha cambiado la dirección ip privada por la publica .\nComprobación de navegación y DNAT Ahora vamos a comprobar que desde la red de casa podemos acceder a los servidores web .\nCliente Debian Desde el cliente debian podemos hacer un curl para comprobar el correcto funcionamiento del DNAT en el Router R1:\nDesde el cliente debian podemos hacer un curl para comprobar el correcto funcionamiento del DNAT en el Router R2:\nAhora vamos a comprobar que pasa si ponemos la dirección privada de los distintos servidores web :\nVemos que no podemos llegar a esa red ya que los routers de internet son incapaces de encaminarnos hacia esta red privada ya que puede haber miles de dispositivos con la misma ip :\nTampoco recibiríamos respuesta si hiciésemos una petición web .\nSi interceptamos una petición http vemos que el SNAT se realiza correctamente , cambiando la ip privada del solicitante por la publica de su router :\nAhora voy a interceptar una petición en la que se haga DNAT para comprobar que este se realiza correctamente :\nPodemos ver que el origen es una dirección ip publica mientras que el destino es una dirección ip privada podemos ver que el DNAT se ha realizado correctamente .\nAhora voy a pinchar un Firefox y volveré a comprobar que podemos acceder a los servidores web solo usando su dirección ip publica :\nServer 1 :\nServer 2:\nVemos que usando dirección ip publica podemos conectarnos , sin embargo no podremos usando las direcciónes ips privada de las maquinas :\nServer 1 :\nServer 2 :\nFunciona correctamente ya que hemos conseguido que nuestros routers Linux sean capaces de hacer SNAT y DNAT pudiendo hacer que estos “utilicen” internet y puedan acceder a los recursos de otras redes . Ya que las direcciónes privadas no se enrutan en los mismos así que si comprobamos usando estas no obtendremos ningún resultado .\nDepuración NAT Para ver cuantos hits ha tenido una regla o para ver cuanta información ha “utilizado” cada regla utilizaremos el siguiente comando :\nPara borrar los contadores de todas las cadenas y reglas usaremos iptables -Z :\nSi nuestra cadena tiene hits la regla estará funcionando correctamente si por el contrario esta se mantiene en 0 , la regla no se esta aplicando así que tendremos que revisarla .\nEscenario con routers Cisco Volveremos a repetir el mismo escenario que con los routers Linux pero ahora usando routers cisco 7200.\nPreparación del entorno Configuración de las tarjetas de red Lo primeros que haremos sera añadirle los slots necesarios a nuestros routers ya que necesitamos 2 tarjetas de red en R1,R2 y CASA . Edemas de 3 para el router ISP .\nPara los primeros le añadiremos el slot PA-FE-TX , que nos añadirá una interfaz FastEthernet:\nMientras que para el router del ISP le añadiremos PA-2FE-TX que nos añadirá dos interfaces de red FastEthernet.\nAhora podemos arrancar los routers y comenzar con la configuración de las tarjetas de red . Usare las mismas direcciónes que en el escenario anterior .\nRouter CASA Configuramos las tarjetas de red :\nQuedando así nuestras interfaces :\nRouter R1 Configuramos las tarjetas de red :\nQuedando así nuestras interfaces :\nRouter R2 Configuramos las tarjetas de red :\nQuedando así nuestras interfaces :\nRouter ISP Configuramos las tarjetas de red :\nQuedando así nuestras interfaces :\nRutas necesarias Rutas ISP: Rutas CASA : Rutas R2: Rutas R1: Seria necesario únicamente que añadamos las rutas por defecto en los Routers R1 , R2 y CASA .\nPrueba de conectividad R1 –\u0026gt; R2\nR1 –\u0026gt; CASA\nR2-→ R1\nR2 –\u0026gt; CASA\nCASA –\u0026gt; R1\nCASA –\u0026gt; R2\nVemos que todos los dispositivos que tiene direcciónes ips publicas tienen conectividad entre si pero que pasa con los que tienen direcciónamiento privado en nuestro escenario , estos no tendrán conectividad ya que no se enrutan direcciónes privadas en los routers de internet .\nConfiguración del servicio DHCP en router CASA Lo primero que haremos sera establecer el rango de IP´s excluidas del conjunto (pool) de direcciónes que podrá asignar el servicio indicando la ip inicial y final del rango, ambas incluidas:\nPonemos un nombre al rango del servicio DHCP:\nDefinimos la red a la que dará servicio de DHCP:\nIncluimos la puerta de enlace que ofrecerá el servicio :\nCon esto ya estaría configurado el servidor DHCP del router de CASA , nos salimos y guardamos los cambios . Ahora encenderemos nuestras maquinas y veremos que están recibirán automáticamente su configuración por DHCP , con el siguiente comando podemos ver las estadísticas del servicio :\nAdemás podemos ver las concesiones con el siguiente comando :\nEste nos sera útil para realizar un seguimiento de quien tiene asignada cada IP sin tener que ir individualmente a casa maquina .\nConfiguración del NAT Router CASA Lo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nip nat pool ip_publica 102.168.0.2 102.168.0.2 netmask 255.255.255.0 Activamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nEl SNAT estaría funcionando , así que vamos a comprobarlo :\nVemos que nos cambia correctamente la ip privada de nuestro host por la publica del router de casa .\nRouter R1 Lo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nip nat pool ip_publica 101.168.0.2 101.168.0.2 netmask 255.255.255.0 Activamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nY comprobaremos que se esta realizando correctamente :\nNos cambia la ip 172.22.1.1 por la 101.168.0.2 que es la publica del router al realizar un ping , por lo que esta funcionando correctamente el SNAT.\nAhora configuraremos la regla de DNAT , la sintaxis es la siguiente :\nip nat inside source static tcp ip_privada puerto ip_publica puerto *Posteriormente comprobaremos que el DNAT funciona correctamente .\nRouter R2 Lo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nip nat pool ip_publica 103.168.0.2 103.168.0.2 netmask 255.255.255.0 Activamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nY comprobaremos que se esta realizando correctamente :\n*Nos cambia la ip 10.0.0.1 por la 103.168.0.2 que es la publica del router al realizar un ping , por lo que esta funcionando correctamente el SNAT.\nAhora configuraremos la regla de DNAT , la sintaxis es la siguiente :\nip nat inside source static tcp ip_privada puerto ip_publica puerto *Posteriormente comprobaremos que el DNAT funciona correctamente .\nComprobación de navegación y DNAT Ahora vamos a comprobar que desde la red de casa podemos acceder a los servidores web .\nAccederé usando curl desde un host de la red de casa . Primero me conectare al servidor 1 :\nVemos que este nos responde correctamente y se aplica el DNAT , ya que ha cambiado la ip publica del router por la privada del servidor web :\nAhora comprobaremos el servidor 2 :\nVemos que este nos responde correctamente y se aplica el DNAT , ya que ha cambiado la ip publica del router por la privada del servidor web :\nAhora comprobaremos que puedo acceder desde un Tiny Core con Firefox a ambos servidores :\nAl servidor 1 :\nAl servidor 2 :\nVemos que también podemos conectarnos ya que las reglas de NAT están funcionando correctamente .\nVamos a comprobar que ocurre si solicitamos la web a través de sus direcciónes ip privadas :\nPues que obviamente no recibimos respuesta ya que en nuestro escenario estamos simulando internet y en este no se pueden enrutar direcciónes ips privadas ya que están pueden estar repetidas en infinidad de redes .\nDepuración de las reglas NAT Además para asegurarnos de que las reglas de NAT están funcionando .\nEl primer comando nos permite ver la tabla de traducciones de direcciónes DNAT :\nCon este comando podremos ver cuantos hits tienen nuestras reglas , si no tiene ninguno es que esta no esta funcionando salvo que nosotros hayamos inicializado este :\nSi queremos poner los contadores a cero usaremos el comando clear ip nat statistics .\nSi queremos ver en tiempo real los paquetes que muestra información sobre cada paquete que traduce el router :\nCuando decodifique el resultado de este comando, observe los significados de los siguientes símbolos y valores:\n* : el asterisco junto a NAT indica que la traducción se realiza en la ruta de switching rápido. Al primer paquete en una conversación siempre se aplica el switching de procesos, que es más lento. Si existe una entrada de caché, el resto de los paquetes atraviesan la ruta de switching rápido. S: Este símbolo hace referencia a la dirección IPv4 de origen. a.b.c.d→ w.x.y.z: este valor indica que la dirección de origen a.b.c.d se traduce a w.x.y.z. d: = Este símbolo hace referencia a la dirección IPv4 de destino. [xxxx] = El valor entre corchetes es el número de identificación IPv4. Esta información puede ser útil para la depuración, ya que habilita la correlación con otros seguimientos de paquetes realizados por los analizadores de protocolos. Bibliografía Depuración NAT ","date":"September 8, 2023","hero":"/images/redes/configuracion_nat/portada.jpg","permalink":"https://www.javiercd.es/posts/redes/configuracion_de_nat/configuracion_de_nat/","summary":"En este artículo, exploraremos la configuración de SNAT (Source Network Address Translation) y DNAT (Destination Network Address Translation) en escenarios con direcciones públicas, haciendo uso de routers en entornos Linux y dispositivos Cisco.\nEscenario con maquinas debian Preparación del entorno Instalación de paquetes Una vez colocadas las maquinas deberemos de descargarnos apache para los servidores web , para realizar esto conectaremos ambos servidores a un switch y este a la nube NAT para disponer de acceso a internet .","tags":["Redes","Enrutamiento","NAT","SNAT","DNAT","Cisco","Linux"],"title":"Configuración de NAT Cisco y Linux"},{"categories":null,"contents":"\rAprenderás a configurar switches en GNS3, tanto dispositivos genéricos como switches Cisco, utilizando el concepto de VLANs para segmentar la red y explorar las complejidades de la gestión de redes.\nPreparación escenario Lo primero que haré sera montar el escenario :\nConfiguración de red de los clientes A continuación configurare las tarjetas de red de los clientes , aprovechando que la nube NAT incluye un servidor DHCP.\nPara hacer esto escribimos en los VPCS el siguiente comando :\nEjercicio A 1 PC1 y PC3 pertenecen a la VLAN 10, PC2 y PC4 pertenecen a la VLAN 20. Demuestra el funcionamiento correcto de ambas VLAN y que no hay conectividad entre PC2 y PC3. ¿Puedes hacerlo con los switches Ethernet que trae GNS3? ¿Encuentras alguna limitación? ¿Cuáles son las distintos tipos (types) que puede tener un puerto y en qué se diferencian?\nPara configurar las VLANS en los switches , le damos clic derecho y a continuación realizamos la siguiente configuración :\nPara el switch 3 (PC1 y PC2)\nPara el switch 2 (PC3 y PC4)\nPara el switch (PC5 Y NAT1)\nPC1 , solo tendrá conectividad con los PCs que pertenecen a su VLAN :\nPC2 , solo tendrá conectividad con los PCs que pertenecen a su VLAN:\nCon sus respectivas parejas del otro switch obtendremos el mismo resultado. PC3 , solo tendrá conectividad con los PCs que pertenecen a su VLAN:\nPC4 , solo tendrá conectividad con los PCs que pertenecen a su VLAN:\nTenemos que tener en cuenta que los dispositivos que no pertenecen a la VLAN 10 deberemos de configurados manualmente ya que estos no tienen conectividad con el servidor DHCP.\nEl ejercicio A podemos hacerlo perfectamente con los switches que trae GNS3 , encontraremos una limitación importante , ya que los switches solo permiten que las bocas pertenezcan a una VLAN .\nAl realizar el ejercicio debemos de tener en cuenta los types que puede tener un puerto , los que hemos utilizado son los dos primeros :\nAccess: Este es el destinado para un equipo final , es decir un cliente ya que se encarga de eliminar el etiquetado que va en el encabezado. Dot1q:Este es el encargado de interconectar dispositivos de red entre si , se encarga de añadir el etiquetado en el encabezado para mandar el paquete a otro dispositivo y que este sepa a que VLAN pertenece . QinQ : Es similar a dot1q pero este además se encarga de añadir en el etiquetado , el tipo de paquete para identificarlos . Teniendo esto en cuenta podemos hacer una analogía con la practica de switches físicos : Los puertos untagged –\u0026gt; Access\nLos puertos tagged –\u0026gt; Dot1q\nAl utilizar estos switches el protocolo 802.1Q pero “con menos funciones” no podemos indicar que VLANS queremos que utilice los puertos configurados como Dot1q , sino que este a través de la VLAN por defecto pasara los paquetes etiquetados de todas las VLANS .\nEjercicio B 2 Todos los ordenadores deben poder acceder al servidor de datos, pero solo PC1 y PC3 deben acceder a Internet. Lo harán a través de vuestra máquina física usando el elemento llamado NAT, que deberéis comprender y configurar. ¿Puedes hacerlo con los switches Ethernet que trae GNS3? ¿Qué limitación te encuentras? Para superar dicha limitación, descarga el CISCO 3725 como appliance y úsalo en lugar de los switches Ethernet configurándolos adecuadamente.\nSwitches Ethernet Aquí encontramos la primera limitación de estos switches , ya que solo podemos tener 1 VLAN por puerto esto quiere decir que solo una VLAN tendrá acceso a estos recursos .\nComo queremos que solo la VLAN 10 navegue por internet configuraremos la boca de nuestra nube a una boca con tipo Access y que pertenezca a esta VLAN :\nPor lo que para este punto no hay problema , nuestros PC1 y PC3 , ambos serán capaces de navegar por internet :\nComo estos 2 PCS pertenecen a la misma VLAN que la nube NAT pueden comunicarse sin problema y utilizar el servidor DHCP que incluye la misma para configurarse . Mientras que los PC2 y PC4 no podrán ni navegar ni configurarse por DHCP al no pertenecer a la misma VLAN que la nube NAT :\nCon el servidor de datos nos toparemos con la limitación ya que únicamente un puerto puede pertenecer a una VLAN , solo una pareja de nuestros PCs podrán comunicarse . Esto podríamos evitarlo configurando el servidor como una “maquina real” con 2 interfaces virtuales y diciéndole al switch que cada una pertenece a una VLAN distinta .\nCISCO 3725 Para comenzar a utilizar este dispositivo , tendremos que añadirle espacio al disco para que podamos iniciarlo , además podemos añadir el modulo de 16 bocas Ethernet de forma predeterminada así no tendremos que hacerlo a mano mas adelante .\nPara realizar esta configuración deberemos de tener importado el router y acceder a Edit \u0026gt; preferences \u0026gt; IOS routers .\nUna vez modificada la plantilla colocaremos los 3725 en el escenario y montaremos el mismo escenario :\nDebemos de tener en cuenta que las interfaces FastEthernet0/0 y FastEthernet0/1 funcionan como routers , es decir no podemos utilizarlos como switch . Los puertos que se comportan como switch son todos los de FastEthernet1 así que sera los que utilicemos .\nA continuación le diremos a estos puertos que tienen que funcionar como si fuesen un switch para ello introduciremos los siguientes comandos en cada uno de los 3725.\nAhora crearemos las vlans usando los siguientes comandos , para cada uno de los switches :\nPodemos listarlas con el siguiente comando :\nAhora le asignaremos a los puertos su VLAN correspondiente :\nA continuación configuraremos el puerto que une a los dos 3725 , para esto lo ponemos en modo trunk y permitimos el trafico encapsulado de todas las VLANS por este puerto .\nPor ultimo guardaremos los cambios para que si se apaga el equipo mantenga las modificaciones que hemos realizado :\nCon esto habremos configurado el primer 3725 , su homologo a este , es decir el que conecta a PC3 y PC4 , tendríamos que hacer lo mismo adaptado a los puertos en los que estén conectado los dispositivos .\nContinuaremos configurando el 3725 que une ambos “switches” y da salida al servidor de datos y a internet . Para ello crearemos las VLANS 10 y 20 :\nY le asignaremos al servidor de datos ambas VLANS mientras que a la salida a internet solo la VLAN 10:\nAhora configuraremos las interfaces que interconectan los switches :\nA continuación crearemos las dos subintrantes para permitir el trafico entre ellas y le asignaremos direcciones ip .\nAhora el servidor de datos lo conectaremos al puerto Fe0/0 y en el crearemos dos subintrantes , yo utilizare una maquina debian . Esto lo haremos editando en network interfaces :\nComprobamos que las interfaces estén subidas :\nAhora crearemos las rutas de enroutamiento:\nUna vez hecho esto podremos hacerle ping al servidor de datos desde las dos interfaces :\nPodemos hacerle ping al servidor de datos y tendremos conectividad con el :\nVemos que el trafico es capaz de llegar al servidor de datos sin embargo este no es capaz de “hacer el camino de vuelta ”.\nTambién he configurado enroutamiento inter vlan , siguiendo los enlaces de la bibliografía sin embargo no me ha funcionado tampoco.\nEjercicio C Responde a las siguientes preguntas sobre los apartados anteriores:\nC.1 ¿Qué pasa con el direccionamiento cuando añades la nube de NAT? ¿Cuál es el motivo de este cambio?\nCuando ponemos la nube NAT , esta incluye un servidor DHCP el cual tiene la direccion ip 192.168.122.1 y asignas direcciones de la red 192.168.122.1/24 . A través de la configuración que nos proporciona este nos permitirá navegar por internet .\nC.2¿Por qué es necesario asignar un disco duro a cada uno de los dispositivos y qué tamaño mínimo debe tener para que el escenario funcione?\nPara los routers cisco 3725 , para que este inicie y supere el chequeo inicial este debe tener como mínimo un espacio de 1MB , además si queremos guardar las configuraciones esto sera necesario .Por ejemplo para guardar la información de las vlans sera necesario.\nC.3¿Qué diferencia hay entre configurar un puerto del switch en modo access y en modo trunk y cuándo hay que usar cada uno de ellos?\nEl modo access esta pensado para conectar un cliente final es decir , un pc . Es el equivalente a el “ puerto untagged “ , sin embargo este tiene una limitación el cual es que solo puede pertenecer a una vlan , este puerto se encarga además de eliminar el encabezado que añaden los puertos trunk para que los dispositivos finales puedan entender los paquetes .\nPor otro lado el modo trunk permite interconectar un dispositivo de red con otro , por ejemplo un switch con otro switch , seria el equivalente a un “puerto tagged” , este además permite el trafico de varios vlans , etiquetando las tramas para que los demás dispositivos puedan interpretar la VLAN a la que pertenece el paquete .\nEjercicio D Sustituye ahora PC1 y PC3 por dos máquinas Linux con Firefox instalado (puedes encontrar las imágenes en el MarketPlace de GNS3) y comprueba que navegan correctamente.\nLo añadimos al escenario y los conectamos a las mismas bocas que teníamos nuestros VPCS para que mantengan la configuración anterior de las VLANS y tengamos acceso a la nube NAT .\nUna vez hecho esto accederemos a la interfaz de la maquina y configuraremos su tarjeta de red por DHCP , para ello accederemos al panel de control :\nEn el panel de control accedemos a network para configurar la red :\nEn el panel de network diremos que use DHCP y guardamos la configuración :\nEn la terminal podemos cerciorarnos de que la configuración de red se ha realizado correctamente .\nY podemos ver que haciendo este procedimiento ya podremos navegar con el tinycore con Firefox :\nAquí la prueba con el segundo tiny core :\nEjercicio E Monta un Port Bonding entre el switch de cabecera y los otros dos. Demuestra su correcto funcionamiento y explica detalladamente como lo has configurado. Explica los flags que puede tener un portchannel.\nA continuación deberemos de configurar los puertos extra que hemos añadido al escenario para que estén en modo trunk y se respete nuestro escenario con las VLANS , es repetir lo que hemos hecho anteriormente.\nLo primero que deberemos de hacer sera crear las interfaces lógicas ,sin embargo este paso lo podemos omitir ya que posteriormente si no existe la interfaz la creara automáticamente .\nIndicaremos que interfaces queremos que pertenezcan al port-channel 1 para el enlace lógico entre R1-R2 y que pertenezcan al port-channel 2 para el enlace lógico entre R2-R3.\nPara R1-R2 :\nPara R2-R1 :\nPara R2-R3 :\nPara R3-R2 :\nTambién podemos configurar el EtherChannel como un enlace trunk, y así conseguimos multiplexación estadística del tráfico de las VLANs y que ante la caída de un enlace sigue funcionando el otro con ambas VLANs. Esto lo haremos con todos los enlaces lógicos :\nUna vez hecho esto podemos comprobar si están funcionando los etherchannels:\nLa configuración de un EtherChannel se puede hacer utilizando uno de estos protocolos :Port Aggregation Protocol (PAgP) o Link Aggregation Control Protocol (LACP).Ambos extremos se deben de configurar en el mismo modo.\nEstos tienen unas serie de “modos ” en los cuales cambiara el comportamiento del puerto a la hora de crear enlaces :\non: En este modo, los enlaces miembros del grupo se agregarán manualmente y no se monitorizarán automáticamente. Este modo se utiliza cuando se desea tener un mayor control sobre los enlaces miembros del grupo. desirable: En este modo, el switch intentará negociar con el dispositivo conectado en el otro extremo del enlace. Si el dispositivo del otro extremo también está configurado en modo \u0026ldquo;desirable\u0026rdquo;, se agregará automáticamente el enlace. auto: En este modo, el switch no intentará negociar sino que agregará automáticamente el enlace si el dispositivo conectado en el otro extremo del enlace está configurado en modo \u0026ldquo;desirable\u0026rdquo;. active: En este modo, el switch enviará constantemente LACP PDUs para determinar si el dispositivo conectado en el otro extremo del enlace está disponible y también está configurado para usar LACP. Si el dispositivo del otro extremo está disponible y también está configurado para usar LACP, se agregará automáticamente el enlace. Ejercicio F Port Mirroring: Conecta un PC5 al Switch1 y monitoriza el tráfico que sale de PC1. Realiza una captura con Wireshark en la boca correspondiente al PC5 y explica el tráfico capturado.\nLo primero que haremos sera configurar el port mirroring , en mi caso enviara el trafico de la boca 1/5 a la 1/4.\nHare en el pc5 un ping a google y monitorizare el cable que va desde el router a pc4 , para comprobar que este funcionando el port mirroring :\nVemos que hemos podido “interceptar ” un ping , proveniente de la dirección ip del PC6 .\nEsto hará que el trafico entrante y saliente del puerto que hemos puesto como sniffer nos lo reenvié al puerto que escucha .\nPodemos comprobar el estado de la sesión del port mirroring con este comando :\nBibliografía Switching and GNS3 The NAT node Simulando switch cisco en GNS3 GNS3, añadiendo hosts a nuestras topologías Trabajando con switch en GNS3: VLAN y Trunk LACP y PAGP Routing interVLAN Enroutamiento VLAN Configurar PortBonding LinkAggregationControlProtocol(LACP)andPortAggregationProtocol(PAgP) Wikipedia Ether-channel Comunicación Inter VLAN ","date":"September 8, 2023","hero":"/images/redes/switches_gns3/portada.jpg","permalink":"https://www.javiercd.es/posts/redes/switches_gns3/configuracion_de_switches_en_gns3/","summary":"Aprenderás a configurar switches en GNS3, tanto dispositivos genéricos como switches Cisco, utilizando el concepto de VLANs para segmentar la red y explorar las complejidades de la gestión de redes.\nPreparación escenario Lo primero que haré sera montar el escenario :\nConfiguración de red de los clientes A continuación configurare las tarjetas de red de los clientes , aprovechando que la nube NAT incluye un servidor DHCP.\nPara hacer esto escribimos en los VPCS el siguiente comando :","tags":["Redes","Wireshark","GNS3","Cisco","Switches"],"title":"Configuración de switches en GNS3"},{"categories":null,"contents":"\r1.Instalación de la característica Lo primero que comprobaremos es comprobar si el servidor ssh esta instalado en la maquina a la cual queremos conectarnos .\nGet-WindowsCapability -Online | Where-Object Name -like \u0026#39;OpenSSH\\*\u0026#39; En el caso de que tengamos la característica la instalaremos :\nAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 Por defecto el servicio estará parado así que lo arrancamos :\nPodemos configurarlo para que arranque automáticamente al reiniciar el equipo :\n2.Conectarnos usando par de claves Lo primero que haremos sera generar un par de claves en el cliente , con ssh-keygen :\nUsando SCP podemos llevarnos nuestra clave publica o añadirla manualmente al fichero de authorized_keys :\nY probamos a conectarnos usando la clave :\nSi queremos que solo el servicio funcione con claves publicas y privadas , editamos el fichero C:\\ProgramData\\ssh\\sshd_config.\nSi queremos conectarnos con un cliente Linux , deberemos hacer el mismo proceso . Si el servidor fuese Linux podríamos usar la utilidad ssh-copy-id sin embargo no es compatible con servidores Windows así que usaremos scp :\nUna vez añadida podremos conectarnos :\n","date":"September 8, 2023","hero":"/images/sistemas/ssh_win/windows-ssh.jpg","permalink":"https://www.javiercd.es/posts/sistemas/ssh_windows/ssh_windows/","summary":"1.Instalación de la característica Lo primero que comprobaremos es comprobar si el servidor ssh esta instalado en la maquina a la cual queremos conectarnos .\nGet-WindowsCapability -Online | Where-Object Name -like \u0026#39;OpenSSH\\*\u0026#39; En el caso de que tengamos la característica la instalaremos :\nAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 Por defecto el servicio estará parado así que lo arrancamos :\nPodemos configurarlo para que arranque automáticamente al reiniciar el equipo :","tags":["Windows","Sistemas","ISO","ASO"],"title":"Configuración servicio ssh en Windows"},{"categories":null,"contents":" Configuración servidor DHCP bajo debian En este artículo aprenderás cómo configurar el servidor DHCP isc-dhcp-server. Además, configurarás una reserva y lo configuraras para que funcione en dos ámbitos.\nInstalación del servidor isc-dhcp-server Para instalar nuestro servidor dhcp ejecutamos:\nNos dará el siguiente error ya que no esta configurado :\nConfiguración del servidor isc-dhcp-server Lo primero que tenemos que hacer es configurar el interfaz de red por el que va a trabajar el servidor dhcp, para ello editamos el siguiente fichero:\nY añadimos nuestra interfaz que repartirá direcciones :\nConfigura el servidor dhcp con las siguientes características:\nRango de direcciones a repartir: 192.168.0.100 - 192.168.0.110 Máscara de red: 255.255.255.0 Duración de la concesión: 1 hora Puerta de enlace: 192.168.0.1 Servidores DNS: 8.8.8.8 Para ello editamos el siguiente archivo :\nAhora añadimos lo siguiente :\nAquí estamos configurando nuestro ámbito conforme al enunciado .\nAhora deberemos de reiniciar el servicio con el siguiente comando :\nConfiguraciòn de los clientes para obtener un direccionamiento dinámico Editaremos la configuración de red para que use el dhcp :\nEn el debian editamos el network/interfaces:\nAhora reiniciamos la tarjeta de red :\nAhora comprobaremos si nos a asignado ip con ipconfig:\nVemos que se ha asignado correctamente . Repetiremos lo mismo con nuestro cliente windows .\nConfiguramos la tarjeta de red para que utilice el protocolo dhcp, reiniciamos la tarjeta y comprobamos la ip que nos ha asignado :\nAhora vamos a comprobar las concesiones de direcciones para ello deberemos ver el siguiente archivo . Lo abriremos con cat ya que es importante no editarlo , puede causar problemas .\nReserva de una direccion IP Para ello deberemos editar el archivo de configuración de nuestro servidor dhcp :\nUna vez aquí vamos a añadir las siguientes lineas :\nNombre de la reserva hardware Ethernet: Es la dirección MAC de la tarjeta de red del host. fixed-address: La dirección IP que le vamos a asignar. Quedaría nuestra reserva así(la pondremos fuera de la configuración de nuestro ámbito):\nAhora reiniciaremos el servicio\nVamos a comprobar que se ha realizado la concesión , para ello nos vamos a windows . Es posible que tengamos que renovar la concesión o reiniciar la tarjeta de red .\nVamos a comprobar qué ocurre con la configuración de los clientes en determinadas circunstancias, para ello vamos a poner un tiempo de concesión muy bajo . Le pondré 1 min .\n1.Los clientes toman una configuración, y a continuación apagamos el servidor dhcp. ¿Qué ocurre con el cliente windows? ¿Y con el cliente Linux?\nEn windows nos asignara una dirección de APIPA\nMientras que en Linux no me asigna ninguna dirección ip , aunque después me asigno una dirección de APIPA\n¿Que ocurre cuando modificamos la configuraciòn? Los clientes toman una configuración, y a continuación cambiamos la configuración del servidor dhcp (por ejemplo, el rango). ¿Qué ocurre con el cliente windows? ¿Y con el cliente Linux?\nModificamos el rango :\nY reiniciamos el servicio\nCon windows mantengo la dirección de la reserva :\nY con Linux nos asigna la dirección del nuevo rango :\nConfigurar dos ambitos Realizar las modificaciones necesarias en la configuración actual de nuestro servidor dhcp para que reparta direcciones ip a dos redes diferentes, la 192.168.0.0 y la 192.168.2.0.\nLo primero que haremos sera añadir una cuarta tarjeta de red y la configuraremos manualmente . Si no sabemos el nombre de la interfaz podemos verlo con ip a :\nAhora la configuraremos estática , siguiendo el enunciado y la añadimos al /etc/default/isc-dhcp-server.\nY configuramos nuestro segundo rango :\nAhora reiniciamos el servicio :\nAhora le añadiré varias tarjetas de red a mi cliente para comprobar las concesiones y configuramos las tarjetas :\nY nos habría concedido dirección ip en ambos rangos :\n","date":"September 8, 2023","hero":"/images/servicios/dhcp_v4/isc-dhcp.webp","permalink":"https://www.javiercd.es/posts/servicios/dhcp/dhcp_ipv4/","summary":"Configuración servidor DHCP bajo debian En este artículo aprenderás cómo configurar el servidor DHCP isc-dhcp-server. Además, configurarás una reserva y lo configuraras para que funcione en dos ámbitos.\nInstalación del servidor isc-dhcp-server Para instalar nuestro servidor dhcp ejecutamos:\nNos dará el siguiente error ya que no esta configurado :\nConfiguración del servidor isc-dhcp-server Lo primero que tenemos que hacer es configurar el interfaz de red por el que va a trabajar el servidor dhcp, para ello editamos el siguiente fichero:","tags":["Servicios","NAT","SMR","DHCP","SNAT"],"title":"Configuración servidor DHCP bajo debian"},{"categories":null,"contents":" Configuración servidor DNS en Debian Dnsmasq El paquete dnsmasq permite poner en marcha un servidor DNS de una forma muy sencilla. Simplemente instalando y arrancando el servicio dnsmasq, sin realizar ningún tipo de configuración adicional, nuestro PC se convertirá en un servidor caché DNS y además, resolverá los nombres que tengamos configurados en el archivo /etc/hosts de nuestro servidor. La resolución funcionará tanto en sentido directo como en sentido inverso, es decir, resolverá la IP dado un nombre de PC y el nombre del PC dada la IP.\nInstalación Para instalarlo solo sera necesario introducir el siguiente comando :\nConfiguración A continuación, editamos el fichero /etc/dnsmasq.conf y modificamos las siguientes líneas:\n1.Descomentamos strict-order para que se realicen las peticiones DNS a los servidores que aparecen en el fichero /etc/resolv.conf en el orden en él aparecen.\n2.Incluimos las interfaces de red que deben aceptar peticiones DNS, descomentar la línea interface por ejemplo: interface=eth0\nAhora crearemos nuestro archivo de configuración :\n3.Creamos el fichero de configuración de nuestra zona :\n4.El dominio que hemos elegido es iesgn.org\n5.Suponemos que el nombre del servidor es miservidor.\n6.Vamos a suponer que tenemos un servidor ftp que se llame ftp.iesgn.org y que está en 192.168.1.201 (esto es ficticio) y que tenemos dos sitios webs: www.iesgn.org y departamentos.iesgn.org.\n7.Además queremos nombrar al cliente que tenía asignada una reserva: lisa.\n8.Reiniciamos el servicio\nModificacion en el servidor DHCP Configura los clientes e indica que su DNS es nuestro servidor. Si tienes un servidor DHCP modificarlo para que envíe el nuevo DNS a los clientes.\nEditamos el fichero :\nY reiniciamos el servicio :\nAhora comprobaremos si el cliente nos ha cambiado el dns mirando el siguiente archivo :\nSe nos ha cambiado satisfactoriamente .\nComandos para comprobar funcionamiento dns Comprueba el funcionamiento usando el comando dig/nslookup desde los clientes preguntando por los distintos nombres. Comprueba que el servidor DNS hace de forwarder preguntando con dig/nslookup la dirección ip de www.josedomingo.org.\nPara la pagina de Jose domingo la respuesta es no autorizada porque nuestro servidor no tiene la resolución en su fichero y tiene que utilizar un forwarder\nComo ves arriba yo he creado mi propia zona y a pesar de haber seguido los pasos de esta pagina de Jose domingo , no he conseguido que las respuestas estén autorizadas .\nHe creado el archivo dns.conf .\nY he creado mi zona :\nTambién he probado mas cosas sin embargo la única forma que he conseguido que me de respuesta autorizada es teniendo solo las resoluciones en el fichero host del servidor , sin crear mi zona .\nDNS BIND 9 Instalación Lo primero que haremos sera desinstalar dnsmasq ya que ambos no son compatibles :\nAdemas podemos ver que nos dice que el directorio /etc/dnsmasq.d/ al no estar vació no se ha borrado seria bueno que lo borrásemos manualmente para eliminar todo rastro de anteriores configuraciones :\nAhora vamos a instalarlos bind:\nConfiguración Ahora vamos a editar el fichero /etc/bind/named.conf.local donde crearemos las zonas (directas e inversas). En el caso de la práctica nos piden una directa (isgn.com) y otra inversa (red 192.168.1).\nAñadiremos las siguientes líneas a dicho fichero :\nEn el directorio / etc/bind están los ficheros db.empty y db.127 (ficheros de configuración de la zona directa e inversa respectivamente). Los copiamos al directorio / var/cache/bind para empezar a añadir los registros\nModificamos el fichero / var/cache/bind/db.isgn e incluimos las siguientes líneas para la resolución directa :\n*javiercruces es el nombre de mi maquina lo he cambiado para facilitar las cosas\nAhora haremos lo mismo para la resolución inversa :\nAhora reiniciaremos el servicio para que se apliquen los cambios :\nAdemas para asegurarnos de que hemos realizado bien la configuración vamos a mirar el estado del servicio para ver si nuestras zonas están funcionando :\nEste paso es opcional , pero gracias a revisar esto he descubierto porque no me hacia la resolución inversa y gracias a ver las zonas que estaban cargadas me di cuenta de que el error estaba en el fichero de configuración /etc/bind/named.conf.local y pude solucionarlo .\nReenviador Hasta ahora, sólo nos resolvería los nombres e ip de nuestra red local. Si queremos configurar un reenviador al que preguntar en caso de que el DNS local no pueda darnos la respuesta, debemos editar el fichero nano / etc/bind/named.conf.options y añadir lo siguiente:\nAntes de hacer este apartado aclarar que como en el apartado de dnsmasq ya comentamos el fichero host y modificamos la configuración del dhcp para que asigne el dns automáticamente , lo omitiré de esta parte.\nComandos para comprobar el funcionamiento del servicio Comprueba el funcionamiento usando el comando dig/nslookup desde los clientes preguntando por los distintos nombres. Comprueba que el servidor DNS hace de forwarder preguntando con dig/nslookup la dirección ip de www.josedomingo.org .\nVemos aquí que las respuestas son correctas , las que están en nuestro servidor estas autorizadas mientras que la pagina de Jose domingo nos la ha echo un forwarder .\nAhora haré las mismas peticiones pero inversas :\nCon esto hemos comprobado que el servidor dns funciona correctamente .\n","date":"September 8, 2023","hero":"/images/servicios/dns/portada-dns.jpg","permalink":"https://www.javiercd.es/posts/servicios/dns/dns/","summary":"Configuración servidor DNS en Debian Dnsmasq El paquete dnsmasq permite poner en marcha un servidor DNS de una forma muy sencilla. Simplemente instalando y arrancando el servicio dnsmasq, sin realizar ningún tipo de configuración adicional, nuestro PC se convertirá en un servidor caché DNS y además, resolverá los nombres que tengamos configurados en el archivo /etc/hosts de nuestro servidor. La resolución funcionará tanto en sentido directo como en sentido inverso, es decir, resolverá la IP dado un nombre de PC y el nombre del PC dada la IP.","tags":["Servicios","NAT","SMR","DHCP","SNAT","DNS","BIND9","DNSMASQ"],"title":"Configuración servidor DNS en Debian"},{"categories":null,"contents":"\rLos empaquetadores y compresores son elementos fundamentales en la gestión de archivos y datos en el ámbito informático. Los empaquetadores permiten agrupar varios archivos en un solo contenedor, facilitando su manipulación y transporte. Por otro lado, los compresores aplican técnicas para reducir el tamaño de los archivos, contribuyendo al ahorro de espacio de almacenamiento y agilizando la transferencia de datos. Estas herramientas desempeñan un papel crucial en la optimización de recursos y la eficiencia operativa al organizar, distribuir y respaldar información de manera más eficaz.\nTAR Es un empaquetador de archivos que como su propio nombre indica utiliza el formato .tar, básicamente se utiliza para almacenar ficheros y directorios en un mismo archivo.\nEl nombre del paquete es tar .\nCrear un archivo .tar Puedes crear compresiones .tar tanto para un archivo como para directorios. Un ejemplo de este tipo de archivo es:\ntar -cvf sampleArchive.tar /home/sampleArchive Aquí /home/sampleArchive es el directorio que necesita ser comprimido creandosampleArchive.tar. Este comando usa las opciones –cvf que significan:\nc – crear un nuevo archivo .tar v – muestra una descripción detallada del progreso de la compresión f – nombre del archivo Crear un archivo .tar.gz Si deseas una mejor compresión, también puedes usar .tar.gz. Un ejemplo de esto es:\ntar -cvzf sampleArchive.tar.gz /home/sampleArchive La opción adicional z representa la compresión gzip. Alternativamente, puedes crear un archivo .tgz que sea similar a tar.gz. Te mostramos un ejemplo de esto último a continuación:\ntar -cvzf sampleArchive.tgz /home/sampleArchive Crear un archivo .tar.bz2 El archivo .bz2 proporciona más compresión en comparación con gzip. Sin embargo, esta alternativa tomará mas tiempo para comprimir y descomprimir. Para usarla, debes usar la opción -j. Un ejemplo de cómo se vería la operación es el siguiente:\ntar -cvjf sampleArchive.tar.bz2 /home/sampleArchive Dicha operación es similar a .tar.tbz o .tar.tb2. Te muestro un ejemplo a continuación:\ntar -cvjf sampleArchive.tar.tbz /home/sampleArchive tar -cvjf sampleArchive.tar.tb2 /home/sampleArchive Cómo descomprimir archivos .tar El comando Tar de Linux también se puede utilizar para extraer un archivo. El siguiente comando extraerá los archivos en el directorio actual:\ntar -xvf sampleArchive.tar Si deseas extraer tus archivos a un directorio diferente, puedes usar la opción -C. Te mostramos un ejemplo de esto a continuación:\ntar -xvf sampleArchive.tar -C /home/ExtractedFiles/ Puedes usar un comando similar para descomprimir archivos .tar.gz, tal como se muestra a continuación:\ntar -xvf sampleArchive.tar.gz tar -xvf sampleArchive.tar.gz -C /home/ExtractedFiles/ Los archivos .tar.bz2 o .tar.tbz o .tar.tb2 pueden descomprimirse de manera similar. Para esto deberás teclear el siguiente comando en la línea de comando:\ntar -xvf sampleArchive.tar.bz2 Cómo listar el contenido de un archivo .tar Una vez que hayas creado el archivo, puedes listar el contenido mediante un comando similar al siguiente:\ntar -tvf sampleArchive.tar Esto mostrará la lista completa de archivos junto con las marcas de tiempo y los permisos. Del mismo modo, para .tar.gz, puedes usar un comando como:\ntar -tvf sampleArchive.tar.gz Esto también funcionaría para archivos .tar.bz2 como se muestra a continuación: tar -tvf sampleArchive.tar.bz2\nCómo descomprimir un único archivo .tar Una vez que creas un archivo comprimido, puedes extraer un único archivo de ese comprimido. Esto lo puedes lograr con el comando que te mostramos a continuación:\ntar -xvf sampleArchive.tar example.sh Aquí example.sh es un archivo único que se extraerá del comprimido sampleArchive.tar. Alternativamente, también puedes usar el siguiente comando:\ntar --extract --file= sampleArchive.tar example.sh Para extraer un solo archivo de un comprimido .tar.gz puedes usar un comando similar al mostrado a continuación:\ntar -zxvf sampleArchive.tar.gz example.sh O alternativamente:\ntar --extract --file= sampleArchive.tar.gz example.sh Para extraer un solo archivo de un comprimido .tar.bz2 puedes usar un comando como este:\ntar -jxvf sampleArchive.tar.bz2 example.sh O, alternativamente, uno como este:\ntar --extract --file= sampleArchive.tar.bz2 example.sh Cómo extraer múltiples archivos de los archivos .tar En caso de que desees extraer varios archivos, usa el siguiente formato del comando:\ntar -xvf sampleArchive.tar \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Para .tar.gz puedes usar:\ntar -zxvf sampleArchive.tar.gz \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Para .tar.bz2 puedes usar:\ntar -jxvf sampleArchive.tar.bz2 \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Extraer múltiples archivos con un patrón Si deseas extraer del comprimido patrones específicos de archivos como solo los .jpg, usa el comando wildcards. Una muestra de dicho comando se muestra a continuación:\ntar -xvf sampleArchive.tar --wildcards \u0026#39;\\*.jpg\u0026#39; Para .tar.gz puedes usar:\ntar -zxvf sampleArchive.tar.gz --wildcards \u0026#39;\\*.jpg\u0026#39; Para .tar.bz2 puedes usar:\ntar -jxvf sampleArchive.tar.bz2 --wildcards \u0026#39;\\*.jpg\u0026#39; Cómo agregar archivos a un archivo .tar Si bien puedes extraer archivos específicos, también puedes agregar archivos nuevos a un archivo comprimido existente. Para hacerlo, debes usar la opción -r que significa agregar. El comando Tar puede agregar tanto archivos como directorios.\nA continuación se muestra un ejemplo en el que estamos agregando example.jpg al sampleArchive.tar existente.\ntar -rvf sampleArchive.tar example.jpg También podemos agregar un directorio. En el ejemplo que te mostramos a continuación, el directorio image_dir se agrega al archivo sampleArchive.tar\ntar -rvf sampleArchive.tar image\\_dir No puedes agregar archivos o carpetas a comprimidos .tar.gz o .tar.bz2.\nCómo verificar un archivo .tar Usando Tar puedes verificar un archivo. Esta es una de las formas en que puedes hacerlo:\ntar -tvf sampleArchive.tar Esto no se puede aplicar en archivos .tar.gz o .tar.bz2.\nCómo verificar el tamaño del archivo .tar Una vez que crees un archivo, puedes verificar su tamaño. Este se mostrará en KB (Kilobytes).\nA continuación te mostramos varios ejemplos del comando a usar para verificar el tamaño de diferentes tipos de archivos comprimidos:\ntar -czf - sampleArchive.tar | wc -c tar -czf - sampleArchive.tar.gz | wc -c tar -czf - sampleArchive.tar.bz2 | wc -c GZIP Puede comprimir un archivo usando gzip con el comando llamado gzip . El nombre de este paquete es gzip .\nEste es el uso más simple: gzip filename\nEsto comprimirá el archivo y agregará un .gz extensión a ella. Se elimina el archivo original. Para evitar esto, puede utilizar el- c y use la redirección de salida para escribir la salida en elfilename.gzexpediente:\ngzip -c filename \u0026gt; filename.gz los -c La opción especifica que la salida irá al flujo de salida estándar, dejando el archivo original intacto o puede usar el -k opción:\ngzip -k filename Hay varios niveles de compresión. Cuanto mayor sea la compresión, más tiempo llevará comprimir (y descomprimir). Los niveles van de 1 (más rápido, peor compresión) a 9 (más lento, mejor compresión), y el valor predeterminado es 6.\nPuede elegir un nivel específico con el - opción:\ngzip -1 filename Puede comprimir varios archivos enumerándolos:\ngzip filename1 filename2 Puede comprimir todos los archivos de un directorio, de forma recursiva, utilizando el -r :\ngzip -r folder gziptambién se puede utilizar para descomprimir un archivo, utilizando el -d opción:\ngzip -d filename.gz BZIP2 El bzip2 es muy similar al programa gzip. La principal diferencia es que utiliza un algoritmo de compresión diferente llamado algoritmo de compresión de texto de clasificación de bloques Burrows-Wheeler y codificación Huffman. Los archivos comprimidos con bzip2 finalizarán con la extensión .bz2.\nComo dije, el uso de bzip2 es casi lo mismo que gzip. Simplemente tendremos que reemplazar gzip en los ejemplos anteriores por bzip2, gunzip por bunzip2, zcat con bzcat y así sucesivamente.\nPara comprimir un archivo usando bzip2, reemplazándolo por una versión comprimida, ejecutaremos:\nbzip2 prueba.txt # Nos creara un archivo prueba.txt.bz2 Comprimir los archivos sin eliminar el archivo original\nSi no queremos reemplazar el archivo original, utilizaremos la opción -c y escribiremos el resultado en un nuevo archivo.\nBzip2 -c prueba.txt # prueba.txt.bz2 Descomprimir archivos\nPara descomprimir un archivo comprimido utilizaremos alguna de las dos siguientes posibilidades:\nbzip2 -d prueba.txt.bz2 bunzip2 prueba.txt.bz2 Ver el contenido de los archivos comprimidos sin descomprimirlos\nPara ver el contenido de un archivo comprimido sin descomprimirlo, no tendremos más que utilizar cualquiera de las opciones:\nbunzip2 -c ubunlog.txt.bz2 bzcat ubunlog.txt.bz2 XZ El paquetes es xz-utils\nComprimir\nEl ejemplo más simple de compresión de un archivo con xz es el siguiente. Compresión de archivos con XZ\nxz deb.iso También se puede utilizar la opción -z para realizar la compresión:\nxz -z deb.iso Estas órdenes comprimirán el fichero, pero eliminará el archivo origen. Si no buscamos borrar los archivos de origen, usaremos la opción -k de la siguiente manera:\nxz -k deb.iso Descomprimir\nPara descomprimir un archivo, vamos a poder utilizar la opción -d:\nxz -d deb.iso unxz deb.iso Forzar compresión\nSi una operación falla, por ejemplo, si existe un archivo comprimido con el mismo nombre, usaremos la opción -f para forzar el proceso:\nxz -kf deb.iso Establecer niveles de compresión\nEsta herramienta admite diferentes niveles preestablecidos de compresión (de 0 a 9. Con un valor predeterminado de 6). También vamos a poder utilizar alias como –fast (será rápido, pero con menos compresión) para establecer como valor 0 y –best para establecer como valor 9 (compresión lenta pero más alta). Algunos ejemplos de cómo establecer estos niveles, son los siguientes:\nxz -k -8 deb.iso xz -k --best deb.iso Limitar la memoria\nEn caso de tener una cantidad pequeña de memoria del sistema y querer comprimir un archivo enorme, vamos a tener la posibilidad de utilizar la opción -memory = límite (el valor límite puede estar en MB o como porcentaje de RAM) para establecer un límite de uso de memoria para la compresión:\nxz -k --best --memlimit-compress=10% deb.iso Habilitar modo silencioso\nSi nos interesa ejecutar la compresión en modo silencioso solo habrá que añadir la opción -q. También podremos habilitar el modo detallado con -v, como se muestra a continuación:\nxz -k -q deb.iso xz -k -qv deb.iso Crear un archivo tar.xz\nEl siguiente es un ejemplo del uso para conseguir un archivo con la extensión tar.xz.\ntar -cf *.txt | xz -7 \u0026gt; deb.tar.xz Crear un archivo tar.xz opción 2\ntar -cJf deb.tar.xz *.txt Comprobar la integridad de los archivos comprimidos\nPodremos probar la integridad de los archivos comprimidos utilizando la opción -t. Utilizando -l podremos ver la información sobre un archivo comprimido.\nxz -t deb.tar.xz xz -l deb.tar.xz 7Z Este compresor cuenta con dos paquetes :\np7zip ofrece soporte para 7zr (una versión ligera de 7z y 7za). Permite comprimir y descomprimir paquetes en estos formatos mediante la herramienta gráfica de tu sistema (file-roller en Ubuntu y Debian) pero no dispone de la funcionalidad de cifrado. p7zip-full es, por decirlo de algún modo, la versión más completa. Soporta los formatos 7z y 7za e incorpora la funcionalidad de cifrado, además de las herramientas para la compresión ZIP Comprimir Uno o Varios Archivos\nEl formato es siempre es la misma, consiste en colocar 7z, seguido de la opción a (para comprimir o empaquetar), seguido del nombre que quieres dar al paquete final (no hace falta colocar la extensión .7z) y acabando con el nombre del archivo a comprimir. Podrás observar que 7-Zip es capaz de aprovechar todos los núcleos de tu procesador durante la operación.\n7z a paquete-comprimido archivo-a-comprimir 7z a paquete-comprimido archivo-1 archivo-2 Si queremos ponerle contraseña utilizamos el parámetro -p :\n7z a -p paquete-comprimido archivo-a-comprimir 7-Zip soporta varios formatos de compresión o empaquetado, aparte del suyo propio, con esta sentencia podrás optar por indicar explícitamente que formato quieres utilizar (puedes escoger entre 7z, zip, gzip, bzip2 o tar).\n7z a -tgzip paquete-comprimido archivo-a-comprimir Listar Contenido de la Carpeta Comprimido\nOtra opción interesante puede ser listar el contenido dentro de un archivador y ver los detalles. Para ello tienes que situarte igualmente en el directorio en el que se encuentra el archivador o carpeta comprimida y teclear la siguiente sentencia.\n7z l paquete-comprimido.7z Descomprimir Paquete y Extraer Ficheros\nUna vez conocido el contenido dentro del archivador, para extraer de golpe todo el contenido dentro del directorio de trabajo actual, puedes valerte del siguiente comando:\n7z e paquete-comprimido.7z Comprobar Integridad de los Datos\nComo opción adicional, también puedes comprobar la integridad de los diferentes archivos que se encuentran dentro del fichero comprimido. Para ello utiliza esto:\n7z t paquete-comprimida.7z RAR El paquete para instalarlo es rar .\nCómo comprimir RAR en Linux\nPara comprimir un fichero o todos los de una carpeta:\nrar a nombre_fichero_comprimido.rar nombre_fichero_a_comprimir rar a nombre_fichero_comprimido.rar Cómo descomprimir RAR en Linux\nY para descomprimir en el mismo directorio o en otro diferente:\nunrar x nombre\\_del\\_rar.rar unrar x nombre\\_del\\_rar.rar /ruta/destino/descomprimido ZIP El nombre del paquete es zip.\nPara comprimir archivos :\nzip archivo.zip archivos Para descomprimir archivos :\nunzip archivo.zip Ver contenido :\nunzip -v archivo.zip Bibliografía Guía comando tar Guía comando gzip Guía comando bzip2 Guía xz Guía comando 7z Guía comando rar ","date":"September 8, 2023","hero":"/images/sistemas/empaquetadores/portada.jpg","permalink":"https://www.javiercd.es/posts/sistemas/empaquetadores_compresores/empaquetadores-compresores-descompresores/","summary":"Los empaquetadores y compresores son elementos fundamentales en la gestión de archivos y datos en el ámbito informático. Los empaquetadores permiten agrupar varios archivos en un solo contenedor, facilitando su manipulación y transporte. Por otro lado, los compresores aplican técnicas para reducir el tamaño de los archivos, contribuyendo al ahorro de espacio de almacenamiento y agilizando la transferencia de datos. Estas herramientas desempeñan un papel crucial en la optimización de recursos y la eficiencia operativa al organizar, distribuir y respaldar información de manera más eficaz.","tags":["Linux","Sistemas","ISO","ASO"],"title":"Empaquetadores y compresores en Linux"},{"categories":null,"contents":"\rEn esta práctica, exploraremos la creación de un escenario mediante la orquestación de OpenStack y, posteriormente, llevaremos a cabo el enrutamiento para asegurar la conectividad entre las distintas máquinas virtuales. Este ejercicio nos permitirá comprender y aplicar el uso de OpenStack para gestionar entornos virtuales, además de configurar la red de manera eficiente para facilitar la comunicación entre los diferentes dispositivos en el escenario.\nEscenario a montar en OpenStack Para poder montar nuestro escenario en OpenStack debido a la situación actual de las imágenes que hay disponibles , necesitaremos preparar una instancia la cual tenga habilitado el acceso por contraseña . Además si posteriormente a partir de una queremos configurar otra habilitar el acceso ssh por contraseña para este usuario .\nEsta tendremos que crearla con el mismo flavour con las que generaremos el escenario para evitar errores .\nCuanto tengamos a punto nuestra instancia comprobaremos que puedes iniciar sesión desde horizon :\nAhora crearemos una instantánea :\nCopiaremos el ID de las instantánea :\nY lo añadiremos al fichero :\nY lo desplegaremos :\nVemos que se ha creado correctamente :\nEsquema gráfico de la configuración El esquema quedaría de la siguiente manera :\nTeniendo la siguiente relación de IPS :\nMAQUINA IP INTERFAZ PC1 10.0.100.144 ens3 R1-PC1 10.0.100.68 ens3 R1-R2 10.0.110.78 ens4 R2-R1 10.0.110.30 ens3 R2-PC2 10.0.120.191 ens4 PC2 10.0.120.203 ens3 R2-R3 10.0.130.146 ens5 R3-R2 10.0.130.36 ens3 R3-PC3 10.0.140.127 ens4 PC3 10.0.140.158 ens3 Tablas de enrutamiento\nR1 10.0.100.0/24 0.0.0.0 ens3 10.0.110.0/24 0.0.0.0 ens4 10.0.120.0/24 10.0.110.30 ens4 10.0.130.0/24 10.0.110.30 ens4 10.0.140.0/24 10.0.110.30 ens4 0.0.0.0/0 10.0.110.30 ens4 *Las redes en las que estamos directamente conectados se crearan automáticamente las rutas.\nR2 10.0.100.0/24 10.0.110.178 ens3 10.0.110.0/24 0.0.0.0 ens3 10.0.120.0/24 0.0.0.0 ens4 10.0.130.0/24 0.0.0.0 ens5 10.0.140.0/24 10.0.130.36 ens5 0.0.0.0/0 10.0.130.36 ens5 *Las redes en las que estamos directamente conectados se crearan automáticamente las rutas.\nR3 10.0.100.0/24 10.0.130.146 ens3 10.0.110.0/24 10.0.130.146 ens3 10.0.120.0/24 10.0.130.146 ens3 10.0.130.0/24 0.0.0.0 ens3 10.0.140.0/24 0.0.0.0 ens4 0.0.0.0/0 10.0.130.146 ens4 Comandos de configuración de cada nodo Router 1 Como es un router deberemos de activar el bit de forwarding para ello introduciremos el siguiente comando :\necho 1 \u0026gt; /proc/sys/net/ipv4/ip\\_forward Crearemos la tabla de enrutamiento :\nLas rutas estáticas :\nip route add 10.0.100.0/24 via 0.0.0.0 dev ens3 La ruta por defecto:\nip route add default via 10.0.110.30 dev ens4 Nos quedaría así la tabla de enrutamiento :\nPC1 Borraremos la ruta por defecto que exista en el dispositivo\nY añadiremos la nueva ruta\nRouter 2 Como es un router deberemos de activar el bit de forwarding para ello introduciremos el siguiente comando :\necho 1 \u0026gt; /proc/sys/net/ipv4/ip\\_forward Crearemos la tabla de enrutamiento :\nQuedaría así :\nPC2** Al igual que hicimos anteriormente eliminaremos la ruta por defecto que trae y la añadiremos la nueva :\nActivaremos el bit de forwarding con el siguiente comando :\necho 1 \u0026gt; /proc/sys/net/ipv4/ip\\_forward Crearemos la tabla de enrutamiento para nuestro escenario :\nLa tabla de enrutamiento quedaría así :\nPC3 Al igual que con los demás deberemos de cambiar la ruta por defecto por la ip del router a la que estamos conectado :\nResumen de configuración y aclaraciones Para los routers Activar el bit de forwarding Crear las tablas de enrutamiento Modificar la ruta por defecto Para los PCs Modificar la ruta por defecto Lo de modificar la ruta por defecto , es debido a que no puedo modificar la configuración de las tarjetas de red por lo que no puedo modificar la puerta de enlace .\nPor defecto al utilizar el script esta viene con la puerta de enlace X.X.X.1 sin embargo esta no coincide con la puerta de enlace de los clientes .\nPara los routers debemos de modificarla también para indicar por donde mandaremos el trafico “por defecto”.\nSi queremos hacer que el bit del forwarding se guarde permanentemente para que cuando reiniciemos el equipo este no vuelva a 0 :\n–\u0026gt; Escribimos directamente en el archivo /etc/sysctl.conf:\nSi queremos volcar en un archivo la configuración de las tablas de enrutamiento para tener una copia de seguridad de las mismas usamos :\nSi queremos restaurar la copia :\nVerificación de conectividad (ping) entre nodos PC1 PC1 – PC2\nPC1-PC3\nPC2 PC2-PC1\nPC2-PC3\nPC3 PC3-PC1\nPC3-PC2\nCaptura de tráfico en el router r2 o r3 mostrando tráfico entre h1 y h3. Para hacer una captura de una determinada interfaz y guardarla en un archivo utilizaremos tcpdump:\ntcpdump -i NOMBRE\\_INTERFAZ -w NOMBRE\\_ARCHIVO Si queremos tener una salida al comando en lugar de guardar el archivo usaremos el parámetro -n: Aquí vemos como llegan los ICMP REQUEST de PC3 a PC1 y los ICMP REPLY DE PC1 a PC3\nAdemás he capturado una petición y respuesta arp de PC3:\nBibliografía Como hacer tablas de enrutamiento ","date":"September 8, 2023","hero":"/images/redes/enrutamiento_os/portada.png","permalink":"https://www.javiercd.es/posts/redes/enroutamiento_openstack/enroutamiento_openstack/","summary":"En esta práctica, exploraremos la creación de un escenario mediante la orquestación de OpenStack y, posteriormente, llevaremos a cabo el enrutamiento para asegurar la conectividad entre las distintas máquinas virtuales. Este ejercicio nos permitirá comprender y aplicar el uso de OpenStack para gestionar entornos virtuales, además de configurar la red de manera eficiente para facilitar la comunicación entre los diferentes dispositivos en el escenario.\nEscenario a montar en OpenStack Para poder montar nuestro escenario en OpenStack debido a la situación actual de las imágenes que hay disponibles , necesitaremos preparar una instancia la cual tenga habilitado el acceso por contraseña .","tags":["Redes","Enrutamiento"],"title":"Enrutamiento en OpenStack"},{"categories":null,"contents":" Servidor FTP bajo debian Instalación y configuración del servidor proFTPd autentificado 1.Primero nos crearemos un grupo que se llame ftpgroup : 2.Crea dos usuarios locales que pertenezcan al grupo ftp que hemos creado: Jose y Maria\n3.Nos instalamos el servicio ftp :\n4.Configuración básica del fichero proftpd.conf:\nTodos los usuarios accedan solo a su directorio :\nAhora podemos acceder desde el navegador con los usuarios Jose y Maria :\nCada uno de estos he creado una carpeta con su nombre dentro de sus directorios personales para poder identificarlos .\nPara que cada usuario pueda conectarse realmente al servidor FTP en Debian y le sea posible subir y descargar los datos en su propio directorio, debes introducir su directorio de entrada en proftpd.conf :\nPodemos transferir archivos correctamente :\nConfiguración de proFTPd para crear ftp anónimo Lo primero que tenemos que hacer es crear el directorio y darle el propietario adecuado:\nAhora cambiaremos esta regla y permitiremos que todos puedan unirse :\nAdemas añadimos las siguientes lineas e indicaremos la ruta a la que accederán los anónimos :\nPor lo que cuando reiniciemos podrán conectarse los usuarios anónimos :\nPero no con los usuarios que hemos creado anteriormente :\nPara permitir que nuestros usuarios se puedan conectar ademas de los anónimos:\nAhora aplicamos estos cambios y probamos a conectarnos . Vemos que con anónimos no podemos copiar nada al servidor pero si podemos descargar.\nAhora con un usuario del grupo , podremos copiar archivos :\n","date":"September 8, 2023","hero":"/images/servicios/ftp/portada-ftp.png","permalink":"https://www.javiercd.es/posts/servicios/ftp/ftp/","summary":"Servidor FTP bajo debian Instalación y configuración del servidor proFTPd autentificado 1.Primero nos crearemos un grupo que se llame ftpgroup : 2.Crea dos usuarios locales que pertenezcan al grupo ftp que hemos creado: Jose y Maria\n3.Nos instalamos el servicio ftp :\n4.Configuración básica del fichero proftpd.conf:\nTodos los usuarios accedan solo a su directorio :\nAhora podemos acceder desde el navegador con los usuarios Jose y Maria :","tags":["Servicios","NAT","SMR","IPTABLES","SNAT","SSH","FORWARDING","APACHE","FTP"],"title":"FTP bajo debian "},{"categories":null,"contents":"\rEn el ecosistema de Linux, un proceso es la ejecución de un programa específico que realiza una tarea particular. Cada proceso tiene su propio identificador único (PID) y está compuesto por un conjunto de recursos, como memoria y CPU, que le permiten funcionar de manera independiente.\nEn el universo de Linux, la gestión efectiva de procesos es una habilidad crucial para optimizar el rendimiento y asegurar la estabilidad del sistema. Este post te sumergirá en los fundamentos esenciales de la gestión de procesos\nPS Si no añadimos ningún parámetro, ps mostrará los procesos del usuario con el que estamos logueados. Por otra parte, los parámetros más básicos a conocer son los siguientes:\naux : Lista los procesos de todos los usuarios con información añadida (destacamos más abajo).\n-a Lista los procesos de todos los usuarios.\n-u Lista información del proceso como por ejemplo el usuario que lo está corriendo, la utilización de CPU y memoria, etc.\n-x Lista procesos de todas las terminales y usuarios\n-l Muestra información que incluye el UID y el valor «nice«.\n–-forest Muestra el listado procesos en un formato tipo árbol que permite ver como los procesos interactúan entre si, podría ser algo similar al comando pstree.\nPSTREE El programa pstree facilita información sobre la finalización de una serie de procesos relacionados entre sí, esto es, todos los descendientes de un proceso particular. El programa deja claro desde un principio que proceso es el primario y cuales son los secundarios. Esto evita buscar las relaciones entre los diversos procesos de manera manual.\nParámetros comúnmente utilizados :\n-H: Si nos interesa podemos ver el árbol de un proceso específico:\n-g: Nos agrupara los procesos por grupos :\n-n: Nos permite ordenar la salida por el numero de PID:\n-p: Muestra el numero de PID\n-s:Muestra los procesos padres\nSYSTEMCTL STATUS Este comando se utiliza para ver el estado en el que se encuentra un servicio , Específicamente, muestra información sobre si el servicio o unidad está activo o inactivo, y si está en ejecución o detenido. También muestra cualquier mensaje de error o advertencia relacionado con el servicio o unidad. Este comando es útil para verificar el estado de un servicio o unidad en el sistema y para resolver problemas relacionados con ellos.\nTOP Es un programa todo en uno: simultáneamente cumple las funciones de ps y kill. Es un comando de modo consola, por lo que debe iniciarlo desde una terminal .\nDentro de este podemos controlarlo usando las siguientes teclas:\n-k: este comando se usa para enviar una señal a un proceso. Luego, top le preguntará por el PID del proceso, seguido del número de la señal a enviar (predeterminadamente TERM — o 15);\n-M: este comando se usa para ordenar el listado de los procesos de acuerdo a la memoria que usan (campo %MEM);\n-P: este comando se usa para\nordenar el listado de procesos de acuerdo al tiempo de CPU que consumen(campo %CPU; este es el método de ordenamiento predeterminado);\n-u: este comando se usa para mostrar los procesos de un usuario en particular, top le preguntará de cual. Debe ingresar el nombre del usuario.\n-i: este comando actúa como un interruptor; predeterminadamente se muestran todos los procesos, incluso los que están dormidos; este comando asegura que se muestran sólo los procesos que están en curso de ejecución :\nHTOP Htop es la version mejorada y actual de top la cual tiene una interfaz mas amigable y mas funcionalidades las cuales nos ayudaran a la supervisión de procesos . Este se divide en varias partes :\nEl encabezado divide la parte superior de la interfaz en secciones izquierda y derecha. Estos muestran el uso de la CPU/memoria, el espacio de intercambio, el tiempo de actividad de la máquina, las tareas y la carga promedio.\nLa sección superior izquierda muestra una línea para cada núcleo de CPU. Por ejemplo, la captura de pantalla anterior muestra dos núcleos de CPU, con el porcentaje que representa la carga en cada uno.\nTambién puede ver el código de colores proporcionado por htop para identificar qué tipo de procesos utilizan la CPU:\nRojo: porcentaje ocupado por procesos del sistema Azul: porcentaje ocupado por proceso de baja prioridad Verde: porcentaje ocupado por procesos de usuario Las líneas de memoria también usan códigos de colores, esta vez para representar:\nAmarillo: porcentaje ocupado por caché contenido Verde: porcentaje ocupado por la memoria utilizada Azul: porcentaje ocupado por contenido buffer El panel central muestra todos los procesos en ejecución con sus estadísticas asociadas según la utilización de la CPU. Muestra la siguiente información para cada proceso:\nID de proceso (PID) El propietario (Usuario) Consumo de memoria virtual porcentaje de procesador memoria física Para finalizar este programa también es interactivo , abajo tenemos un índice donde podemos comprobar las funciones que nos permite usar :\nAdemás disponemos de varios atajos de teclados :\nu Ordenar procesos por nombre de usuario p Alternar con la ruta del programa F2 o S Entrar en Configuración F3 o / Proceso de búsqueda F5 o t Vista ordenada o de árbol F6 +/- Seleccione el proceso principal para expandir/contraer el árbol F7 o [ Aumentar la prioridad solo para root F8 o ] Prioridad baja (bueno +) F9 o k Matar proceso H Alterna con subprocesos de proceso de usuario K Alterna con subprocesos de proceso del kernel \u0026amp; El símbolo \u0026amp; es un operador de shell en Unix y Linux que permite ejecutar un proceso en segundo plano. Al colocar \u0026amp; al final de un comando, se ejecutará el proceso en segundo plano y se le asignará una tarea en segundo plano. Esto significa que el proceso se ejecutará en paralelo con otras tareas y no bloqueará la terminal o la línea de comandos hasta que finalice.\nJOBS Este comando listara los procesos que se encuentran en segundo pano así como su estado , nos permite saber su PID:\nFG Complementando al comando anterior , este nos permite reanudar en primer plano el último trabajo que fue suspendido.:\nListando con jobs podemos mandar un proceso en especifico a primer plano :\nBG Cuando un comando se está ejecutando puedes suspenderlo usando ctrl-Z. El comando se detendrá inmediatamente, y volverás al shell de la terminal.\nPuedes reanudar la ejecución del comando en segundo plano, así que seguirá ejecutándose pero no te impedirá hacer otro trabajo en la terminal.\nKILL Los procesos de Linux pueden recibir señales y reaccionar a ellas. Esa es una forma en la que podemos interactuar con los programas en ejecución. El programa kill puede enviar una variedad de señales a un programa. No sólo se usa para terminar un programa, como el nombre lo sugiere, sino que es su principal trabajo Por defecto, este manda una señal TERM al identificador de proceso indicado.\nPodemos listar las señales con kill -l :\nMandamos una señal con el parámetro -s seguida del numero de esta y el PID del proceso :\nXKILL Este es el método más sencillo y el más práctico. El cursor del mouse se transformará en una pequeña calavera. Todo lo que resta es hacer clic en la ventana que querés cerrar y voilá. Chau proceso.\nKILLALL Similar al comando kill, killall enviará la señal a múltiples procesos a la vez en lugar de enviar una señal a un identificador de proceso específico . Por ejemplo, puedes tener múltiples instancias del programa top en ejecución, y killall top terminará con todos ellos.\nPuedes especificar la señal, como con kill :\nPor ejemplo podemos matar todos los tops :\nPIDOF Te permite encontrar el ID del proceso de un programa en ejecución:\n-s: Petición única - ordena al programa devolver un único identificador de proceso\nPID BASH echo t$$ → id bash\nEs una forma rápida de encontrar el identificador actual de la bash :\nNICE Ejecuta un comando con una prioridad determinada, o modifica la prioridad a de un proceso (programa en ejecución). Utiliza una prioridad variable que parte de la prioridad del shell y suma o resta valores. Mientras menor es el valor de la prioridad mayor prioridad tiene el proceso.\nEl valor de la prioridad del proceso find aumenta en 5, disminuye su prioridad.\nRENICE Sirve para cambiar la prioridad de un proceso :\nPKILL Este comando nos permite matar un proceso del que conocemos su nombre completo o parte de él. Veamos un ejemplo:\nBibliografía Guía de uso pstree Guía de uso envío de señales Guía de uso htop Guía de uso nice , renice , kill \u0026hellip; ","date":"September 8, 2023","hero":"/images/sistemas/comandos_procesos/portata_procesos.jpg","permalink":"https://www.javiercd.es/posts/sistemas/comandos_procesos/comandos_procesos/","summary":"En el ecosistema de Linux, un proceso es la ejecución de un programa específico que realiza una tarea particular. Cada proceso tiene su propio identificador único (PID) y está compuesto por un conjunto de recursos, como memoria y CPU, que le permiten funcionar de manera independiente.\nEn el universo de Linux, la gestión efectiva de procesos es una habilidad crucial para optimizar el rendimiento y asegurar la estabilidad del sistema.","tags":["Debian 12","Sistemas","ISO","ASO"],"title":"Gestión de Procesos en Linux"},{"categories":null,"contents":" La instalación de los controladores de NVIDIA en el universo de Linux ha sido tradicionalmente un desafío, especialmente en distribuciones como Debian, donde las políticas del software libre a menudo complican el proceso.\nEn este post voy a explicarte una forma sencilla de instalar los drivers de NVIDIA usando los repositorios oficiales de Debian . Además, al final del artículo, aprenderás a instalar una herramienta clave llamada Nvidia Optimus, que te brindará la capacidad de seleccionar qué tarjeta gráfica utilizará tu equipo.\nEsta herramienta es especialmente útil en portátiles, ya que es común que estos dispositivos presenten problemas al emitir video a través de los puertos, una situación que puede ser fácilmente con esta herramienta.\nIdentificación de Nuestra GPU Antes de embarcarnos en la instalación y configuración, es fundamental conocer el hardware de nuestro equipo. Para averiguar qué tarjetas gráficas están disponibles en nuestro sistema, utilizaremos el siguiente comando:\njaviercruces@HPOMEN15:~$ lspci -nn | egrep -i \u0026#34;3d|display|vga\u0026#34; 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA106M [GeForce RTX 3060 Mobile / Max-Q] [10de:2520] (rev a1) 06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Cezanne [Radeon Vega Series / Radeon Vega Mobile Series] [1002:1638] (rev c5) Como se puede apreciar en la salida del comando anterior, mi equipo portátil cuenta con dos tarjetas gráficas. Identificar el modelo es crucial, ya que si optamos por una instalación manual del controlador, necesitaremos el específico para nuestra GPU.\nNo obstante, en Debian contamos con una utilidad que simplifica este proceso, indicándonos qué controlador debemos instalar. Sin embargo, para acceder a esta utilidad, es necesario modificar nuestros repositorios de Debian.\nPara llevar a cabo esta modificación, añadiremos la sección \u0026ldquo;non-free\u0026rdquo; a nuestros repositorios utilizando un editor de texto de nuestra preferencia:\njaviercruces@HPOMEN15:~$ sudo nano /etc/apt/sources.list deb http://deb.debian.org/debian/ bookworm main contrib non-free non-free-firmware Recuerda que cada vez que modifiques este fichero tienes que hacer un update para que se actualice.\njaviercruces@HPOMEN15:~$ sudo apt update -y Con nuestros repositorios debidamente actualizados, procederemos a instalar el script de detección de NVIDIA con el siguiente comando:\njaviercruces@HPOMEN15:~$ sudo apt install nvidia-detect Ahora ejecutaremos el script de NVIDIA; como podrás observar, nos proporcionará información detallada sobre nuestra tarjeta gráfica NVIDIA, así como los diversos controladores compatibles y el paquete de Debian recomendado para la instalación:\njaviercruces@HPOMEN15:~$ nvidia-detect Detected NVIDIA GPUs: 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA106M [GeForce RTX 3060 Mobile / Max-Q] [10de:2520] (rev a1) Checking card: NVIDIA Corporation GA106M [GeForce RTX 3060 Mobile / Max-Q] (rev a1) Your card is supported by all driver versions. Your card is also supported by the Tesla drivers series. Your card is also supported by the Tesla 470 drivers series. It is recommended to install the nvidia-driver package. Instalación del driver recomendado Antes de instalar los controladores, debes obtener los encabezados del kernel adecuados para que el controlador de NVIDIA pueda compilar correctamente.\nEn un sistema típico de 64 bits que utiliza el kernel predeterminado, simplemente ejecutas:\njaviercruces@HPOMEN15:~$ sudo apt install linux-headers-amd64 Para sistemas de 32 bits con el kernel no-PAE, en su lugar, realizarías la siguiente instalación:\njaviercruces@HPOMEN15:~$ sudo apt install linux-headers-686 Una vez instalada las dependencias del driver , instalaremos el mismo :\njaviercruces@HPOMEN15:~$ sudo apt install nvidia-driver -y Durante la instalación, es probable que encuentres una pantalla típicamente azul que te informa sobre un conflicto con el controlador \u0026ldquo;nouveau\u0026rdquo;, el cual es el driver instalado automáticamente por Debian debido a sus características de software libre. Simplemente haz clic en \u0026ldquo;OK\u0026rdquo; en esta pantalla y continúa con el proceso de instalación.\nAl concluir la instalación, será necesario reiniciar tu equipo para cargar el módulo de NVIDIA. Después de reiniciar, puedes verificar si se ha cargado correctamente utilizando el siguiente comando. Utilizando la barra inclinada (/), puedes filtrar la salida escribiendo la palabra \u0026ldquo;nvidia\u0026rdquo;, lo que te llevará directamente a la información relevante de tu tarjeta gráfica, permitiéndote confirmar que el módulo de NVIDIA está cargado.\nTienes que comprobar que en la linea \u0026ldquo;Kernel driver in use\u0026rdquo; , tenga el modulo nvidia .\njaviercruces@HPOMEN15:~$ lspci -knn | less 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA106M [GeForce RTX 3060 Mobile / Max-Q] [10de:2520] (rev a1) DeviceName: NVIDIA Graphics Device Subsystem: Hewlett-Packard Company GA106M [GeForce RTX 3060 Mobile / Max-Q] [103c:88d1] Kernel driver in use: nvidia Kernel modules: nouveau, nvidia_current_drm, nvidia_current Puede que no te hayas dado cuenta pero ahora en tu escritorio tendrás una app llamada nvidia-settings con la cual podrás configurar tu gráfica .\nAdemas si quieres ver desde la linea de comandos información de tu GPU NVIDIA tienes a tu disposición el siguiente comando :\njaviercruces@HPOMEN15:~$ nvidia-smi Fri Dec 29 02:04:58 2023 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 525.125.06 Driver Version: 525.125.06 CUDA Version: 12.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 NVIDIA GeForce ... On | 00000000:01:00.0 Off | N/A | | N/A 42C P5 10W / 80W | 296MiB / 6144MiB | 12% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | 0 N/A N/A 3246 G /usr/lib/xorg/Xorg 117MiB | | 0 N/A N/A 3442 G /usr/bin/gnome-shell 32MiB | | 0 N/A N/A 4807 G ...on=20231218-080113.411000 104MiB | | 0 N/A N/A 5802 G ...RendererForSitePerProcess 38MiB | +-----------------------------------------------------------------------------+ javiercruces@HPOMEN15:~$ ¡Felicidades, Maestro de los Drivers NVIDIA! Has desbloqueado un logro épico en el reino de la informática. No cualquiera es capaz de llegar hasta aquí, no quiero desilusionarte pero ¿has verificado que funcionen los puertos HDMI y DP de tu equipo?\nEn este punto, se abren dos posibles caminos:\nEn el primer escenario, tus puertos funcionan a la perfección sin requerir intervención adicional. Si este es tu caso, felicidades se ve que Dios tiene favoritos .\nSi por el contrario al igual que yo no eres uno de sus elegidos , como acabas de comprobar los puertos no emiten video , en tu monitor veras que no tienes señal a pesar de que en el debian veas que te detecta el monitor.\nAquí se habré un mundo de problemas y incompatibilidades . Puedes tener problema con el sistema de ventanas de tu equipo , te falte alguna librería \u0026hellip;\nNvidia Optimus Después de una extensa investigación, he descubierto una herramienta que facilita, a través de la línea de comandos (CLI), la elección de la tarjeta gráfica que utiliza tu equipo.\nLa herramienta en cuestión es EnvyControl, una utilidad de línea de comandos (CLI) que simplifica el cambio entre modos de GPU en sistemas Nvidia Optimus, como aquellos presentes en portátiles con configuraciones de gráficos híbridos Intel + Nvidia o AMD + Nvidia, en entornos Linux.\nEnvyControl es un software gratuito y de código abierto lanzado bajo la licencia MIT.\nTen en cuenta que este software se proporciona \u0026ldquo;tal cual\u0026rdquo; sin ninguna garantía expresa o implícita. Además, cualquier configuración personalizada de X.org puede ser eliminada o sobrescrita al cambiar entre modos.\nEl repositorio de la herramienta es el siguiente \u0026ndash;\u0026gt; https://github.com/bayasdev/envycontrol\nPara la instalación, se proporciona un mini tutorial específico para cada distribución en el repositorio. A continuación, te guiaré a través de los pasos para instalarlo en Debian.\nInstalación de EnvyControl Dado que ya no es posible instalar paquetes pip fuera de un entorno virtual tras la adopción de PEP668, en su lugar, utiliza el paquete .deb proporcionado por el repositorio .\nEncuentra la versión más reciente en el siguiente enlace: Releases - EnvyControl.\nEn esa página, selecciona y descarga el paquete .deb correspondiente. También puedes utilizar la herramienta wget para descargarlo desde la terminal.\nInstala el paquete descargado con el siguiente comando:\nsudo apt -y install ./python3-envycontrol_version.deb Una vez que hayas instalado la herramienta, tendrás la capacidad de seleccionar la tarjeta gráfica que deseas utilizar en tu equipo. Es importante recordar que cualquier configuración aplicada no surtirá efecto hasta que reinicies el sistema.\nSupongamos que decides utilizar la gráfica integrada para ahorrar energía, por ejemplo. El comando correspondiente sería :\nsudo envycontrol -s integrated Si por el contrario quieres utilizar el modo hibrido (ambas)\nsudo envycontrol -s hybrid --rtd3 Si prefieres utilizar solo tu gráfica dedicada, ten en cuenta que esta es la única configuración que me ha funcionado para activar los puertos de video. Para dar el salto a este modo te pedira primero que pongas el modo anterior , el hibrido . Una vez estes en ese modo el comando para activar solo tu grafica dedicada:\nsudo envycontrol -s nvidia --force-comp --coolbits 24 Vuelvo a insistirse pero RECUERDA REINICIAR PARA QUE SE APLIQUEN LOS CAMBIOS .\nEn este punto, te he proporcionado los comandos que he utilizado, pero el programa cuenta con su propio manual. Además, en el repositorio del autor, puedes encontrar información útil adicional.\nAdemas en esté explica que hay una extension de gnome para que puedas realizar estos cambios desde la interfaz gráfica . Aunque personalmente siempre tengo un enchufe donde trabajo con el portátil , es posible que para ahorrar batería quieras cambiar al modo híbrido o al de la gráfica integrada .\nHasta este punto, confío en que los controladores de NVIDIA estén funcionando correctamente y que puedas aprovechar los puertos de video de tu equipo.\n","date":"September 8, 2023","hero":"/images/sistemas/nvidia/nvidia.png","permalink":"https://www.javiercd.es/posts/sistemas/nvidia/nvidia_drivers/","summary":"La instalación de los controladores de NVIDIA en el universo de Linux ha sido tradicionalmente un desafío, especialmente en distribuciones como Debian, donde las políticas del software libre a menudo complican el proceso.\nEn este post voy a explicarte una forma sencilla de instalar los drivers de NVIDIA usando los repositorios oficiales de Debian . Además, al final del artículo, aprenderás a instalar una herramienta clave llamada Nvidia Optimus, que te brindará la capacidad de seleccionar qué tarjeta gráfica utilizará tu equipo.","tags":["Debian 12","Controladores NVIDIA","Sistemas","ISO","ASO"],"title":"Instalación de Controladores NVIDIA en Debian 12"},{"categories":null,"contents":"\r1. Introducción Wireshark es un analizador de protocolos utilizado para realizar análisis y solucionar problemas en redes de comunicaciones, para análisis de datos y protocolos, y como una herramienta didáctica.\nAñade una interfaz gráfica y muchas opciones de organización y filtrado de información. Así, permite ver todo el tráfico que pasa a través de una red estableciendo la configuración en modo promiscuo de nuestra tarjeta de red . También incluye una versión basada en texto llamada tshark.\nPermite examinar datos o de un archivo de captura salvado en disco. Se puede analizar la información capturada, a través de los detalles y sumarios por cada paquete. Wireshark incluye un completo lenguaje para filtrar lo que queremos ver y la habilidad de mostrar el flujo reconstruido de una sesión de TCP.\nWireshark es software libre, y se ejecuta sobre la mayoría de sistemas operativos Unix y compatibles.\nLos requisitos mínimos para utilizar este software son :\nCualquier procesador moderno AMD64/x86-64 de 64 bits o x86 de 32 bits. 500 MB de RAM disponibles. Los archivos de captura más grandes requieren más RAM. 500 MB de espacio disponible en disco. Los archivos de captura requieren espacio en disco adicional. Cualquier pantalla moderna. Se recomienda una resolución de 1280 × 1024 o superior. Wireshark utilizará resoluciones HiDPI o Retina si están disponibles. Los usuarios avanzados encontrarán útiles varios monitores. Una tarjeta de red compatible para capturar 1.1 Descarga del paquete en debían Para descargar el paquete en nuestro equipo deberemos de mirar en la pagina oficial de descargas si incluye soporte para nuestro sistema operativo .\nVemos que no aparece en la lista ningún sistema operativo GNU/Linux , esto es porque Wireshark está disponible a través del sistema de empaquetado predeterminado en la mayoría de estas plataformas . Es decir esta presente en los repositorios de nuestra distribución , en el caso de que no estuviese tenemos el código fuente al ser un software libre y podríamos compilarlo .\nPodemos comprobar si esta disponible en nuestro sistema operativo visitando la pagina oficial :\nVemos que Debian aparece en la lista esto quiere decir que el paquete esta en los repositorios oficiales de debían.\nEn Debian contamos con el gestor de paquetes apt , así que podemos comprobar la versión del paquete disponible para la instalación y comprobar desde que repositorios se nos descargara con el siguiente comando :\nPara realizar la instalación de wireshark introduciremos el siguiente comando :\nA continuación para hacer capturas de red en el equipo necesitaremos permisos para nuestro usuario para ello , utilizaremos el siguiente comando :\n1.2 Comprobación de funcionamiento Ahora abriremos el programa para comprobar que todo funciona correctamente :\nAhora iniciaremos una captura de paquetes para ello si queremos hacerla sobre un interfaz en concreta pulsamos sobre ella , en mi caso usare la tarjeta de red inalámbrica wlo1 y haré una petición web a la pagina jagger.es .\nAquí te muestro la petición DNS que ha viajado desde mi portátil hasta el router .\n1.3 Componentes de wireshark generales Wireshark hace uso de unos determinados paquetes : Wireshark : el analizador de protocolos de red que todos conocemos . TShark : un analizador de protocolo de red de línea de comandos. Complementos y extensiones : extras para los motores de disección Wireshark y TShark Complementos Dissector : complementos con algunas disecciones extendidas. Complementos de estadísticas de árbol -:Estadísticas extendidas. Mate: motor de seguimiento y meta análisis : extensiones configurables por el usuario del motor de filtro de pantalla; consulte el Capítulo 12, MATE para obtener más detalles. MIB de SNMP: MIB de SNMP para una disección de SNMP más detallada. Herramientas : herramientas de línea de comandos adicionales para trabajar con archivos de captura Editcap : lee un archivo de captura y escribe algunos o todos los paquetes en otro archivo de captura. Text2Pcap : lee un volcado hexadecimal ASCII y escribe los datos en un archivo de captura pcap. Reordercap : reordena un archivo de captura por marca de tiempo. Mergecap : combina varios archivos de captura guardados en un único archivo de salida. Capinfos : proporciona información sobre los archivos de captura. Rawshark : filtro de paquetes sin procesar. Guía del usuario : instalación local de la Guía del usuario. Los botones de Ayuda en la mayoría de los cuadros de diálogo requerirán una conexión a Internet para mostrar las páginas de ayuda si la Guía del usuario no está instalada localmente. 2 Instalación de GNS3 en Debian 11 2.1 Introducción GNS3 es un simulador gráfico de red lanzado en 2008, que te permite diseñar topologías de red complejas y poner en marcha simulaciones sobre ellos,permitiendo la combinación de dispositivos tanto reales como virtuales.\nPara permitir completar simulaciones, GNS3 está estrechamente vinculada con:\nDynamips: un emulador de IOS que permite a los usuarios ejecutar imágenes de IOS . Dynagen: un front-end basado en texto para Dynamips . Qemu y VirtualBox: para permitir utilizar máquinas virtuales como un firewall PIX o estaciones de trabajo . VPCS: un emulador de PC con funciones básicas de networking . IOU: (IOS en Unix), compilaciones especiales de IOS provistas por Cisco para correr directamente en sistemas UNIX y derivados . Los requisitos mínimos para hacer uso de esta herramienta son :\nProcesador : 2 o más núcleos lógicos Virtualización: Se requieren extensiones de virtualización. Es posible que deba habilitar esto a través del BIOS de su computadora. Memoria RAM: 4 GB de RAM Almacenamiento : 1 GB de espacio disponible (la instalación de Windows es \u0026lt; 200 MB). Notas adicionales : Es posible que necesite almacenamiento adicional para su sistema operativo y las imágenes del dispositivo. 2.2 Instalación Lo primero que haremos antes de instalar sera comprobar que nuestro sistema este actualizado , para ello haremos un apt update y si tenemos paquetes desactualizados haremos un apt upgrade .\nA continuación instalaremos todas las dependencias que necesita GNS3 :\nAhora te describiré la función de los paquetes que vamos a instalar :\nPaquete Descripción python3-pip El módulo pip es el instalador de paquetes de Python. python3-pyqt5 El módulo PyQt5 expone la API de Qt5 a Python 3 . python3-pyqt5.qtsvg El módulo SVG de PyQt5 proporciona clases para mostrar el contenido de los archivos SVG. python3-pyqt5.qtwebsockets El módulo WebSockets de PyQt5 proporciona enlaces de Python 3 para la especificación WebSockets (tanto cliente como servidor). qemu Software de Virtualización , actualmente se encuentra dividido en varios paquetes . qemu-kvm Binarios de emulación de sistema completo QEMU . qemu-utils Binario de utilidades de emulación de QEMU . libvirt-clients Libvirt es un conjunto de herramientas en C para interactuar con las capacidades de virtualización de versiones recientes de Linux . libvirt-daemon-system Este paquete contiene los archivos de configuración para ejecutar el demonio libvirt como un servicio del sistema. Virtinst Este paquete contiene algunas utilidades de línea de comandos para crear y editar máquinas virtuales . wireshark Es un analizador de red que captura paquetes para su posterior análisis . xtightvncviewer Sistema de visualización remota que le permite ver un entorno de \u0026rsquo;escritorio\u0026rsquo; no solo en la máquina donde se está ejecutando, sino desde cualquier lugar en Internet . apt-transport-https Este es un paquete de transición ficticio: la compatibilidad con https . ca-certificates Contiene los certificados de las autoridades certificadoras que se incluyen en el navegador de Mozilla para permitir que las aplicaciones basadas en SSL . curl curl es una herramienta de línea de comandos para transferir datos con sintaxis URL . gnupg2 Se puede utilizar para cifrar datos y crear firmas digitales. Incluye una función avanzada de administración de claves y cumple con el estándar de Internet OpenPGP propuesto. software-properties-common Le permite administrar fácilmente su distribución y las fuentes de software de proveedores de software independientes. Una vez instalados estos paquetes , nos descargaremos GNS3 utilizando pip3 :\nAdemás nos fijaremos en la salida del comando para comprobar si hay algún error :\nLo siguiente sera instalar docker , el cual nos permitirá crear contenedores . Para ello importaremos su clave GPG para que nuestro sistema confié en el :\nLo siguiente sera añadir el repositorio a nuestro sistema para ello utilizaremos el siguiente comando:\nActualizaremos los repositorios que utiliza apt haciendo un apt update :\nY finalmente podremos instalar docker :\nAgregue las siguientes líneas a su /etc/apt/sources.list , para que podamos instalar dynamips y ubridge:\nPara poder instalar los paquetes necesarios de estos repositorios , añadiremos las claves gpg del mismo :\nActualizaremos los repositorios que utiliza apt haciendo un apt update :\nNos instalaremos los paquetes Dynamips y ubridge :\nSaldrá un recuadro como este , para indicar si los usuarios que no son superusuarios pueden capturar paquetes , le diremos que si en nuestro caso :\nPara evitar la instalación accidental de cualquier otra cosa de ese repositorio (por ahora), elimine o comente esas dos líneas en su archivo /etc/apt/sources.list y haga un apt update:\nTambién podemos eliminar la clave GPG de estos repositorios si lo deseamos :\nAñadiremos a los usuarios que vayan a utilizar la herramienta a los siguientes grupos :\nReinicie su sesión de usuario cerrando sesión y volviendo a iniciarla, o reiniciando el sistema para que se apliquen estos cambios .\n2.3 Nuestra primera topología en GNS3 Una vez reiniciado el sistema iniciaremos la aplicación , y nos saldrá un recuadro como este :\nAquí indicaremos que voy a correr las aplicaciones localmente en mi maquina .A continuación seleccionaremos la ruta del servidor , el nombre de host y el puerto asociado :\nSi todo ha sido correcto , nos dirá que se ha realizado correctamente :\nCuando abramos el programa , nos dará opción a crear un proyecto o podemos crear uno nuevo , en mi caso creare uno :\nSi nos fijamos en la parte izquierda del programa veremos los siguientes símbolos que sirven para lo siguiente :\nAñadiremos arrastrando 2 VPCS :\nLe añadiremos un Ethernet swicht :\nHaremos clic en el botón Agregar un enlace para dejar de agregar enlaces , nos quedaría así el escenario :\nPodemos hacer visible la interfaz a la cual los hemos conectado pulsando en el siguiente botón :\nEl botón verde \u0026ldquo;Reproducir\u0026rdquo; en la barra de herramientas GNS3 encenderá todos los dispositivos en la topología, mientras que el botón amarillo \u0026ldquo;Pausa\u0026rdquo; los suspenderá y el botón rojo \u0026ldquo;Detener\u0026rdquo; apagará todo en la topología:\nNos saldrá una advertencia , para que confirmemos si queremos añadir todos los dispositivos , le daremos a si :\nVeremos que tanto a la izquierda en el resumen de dispositivos como en las conexiones salientes de los dispositivos su “luz” de estado a cambiado de rojo a verde , puestos que estos ahora están encendidos :\nAhora abriremos una terminal en todos nuestros VPCS , con el siguiente botón :\nA través de estas terminales le asignaremos direcciones ips a nuestros dispositivos con el siguiente comando :\nUna vez configurada las tarjetas de red , comprobaremos si hay conectividad entre ellos haciendo un ping :\nAñadiremos un tercer VPCS a nuestro esquema :\nLo encenderemos y abriremos una terminal para configurarlo al igual que hemos hecho con los anteriores :\nY comprobare que esta nueva maquina tiene conectividad con las anteriores :\nSi queremos que se guarden las configuraciones de nuestros equipos introduciremos el comando save :\n2.4 Acceso a internet a través de NAT en GNS3 La manera mas fácil de conseguir acceso a internet es a través de la nube NAT .\nEsta cuenta con acceso a internet , así como un servicio DHCP corriendo con IPV4 .Para hacer uso de ella , la pondremos en nuestro escenario y la conectaremos en un swicht .\nA continuación si queremos salir a internet , tendremos que configurar nuestros clientes para que estos obtengan la configuración de red adecuada . Aprovecharemos que tenemos un servidor DHCP .\nPara que los clientes se configuren a través de este servicio introduciremos el comando dhcp :\nProbaremos a hacer un ping a google.es para comprobar la conectividad :\n3 Problemas comunes en la instalación 3.1 Error VPCS executable version must be \u0026gt;=0.6.1 but not 0.8 Este error viene al hacer la instalación de los VPCS , se descarga de los repositorios una versión que no admite actualmente el programa .\nPor suerte es muy fácil de solucionar , accederemos al repositorio del desarrollador en github y nos descargaremos el siguiente paquete :\nUna vez descargado lo descomprimiremos usando el siguiente comando :\nDonde hagamos este comando nos creara un directorio en el cual accederemos para compilar el programa :\nEjecutaremos el siguiente script :\nNos creara en esta ruta el directorio vpcs , este tendremos que añadirlo en gns3 :\nAccederemos a gns3 , pulsaremos CTRL + SHIFT + P para acceder al panel de preferencias . Una vez aquí nos desplazamos al apartado de las vpcs y seleccionamos la ruta del directorio que acabamos de generar :\nAplicamos los cambios y ya podríamos utilizar las vpcs .\n3.2 Xterm no instalado Este error aparece cuando queremos acceder a una consola de un dispositivo de nuestra tipología de red .Para solucionar este problema lo primero es cerrar GNS3 y a continuación dirigirnos a una terminal para descargarlo, utilizaremos el siguiente comando :\nVolveremos a abrir el programa y podremos acceder a las consolas de nuestras maquinas .\n4 Instalar imágenes IOS Si queremos añadir a nuestro sistema hardware real como puede ser un router cisco por ejemplo deberemos de acceder a la pagina oficial de GNS3 y descargar concretamente el que deseemos añadir en mi caso añadiré un cisco 3725 .\nSi pulsamos sobre el botón de descarga nos descargara un archivo con extensión , el cual es una plantilla .\nSi nos fijamos en este caso no tenemos la posibilidad de descargar la imagen desde este repositorio , nos dice que no hay link disponible . Para estos casos existe un repositorio de cisco el cual tiene todas las imágenes de sus productos –\u0026gt; tfr.org/cisco-ios\nPara saber cual nos tenemos que traer de aquí , abriremos gns3 y a través del menú superior izquierdo pulsaremos sobre el apartado file \u0026gt; import appilance , seleccionaremos la plantilla que vamos a importar . Le daremos a instalar en nuestro ordenador local :\nUna vez aquí nos , veremos el nombre del archivo y lo buscaremos en el repositorio externo , ya que podemos observar que no se encuentra el archivo\nEn este caso descargare , esta version que coincide con la plantilla que he descargado :\nCuando hayamos hecho esto tendremos el siguiente problema , las firmas de las imágenes no coincidirán para paliar ese paso marcaremos la opción allow custom files en la parte inferior y importaremos el binario que acabamos de descargar :\nNos informara que para la plantilla seleccionada , el archivo que hemos descargado del repositorio no coinciden los hashes . En nuestro caso es normal ya que la imagen no es la misma que tendría que venir con la plantilla , así que aceptaremos los riesgos .\nVeremos que cambiara el estado a listo para instalar , así que le daremos a siguiente en la parte inferior .\nNos pedirá confirmación para añadir nuestro dispositivo , confirmaremos la acción :\nNos informara de que nuestro dispositivo se ha añadido en las plantillas de los router , para este caso .\nAdemás nos informara del nombre que se le ha asignado .\nComo nos indico , lo encontraremos en la sección de routers :\nAhora haremos una pequeña prueba de funcionamiento , lo añadiremos a nuestro escenario y comprobaremos que podemos arrancarlo y conectarnos a la consola :\nVeremos la conexión a la consola es correcta :\n5 Instalación en Windows de GNS3 5.1 Paquetes necesarios para Windows Aunque tengamos instalado el software de GNS3 este hará uso de paquetes adicionales para realizar algunas funciones o incluso añadir nuevas funcionalidades como emular enrutadores de determinados fabricantes .\nArtículo Requerido Descripción WinPCAP Requerido Requerido para conectar GNS3 a su red informática. Utilizado por los nodos Cloud y NAT para permitir que sus proyectos se comuniquen con el mundo exterior. Npcap Opcional El reemplazo moderno de WinPCAP sabe solucionar problemas pero está menos probado que WinPCAP.Instale Npcap con la opción \u0026ldquo;Modo compatible con la API de WinPcap\u0026rdquo; seleccionada, si se usa sin WinPcap.Npcap puede coexistir con WinPcap, si esa opción no está seleccionada. Wireshark Recomendado Le permite capturar y ver el tráfico de red enviado entre nodos. Dynamips Requerido Requerido para ejecutar una instalación local de GNS3 con enrutadores Cisco. QEMU 3.1.0 y 0.11.0 Opcional Un software de virtualización .La versión anterior de Qemu 0.11.0 está instalada para admitir dispositivos ASA antiguos. Se recomienda utilizar la vm GNS3 en su lugar.\nVPCS Recomendado Un emulador de PC muy ligero que admite comandos básicos como ping y traceroute Cpulimit Opcional Se usa para evitar que QEMU use el 100% de su CPU (cuando se está ejecutando) en algunos casos, como con los dispositivos ASA antiguos GNS3 Requerido El software principal de GNS3.Esto siempre es obligatorio. Visor TightVNC Recomendado Un cliente VNC utilizado para conectarse a las interfaces gráficas de usuario del dispositivo. Solar-Putty Recomendado La nueva aplicación de consola predeterminada. Virt-viewer Recomendado Visualizador alternativo de máquinas virtuales de escritorio Qemu que tienen qemu-spice preinstalado. Intel Hardware Acceleration Manager (HAXM) Opcional Solo disponible en sistemas con CPU Intel (y VT-X habilitado), que no usan Hyper-V. Se utiliza para la aceleración de hardware de la emulación de Android, así como para QEMU. 5.2. Requisitos mínimos Para entornos pequeños en Windows los desarrolladores exigen tener como mínimo las siguientes características :\nCaracterísticas Requisitos Sistema operativo Windows 7 (64 bits) o posterior Procesador 2 o más núcleos lógicos Virtualización Se requieren extensiones de virtualización. Es posible que deba habilitar esto a través del BIOS de su ordenador . Memoria 4 GB de RAM Almacenamiento 1 GB de espacio disponible (la instalación de Windows es \u0026lt; 200 MB). 5.3 Instalación GNS3 Lo primero que tendremos que sera descargarnos el ejecutable oficial de su pagina web , para ello tendremos que estar registrados previamente .\nLanzaremos el ejecutable y nos pedirá permisos de administrados , se los concedemos :\nSaldrá una pantalla informándonos sobre el producto , le damos a next .\nA continuación deberemos de aceptar los términos y licencias de uso :\nNos preguntara donde queremos crear los atajos del programa , lo dejare por defecto ya que asi los añadirá al escritorio :\nA continuación debemos de prestar atención ya que debemos de seleccionar instalación local y todos los paquetes que vayamos a hacer uso , si hubiésemos instalado antes alguno de ellos los desmarcamos (Los mencionados en el punto 5.1) :\nSeleccionaremos la ruta donde se instalara el programa , yo dejare la predeterminada . También nos informa el espacio que necesitara la instalación :\nEsperaremos a que se realice la instalación :\nInstalación WinCap\nRequerido para conectar GNS3 a su red informática. Utilizado por los nodos Cloud y NAT para permitir que sus proyectos se comuniquen con el mundo exterior.\nMientras se realiza la instalación de GNS3 comenzara la instalación de todos los programas que hemos marcado anteriormente .\nNos mostrara información sobre el programa esta primera ventana así que le damos a siguiente :\nAceptamos la licencia de términos y uso :\nMarcamos la opción para que arranque automáticamente el driver y le damos a instalar\nNos informa de que la instalación a sido correcta y cerramos la ventana :\nInstalación Ncap\nEl reemplazo moderno de WinPCAP sabe solucionar problemas pero está menos probado que WinPCAP.Instale Npcap con la opción \u0026ldquo;Modo compatible con la API de WinPcap\u0026rdquo; seleccionada, si se usa sin WinPcap.Npcap puede coexistir con WinPcap, si esa opción no está seleccionada.\nOtra vez el mismo proceso , aceptamos los términos y licencias de uso .\nDejamos la opción marcada por defecto y le damos a install\nCuando finalice la instalación le damos a siguiente :\nY cerramos el instalador :\nVolvemos a GNS3 ya que el proceso de instalación ha quedado detenido mientras hemos instalado los componentes que va a hacer uso , esta se reanuda automáticamente :\nUna vez finalice la instalación , le damos a siguiente\nGNS3 nos ofrece una licencia gratuita de Solarwinds , le daremos a si :\nHabremos finalizado correctamente la instalación de GNS3\nAbriremos el programa y seleccionaremos correr los dispositivos en nuestra maquina local :\nAquí configuraremos nuestro servidor local de GNS3\nAnteriormente lo deje por defecto , si nuestra configuración es correcta nos dirá que la conexión se ha realizado satisfactoriamente :\nNos mostrara un resumen de la configuración dada anteriormente :\n5.4 Prueba de funcionamiento Montaremos el mismo escenario que en debian para comprobar su funcionamiento , el proceso es el mismo .\nConfiguraremos las direcciones ips de las maquinas y comprobamos que tengan conectividad a través de solarputty .\nPC1 :\nPC2:\nPodemos observar que ambos equipos tienen conectividad a través del escenario .\n6 Instalación Wireshark en Windows 6.1 Instalación La instalación de este producto es muy sencilla , si hemos instalado GNS3 anteriormente y hemos marcado la casilla de este , se nos habrá instalado automáticamente .\nPor el contrario si partimos desde cero podemos hacer su instalación , bajandonoslo de su sitio web oficial :\nCuando abramos el instalador nos pedirá permisos de administrador , se lo concedemos :\nSi al igual que yo lo has instalado con GNS3 nos detectara que ya existe una instalaron , así que yo la cancelare .\nSi no lo tuviésemos la instalación es idéntica a cualquier programa que hemos instalado en la practica . Aquí te lo muestro , lo primero que veras sera una pantalla informativa del ejecutable :\nAl igual que todos los programas te pedirá que aceptes los términos y condiciones de uso :\nSeleccionaremos los productos que deseemos instalar en mi caso todos :\nAdemás nos preguntara que accesos directos y donde los queremos crear\nSeleccionaremos la ruta donde queremos que se instale :\nSeleccionaremos si nos interesa el paquete Ncap .(Lo hemos instalado con GNS3)\nA continuación nos preguntara para instalar la extensión que nos permite analizar trafico USB , en mi caso la desmarcare ya que no me interesa .\nEsperaremos a que finalice la instalación y le daremos a siguiente :\nNos informara de que la instalación ha sido realizada correctamente :\n6.2 Prueba de funcionamiento He realizado una petición DNS a www.sevillafc.es y aquí podemos ver la consulta DNS :\n7 GNS VM Si queremos desplegar maquinas virtuales en una instancia virtual desplegaremos la maquina virtual que nos da GNS3 para que este lleve la carga de la Virtualización .\nNos descargaremos la OVA desde la pagina web oficial\nUna vez descargada la importaremos en Vmware y le daremos las características hardware que consideremos oportuno :\nUna vez echo esto abriremos GNS3 y editaremos las preferencias de GNS VM y seleccionaremos la maquina virtual que acabamos de importar :\nSe nos iniciara la maquina virtual y podremos ver los datos de la misma en la pestaña info :\nLanzaremos el set-up wizard desde la pestaña help de GNS3 y seleccionaremos la opción de ejecutar las apilances en una maquina virtual :\nSeleccionaremos la configuración de nuestra maquina virtual :\nSeleccionaremos de nuevo nuestra maquina virtual y las características hardware que deseemos :\nSolo nos quedara importar los dispositivos en la maquina virtual , esto se hace igual que hemos echo anteriormente cambiando el sitio donde lo importamos :\nSi queremos ver donde se ejecutara un dispositivo podemos verlo a través de preferencias :\nAdemás podemos ver en apartado servers sumarry el consumo de recursos de nuestras maquinas :\n8 Conclusión Podemos ver que la instalación es infinitamente mas cómoda en Windows ya que automáticamente te instala las dependencias, siendo la típica instalación de “siguiente a siguiente ” .\nAdemás en Windows al acabar la instalación el producto estaba listo para usarse y no he sufrido ningún error al iniciar el programa ni al usar sus características como si me ha pasado en Debian .\n9 Bibliografía Documentacion oficial wireshark\nPaquete wireshark en debian\nRequisitos mínimos wireshark\nError “VPCS executable version must be \u0026gt;=0.6.1 but not 0.8” Descarga VPCS\n","date":"September 8, 2023","hero":"/images/redes/instalacion_wireshark_gns3/portada_instalacion_wireshark_gns3.jpeg","permalink":"https://www.javiercd.es/posts/redes/instalacion_wireshark_gns3/instalacion-gns3-y-wireshark/","summary":"1. Introducción Wireshark es un analizador de protocolos utilizado para realizar análisis y solucionar problemas en redes de comunicaciones, para análisis de datos y protocolos, y como una herramienta didáctica.\nAñade una interfaz gráfica y muchas opciones de organización y filtrado de información. Así, permite ver todo el tráfico que pasa a través de una red estableciendo la configuración en modo promiscuo de nuestra tarjeta de red . También incluye una versión basada en texto llamada tshark.","tags":["Redes","Wireshark","GNS3"],"title":"Instalación GNS3 y Wireshark en Debian"},{"categories":null,"contents":"\rEn ocasiones, es necesario actualizar el almacenamiento de nuestro sistema Debian para satisfacer las crecientes necesidades de espacio y mejorar la organización del disco. En esta guía, exploraremos el proceso de migración desde un disco con una única partición hacia uno con mayor capacidad, además de dividirlo en particiones separadas para una gestión más eficiente.\nEste proceso no solo ampliará el espacio de almacenamiento disponible, sino que también brindará una estructura más ordenada al sistema, facilitando tareas como la gestión de respaldos, el rendimiento del sistema y la administración del espacio en disco.\nCaracterísticas de la maquina Crea una máquina virtual en virt-manager con las siguientes características:\nSe instalará sistema operativo GNU/Linux Debian11. Tamaño de memoria: 1GB. CPU:1 Tamaño de disco duro: 2GB Detalles del hipervisor: chipset:Q35 Firmware: UEFIx86 Esquema de particiones La instalación de debian la realizarás, con el siguiente esquema de particiones: partición efi: 50MB\npartición /: 2GB\nswap: el resto de espacio sobrante.\nNo se instalará ningún entorno de escritorio.\nUna vez instalado el sistema, nos damos cuenta que estaríamos muy justos de espacio.\nAmpliación del disco Particionado Añade un disco a tu sistema de 10GB.\nParticiona este disco, eligiendo el tamaño apropiado para cada una de las particiones, teniendo en cuentas que cada partición será asignada a un directorio de los indicados:\n/boot/efi FAT32 partición efi –\u0026gt; 100MB / ext4 –\u0026gt; 8GB\n/home ext4 –\u0026gt;1GB\n/var ext4 –\u0026gt; 400MB\n/usr ext4 –\u0026gt; 400MB\nswap swap –\u0026gt; 200MB\nDando sistema de ficheros a las particiones Para darle formato a esta partición /boot/efi FAT32 partición efi –\u0026gt; 100MB\nPara estas particiones le daré formato ext4: / ext4 –\u0026gt; 8GB\n/home ext4 –\u0026gt;1GB\n/var ext4 –\u0026gt; 400MB\n/usr ext4 –\u0026gt; 400MB\nPara dar formato de swap: swap swap –\u0026gt; 200MB\nPara “activar la swap” –\u0026gt; sudo swapon dev/vdb6 y posteriormente para hacerlo permanente lo añadiremos al /etc/fstab .\nNos quedaría el disco con los siguientes formatos :\nMigración de datos Partición EFI A continuación realizaremos una copia fidedigna de cada una de nuestras particiones para ello , creare un directorio para montar cada disco en un directorio con su nombre :\nY montaremos las particiones en estos directorios :\nComenzaremos a pasar la información de nuestras particiones . Es importante usar el parámetro a (lo mismo que dpR) que permite hacer la copia recursivamente además se conservan intactos los permisos y enlaces que se encuentren en el sistema. Con el parámetro f, forzamos la copia.\nCopia de la partición EFI :\nPartición HOME Lo montaremos en un directorio cualquiera , a continuación lo copiaremos con rsync y con el comando diff comprobaremos si hay archivos diferentes en los directorios para ahorrarnos hacer la comprobación de forma manual .\nAhora lo añadiremos al fstab :\nLo montamos con un mount -a . Lo desmontamos y borraremos el directorio home del antiguo disco :\nPartición VAR Lo montaremos en un directorio cualquiera , a continuación lo copiaremos con rsync y con el comando diff comprobaremos si hay archivos diferentes en los directorios para ahorrarnos hacer la comprobación de forma manual .\nAhora lo añadiremos al fstab :\nLo montamos con un mount -a . Lo desmontamos y borraremos el directorio var del antiguo disco :\nPartición USR Lo montaremos en un directorio cualquiera , a continuación lo copiaremos con rsync y con el comando diff comprobaremos si hay archivos diferentes en los directorios para ahorrarnos hacer la comprobación de forma manual .\nAhora lo añadiremos al fstab :\nLo montamos con un mount -a :\nLo desmontamos y borraremos el directorio home del antiguo disco :\nY volveremos a montarlos con un mount -a .\nPartición RAIZ Lo montaremos en un directorio cualquiera , a continuación lo copiaremos con rsync y con el comando diff comprobaremos si hay archivos diferentes en los directorios para ahorrarnos hacer la comprobación de forma manual .\nExcluyendo los directorios que hemos separado anteriormente :\nAhora lo añadiremos al fstab :\nPara montar esta partición deberemos de reiniciar el sistema .\nGenerar la nueva EFI Para esto hay que seguir un procedimiento distinto , lo primero que haremos sera darle formato fat32 a la partición . Después igual que las demás la montaremos y instalaremos un nuevo grub especificando donde queremos instalarlo , en el segundo disco.\nAhora lo añadiremos al fstab :\nReiniciaremos el equipo y comprobaremos que funciona :\nAhora actualizaremos el grub :\nAhora para construir el nuevo efi tendremos que a través de un cd live o desde el modo rescate construir un nuevo grub :\nMontamos nuestra nueva partición del sistema y le damos a reinstalar el cargador de arranque grub :\nUna vez hecho esto apagamos la maquina y ponemos el segundo disco primero e el orden de arranque y reiniciamos el equipo :\nCuando reinicie elegimos la primera opción que es el arranque de vdb :\nY habremos conseguido migrar el sistema a un disco mas grande :\nMi /etc/fstab ha quedado de la siguiente manera :\nBibliografía Migrar de un disco a otro Copiar particiones Recuperar grub ","date":"September 8, 2023","hero":"/images/sistemas/migracion_de_sistema_de_ficheros/portada.jpg","permalink":"https://www.javiercd.es/posts/sistemas/migracion_sistema_de_ficheros/sistemas-de-ficheros/","summary":"En ocasiones, es necesario actualizar el almacenamiento de nuestro sistema Debian para satisfacer las crecientes necesidades de espacio y mejorar la organización del disco. En esta guía, exploraremos el proceso de migración desde un disco con una única partición hacia uno con mayor capacidad, además de dividirlo en particiones separadas para una gestión más eficiente.\nEste proceso no solo ampliará el espacio de almacenamiento disponible, sino que también brindará una estructura más ordenada al sistema, facilitando tareas como la gestión de respaldos, el rendimiento del sistema y la administración del espacio en disco.","tags":["Debian 12","Sistemas","ISO","ASO"],"title":"Migración de un sistema de ficheros"},{"categories":null,"contents":" NAT con iptables En este artículo aprenderás a configurar un pequeño escenario en el cual podrás configurar una serie de servicios. Crearás el escenario descrito a continuacion , además, harás que a través de una red interna, usando un servidor Linux, tengas acceso a Internet configurando SNAT en el mismo haciendo uso de iptables.\nInstalación del entorno de pruebas Vamos a instalar el siguiente entorno:\nConfiguración de VirtualBox Servidor debian :\nCliente windows\nCliente debian\nConfiguración de red Lo primero que haremos sera configurar las tarjetas de red de nuestras maquinas .\nServidor debian Editamos el fichero con nano /ect/network/interfaces como superusuario y añadimos las siguientes lineas .\nLos cuadros rojos corresponden a la configuración de las tarjetas de red enp0s3(tarjeta externa) y enp0s8(red interna). El cuadro azul corresponde a las reglas iptables para permitir las peticiones al exterior y prohibir las interiores .\nCliente debian Editamos el fichero con nano /etc/network/interfaces como superusuario y añadimos las siguientes lineas .La puerta de enlace sera la dirección ip de la tarjeta del servidor interna .\nCliente Windows 10 En windows 10 configuramos manualmente accediendo a conexiones de red \u0026gt; configuracion del adaptador \u0026gt; ipv4 y le asignamos lo siguiente .Al igual que el cliente debian cambiando la dirección ip . He puesto dns de Google porque utilizo mi red movil .\nConfiguración de nat en el servidor Modificar el fichero /etc/sysctl.conf. Hay que descomentar la línea :\nComprobamos si se ha aplicado\nComprobación de internet en los clientes Windows 10 Debian 11 ","date":"September 8, 2023","hero":"/images/servicios/nat_iptables/portada_iptables.jpeg","permalink":"https://www.javiercd.es/posts/servicios/nat_iptables/nat_iptables/","summary":"NAT con iptables En este artículo aprenderás a configurar un pequeño escenario en el cual podrás configurar una serie de servicios. Crearás el escenario descrito a continuacion , además, harás que a través de una red interna, usando un servidor Linux, tengas acceso a Internet configurando SNAT en el mismo haciendo uso de iptables.\nInstalación del entorno de pruebas Vamos a instalar el siguiente entorno:\nConfiguración de VirtualBox Servidor debian :","tags":["Servicios","NAT","SMR","IPTABLES","SNAT"],"title":"NAT con iptables"},{"categories":null,"contents":"\rEl Protocolo de Resolución de Direcciones (ARP) es fundamental en redes informáticas para mapear direcciones IP a direcciones físicas de capa de enlace (MAC). Su función principal es encontrar la dirección MAC asociada a una dirección IP específica en una red local. Cuando un dispositivo necesita comunicarse con otro en la misma red, utiliza ARP para determinar la dirección MAC del destino antes de enviar datos.\n¿Crees que la pregunta ARP es un mensaje de difusión? Realiza una captura en Wireshark de una petición ARP y analízala para justificar tu respuesta. Si , es un mensaje de difusión ya que en la cabecera podemos ver que el destino tiene una dirección de broadcast . Esta dirección es la que tiene todos sus bits a 1 que en las direcciones mac se traduce en FF:FF:FF:FF:FF:FF .\nCuando esta le llegue , en este caso al que tiene la dirección IP 192.168.1.1 nos devolverá la petición y en el origen obtendremos su dirección MAC.\n¿Crees que la respuesta ARP es un mensaje de difusión? Realiza una captura en Wireshark de una respuesta ARP y analízala para justificar tu respuesta. Podemos ver en la respuesta que en la dirección de destino viene la del pc que mando la pregunta , por lo que la respuesta no es un mensaje de broadcast sino una comunicación punto a punto .\nLos ordenadores de una red almacenan en memoria una caché con las correspondencias IP-MAC que van conociendo. Explica el proceso de actualización de la caché ARP después de observar como se va rellenando en las máquinas de un pequeño escenario en GNS3 con una red local con cuatro ordenadores conectados a un switch. Ve comprobando como cambia la caché ARP de todos los ordenadores cuando vas haciendo ping entre un ordenador y otro. Cuando hacemos un ping el emisor y el receptor “se añaden mutuamente a la tabla ARP” , si las consultamos en ambas veremos que están incluidos :\nPodemos ver que el tiempo por el que se guardan en cache es de 120 segundos , cuando este tiempo se acaba, se borra la entrada.\nMientras que en los pcs que no han intervenido no almacenaran nada en la cache arp sobre la “transacción realizada”:\nAnaliza el comando ip neigh para ver las posibilidades que ofrece y piensa cual puede ser el uso real de cada una de ellas. Este comando nos permite interactuar con la tabla arp donde se guardan la relación de direcciones IP-MAC . Por ejemplo podemos visualizarla , añadir entradas o borrarlas así como modificarlas . Además podemos cambiar el tiempo durante el cual se guarda una petición en la tabla .\nPor ejemplo , listar el contenido :\nPodemos resumir sus funciones :\nMostrar la tabla ARP completa: ip neighbour show Agregar una entrada a la tabla ARP: ip neighbour add (IP) lladdr {MAC} dev {interface} Eliminar una entrada de la tabla ARP: ip neighbour del {IP} dev {interface} Establecer el tiempo de vida de una entrada en la tabla ARP: ip neighbour change {IP} dev {interface} nud {state} Buscar una entrada específica en la tabla ARP: ip neighbour | grep {IP} Básicamente esto es lo que debemos conocer para poder controlar las tablas ARP con el comando IP en sustitución (o como complemento) a «arp».\nAverigua qué es un ARP gratuito y cuál es el sentido de su existencia. Es una solicitud emitida por un dispositivo con el objetivo de actualizar la tabla arp del resto de dispositivos de una red . Este simplemente informa a los demás dispositivos de la red de su propia dirección IP y MAC .\nEl propósito principal de las ARP gratuitas es asegurar que todos los dispositivos en una red tengan la información más actualizada posible sobre las direcciones IP y MAC de los demás dispositivos en la red.\nUna de sus utilidades es detectar conflictos de IP\u0026rsquo;s, \u0026ldquo;esta ip ya está cogida\u0026rdquo; esto es debido a que otro equipo ha respondido con estos paquetes.\nPor lo que a partir de esta información se puede resolver esta incidencia.\nExplica con tus palabras en qué se basa un ataque ARP Spoofing y cómo se lleva a cabo. ¿Puede usarse como técnica de ataque desde tu casa a una red ajena? ¿Cómo podríamos defendernos de él? El ataque viene a modificar el flujo de los datos enviados desde un PC Víctima que pasa a través de un Gateway para hacer un ataque de tipo MITM (Man in the Middle) consiguiendo que el tráfico de la víctima pase por una máquina Atacante de forma inocua para la víctima.\nAsí el atacante intercepta los mensajes y es capaz de obtener todo el trafico de la red obteniendo contraseñas e información confidencial o sensible .\nLos pasos que sigue un atacante al realizar este ataque son :\nEscanear la red , para obtener una relación de los dispositivos conectados . Enviar paquetes arp falsos para asociar en las víctimas su dirección ip a su propia mac. Una vez que el cliente ha sido “engañado” , el atacante comenzara a interceptar todo el trafico. Estos ataques solo se producen si el atacante consigue acceso a tu red local , así que para protegernos podemos usar :\nHerramientas de detección de ARP Spoofing . Utilizar un firewall , ya que ese es capaz de bloquear paquetes ARP sospechosos . Utilizar protocolos como Ipsec y SSL/TLS . Configurar la tabla arp de manera estática. Hay dos tipos de ataques a switches llamados MAC Flooding y MAC Spoofing. ¿En qué consisten y cómo podemos defendernos de ellos? MAC Flooding consiste en llenar la tabla arp de un dispositivo de red , por ejemplo un switch y hacer que este no sea capaz de localizar a que boca va el trafico a si este lo mandara por todas las bocas provocando que en el peor de los casos dejar sin servicio al dispositivo .\nPara mitigar este ataque se recomienda configurar un limite en el tamaño de la tabla ARP y la detección y bloqueo de trafico sospechoso .\nMientras que el MAC Spoofing consiste en falsificar una dirección MAC para interceptar un determinado trafico , pudiendo tener acceso a contenido privado .\nPara mitigar este ataque en el caso de que suplante una maquina de mi red y tenga acceso a contenido podemos implementar herramientas de segundo factor de autentificaron o usar certificados digitales .\nAdemás podemos implementar en nuestra red las siguientes estrategias :\nEntradas estáticas en tabla ARP\nLa primera solución que existe corresponde a trabajar con rutas estáticas en los equipos de red. Esto permite invalidar los mensajes ARP, debido a que las IP se asocian una dirección MAC y esta no cambia en el tiempo. Es una solución simple y en general se aplica para asegurar que la puerta de enlace predetermina sea realmente la de la red y no un atacante. Sin embargo, es una estrategia difícil de aplicar si se posee una red con una gran cantidad de terminales.\nDHCP snooping\nEs una estrategia que mantiene un registro de las MAC que están conectadas en cada puerto y detecta inmediatamente si existe una suplantación. Varios fabricantes de equipos de red incorpora esta solución en sus equipos, como es el caso de CISCO.\nDynamic ARP Inspection\nPara evitar la suplantación de ARP (ARP spoofing) y el envenenamiento por ARP (ARP poisoning) resultante, un switch debe garantizar que solo se transmitan ARP Requests y ARP Replies válidas.\nLa Inspección Dinámica de ARP/ Dynamic ARP Inspection (DAI) requiere de DHCP snooping y ayuda a prevenir ataques ARP así:\nNo retransmitiendo respuestas/Replies ARP invalidas o gratuitas/gratuitous a otros puertos en la misma VLAN. Intercepta todas las solicitudes/Requests y respuestas/Replies ARP en puertos no confiables. Verificando cada paquete interceptado para un enlace válido de IP a MAC. Descarte y registro de respuestas no válidas de ARP para evitar el envenenamiento por ARP. Error-disabling la interfaz si se excede el número de paquetes ARP DAI configurado. RARP\nRARP es Reversal ARP, esto quiere decir que consulta a partir de una dirección MAC la IP correspondiente. En caso de que retorne más de una dirección IP, entonces la MAC ha sido clonada.\nBibliografía ip neigh arp spoofing ARP gratuitos medidas de mitigación ","date":"September 8, 2023","hero":"/images/redes/arp/portada.png","permalink":"https://www.javiercd.es/posts/redes/arp/arp/","summary":"El Protocolo de Resolución de Direcciones (ARP) es fundamental en redes informáticas para mapear direcciones IP a direcciones físicas de capa de enlace (MAC). Su función principal es encontrar la dirección MAC asociada a una dirección IP específica en una red local. Cuando un dispositivo necesita comunicarse con otro en la misma red, utiliza ARP para determinar la dirección MAC del destino antes de enviar datos.\n¿Crees que la pregunta ARP es un mensaje de difusión?","tags":["Redes","ARP"],"title":"Protocolo ARP"},{"categories":null,"contents":" servidor SSH bajo debian Gestión remota usando SSH Lo primeros que deberemos de hacer sera instalarnos el paquete en el servidor y el cliente :\nPor seguridad se suele no permitir la conexión del root al servidor; para ello, se debe modificar el archivo /etc/ssh/sshd_config, y se pone la siguiente opción:\nY reiniciamos el servicio para que se apliquen los cambios :\nConectarse al servidor ssh Vamos a instalarnos el cliente ssh, para ello:\nPara acceder desde el cliente al servidor tecleamos:\nNos abríamos conectado remotamente\nEjecución remota de aplicaciones gráficas Mediante ssh existe la posibilidad de ejecutar aplicaciones gráficas en el servidor y manejarlas y visualizarlas en el cliente. El servidor ssh deberá tener activada la redirección del protocolo X, es decir, deberá tener el siguiente parámetro en el archivo de configuración /etc/ssh/sshd_config:\nEn mi caso ya estaba habilitado , si no lo tuviésemos lo cambiamos y reiniciamos el servicio para que se apliquen los cambios . Ahora deberemos de conectarnos con el parámetro -X :\ny posteriormente podemos ejecutar cualquier aplicación gráfica, por ejemplo, gedit:\nSe nos abrirá el programa gráficamente :\nAhora vemos en el servidor que se ha creado :\nTransferir ficheros con ssh Para copiar un fichero desde el cliente al servidor introducimos el siguiente comando :\nAhora vamos a comprobar si se ha copiado al servidor :\nAcceso remoto por cifrado asimetricó Configuracion del acceso por claves Vamos a generar nuestras claves desde nuestro cliente :\nAhora vamos a añadirla a nuestro servidor :\nUna vez echo esto deshabilitamos el acceso con contraseña en el servidor editando el archivo /etc/ssh/sshd_config :\nA continuación solo debemos reiniciar el servicio y al volver a registrarnos, ya estaremos utilizando clave publica :\nSi nos intentamos registrar con usuario el cual no tenemos la clave publica nos dirá lo siguiente :\nCambio de puerto Ahora vamos a editar el fichero de configuración para indicar el puerto :\nY reiniciaremos el servicio :\nAhora si nos intentamos conectar como lo hemos hecho anterior mente , nos dara el siguiente error :\nPara conectarnos deberemos de especificar el puerto por el cual nos conectamos con -p :\nConectarnos con un cliente de acceso remoto usando túneles Usaremos kitty , cuando lo abramos en la primera pantalla introducimos la ip del servidor y el puerto que haya configurado en el servidor para el ssh en mi caso 2222\nAhora añadimos el puerto por el cual nos conectaremos usando el túnel y después la ip seguida de dos puntos y el mismo puerto .\nAhora introducimos nuestro usuario y contraseña y nos habremos conectado :\nSi queremos hacer lo mismo pero usando una clave publica desde windows , pulsamos windows +r y escribimos lo siguiente :\nY generamos las claves publicas :\nAhora vamos a la ruta que lo hemos guardado copiamos la clave publica y la introducimos en el servidor , por comodidad la he copiado desde el cliente usando ssh.\nUna vez añadida guardamos el archivo :\nVamos a desactivar la autenticación por contraseña y reiniciamos el servicio\nAhora desde el kitty deberemos de irnos al apartado ssh\u0026gt;auth , le damos a browse y seleccionamos nuestra clave privada , que deberá tener la extension .ppk . Yo la copie en otro directorio por comodidad para las pruebas .\nY nos conectamos :\nAquí hemos combinado conectarnos con kitty usando un túnel + otro puerto + clave publica .\nVNCserver Lo instalamos con el siguiente comando :\nA continuación configuramos las credenciales de configuración para administradores y usuarios de acceso con el siguiente comando :\nAhora vamos al cliente y introducimos la ip seguida del puerto por dos puntos, si no lo sabemos lo podemos mirar con :\nNos saldrá una advertencia al no estar cifrada la comunicación , le damos a continuar y introducimos la contraseña de acceso , que hayamos puesto anteriormente :\nComo no tenemos entrono grafico en el servidor no nos mostrara imagen pero podemos ver que hemos establecido conexión tanto en windows como en Linux :\nGestión de páginas web mediante ssh 1.Una vez creado los dos sitio virtuales deseamos establecer una conexión segura a cada uno de nuestros sitios, para ello debemos establecer un túnel ssh de la misma manera que lo hemos establecido para establecer una conexión remota por vnc .\n2.Crear un túnel desde el cliente ssh para que el acceso a la sección privada de la web de departamentos se establezca por el puerto 9999\n3.Con ambos túneles establecidos comprobar que el acceso a la web iesgn.org se puede realizar sin problemas por el puerto 80\nSolo he conseguido hacer a mi pagina por defecto , para eso hacemos un túnel con kitty por ejemplo:\nAhora añadimos los puertos origen y destino del puerto :\nAhora nos registramos con nuestro usuario :\nUna vez establecido el túnel introducimos en el navegador localhost:8888 :\nY así hemos establecido una conexión segura web .\nSi cerramos el túnel perderemos la conexión :\n","date":"September 8, 2023","hero":"/images/servicios/ssh/portada-ssh.png","permalink":"https://www.javiercd.es/posts/servicios/ssh/ssh/","summary":"servidor SSH bajo debian Gestión remota usando SSH Lo primeros que deberemos de hacer sera instalarnos el paquete en el servidor y el cliente :\nPor seguridad se suele no permitir la conexión del root al servidor; para ello, se debe modificar el archivo /etc/ssh/sshd_config, y se pone la siguiente opción:\nY reiniciamos el servicio para que se apliquen los cambios :\nConectarse al servidor ssh Vamos a instalarnos el cliente ssh, para ello:","tags":["Servicios","NAT","SMR","IPTABLES","SNAT","SSH","FORWARDING"],"title":"SSH bajo debian "},{"categories":null,"contents":"\rStorage Spaces es una característica de almacenamiento definido por software en el sistema operativo Windows Server que permite a los administradores de sistemas combinar varios discos físicos en un único espacio de almacenamiento lógico llamado \u0026ldquo;pool de almacenamiento\u0026rdquo;. Este pool de almacenamiento se puede utilizar para crear espacios de almacenamiento virtuales llamados \u0026ldquo;espacios de almacenamiento\u0026rdquo; que ofrecen diversas funciones de redundancia y capacidades avanzadas de administración de almacenamiento.\nGrupos de almacenamiento Los siguientes cmdlets de Windows PowerShell realizan la misma función que el procedimiento anterior. Escriba cada cmdlet en una sola línea, aunque aquí pueden aparecer con saltos de línea entre varias líneas aquí debido a restricciones de formato.\nEl siguiente ejemplo muestra qué discos físicos están disponibles en el grupo primordial.\nGet-StoragePool -IsPrimordial $true | Get-PhysicalDisk -CanPool $True El siguiente ejemplo crea un nuevo grupo de almacenamiento denominado StoragePool1 que usa todos los discos disponibles:\nNew-StoragePool –FriendlyName StoragePool1 –StorageSubsystemFriendlyName \u0026#34;Windows Storage\\*\u0026#34; –PhysicalDisks (Get-PhysicalDisk –CanPool $True) Por defecto el tipo de aprovisionamiento es mirror.\nSi necesitamos añadir mas discos :\nAdd-PhysicalDisk -StoragePoolFriendlyName StoragePool1 -PhysicalDisks (Get-PhysicalDisk - CanPool $True) Crear un disco virtual Vamos a crear un disco virtual :\nNew-VirtualDisk –StoragePoolFriendlyName StoragePool1 –FriendlyName VirtualDisk1 –Size (8GB) Automáticamente nos creara un volumen y nos lo montara en una letra disponible: :\nPodemos interactuar con el y guardar información :\nVemos que este es el “equivalente” a LVM en Windows . Vemos que hay similitudes no solo en la estructura a la hora de crearlo si no que también podemos observar que hacen referencia en la documentación oficial a RAID 5 y RAID 6:\nA la forma de almacenar los datos en ya sea en stripes o guardando el espacio completo , al igual que sucede en Linux :\nBibliografía Documentación oficial ","date":"September 8, 2023","hero":"/images/sistemas/storage_spaces/portada.png","permalink":"https://www.javiercd.es/posts/sistemas/almacenamiento_servidor_independiente/almacenamiento_servidor_independiente/","summary":"Storage Spaces es una característica de almacenamiento definido por software en el sistema operativo Windows Server que permite a los administradores de sistemas combinar varios discos físicos en un único espacio de almacenamiento lógico llamado \u0026ldquo;pool de almacenamiento\u0026rdquo;. Este pool de almacenamiento se puede utilizar para crear espacios de almacenamiento virtuales llamados \u0026ldquo;espacios de almacenamiento\u0026rdquo; que ofrecen diversas funciones de redundancia y capacidades avanzadas de administración de almacenamiento.\nGrupos de almacenamiento Los siguientes cmdlets de Windows PowerShell realizan la misma función que el procedimiento anterior.","tags":["Linux","Sistemas","ISO","ASO"],"title":"Storage Spaces en Windows Server"},{"categories":null,"contents":"\rEn este post detallado, exploramos el proceso de configuración de túneles IPv6 a IPv4 y viceversa en entornos Linux y Cisco. A medida que la migración hacia IPv6 gana importancia, la capacidad de establecer comunicaciones entre redes IPv4 e IPv6 se vuelve fundamental. Cubriremos los conceptos básicos de la configuración de túneles, incluyendo los tipos de túneles más comunes, como 6to4 y Teredo. Además, proporcionaremos instrucciones paso a paso para la configuración tanto en sistemas Linux como en dispositivos Cisco\nTúneles 6to4 en cisco 1.Configuraron de las interfaces de red de los Routers R1\nR1 –\u0026gt; FastEthernet 0/0\nLlevara el prefijo de red –\u0026gt; 3333:db7::/64 Enlace :FE80::C801:20FF:FE69:0 Global : 3333:DB7::C801:20FF:FE69:0 R1 –\u0026gt; FastEthernet 1/0\nR1 –\u0026gt; FastEthernet 2/0\nPara los clientes del router 1 configurare SLAAC :\nR2\nR2 –\u0026gt; FastEthernet 0/0\nLlevara el prefijo de red –\u0026gt; 3333:db7:1::/64 Enlace :FE80::C802:20FF:FE79:0 Global : 3333:DB7:1:0:C802:20FF:FE79:0 R2–\u0026gt; FastEthernet 1/0\nR2–\u0026gt; FastEthernet 2/0\nPara los clientes del router 2 configurare SLAAC :\nR3\nR3 –\u0026gt; FastEthernet 0/0\nLlevara el prefijo de red –\u0026gt; 3333:db7:2::/64 Enlace :FE80::C803:20FF:FE89:0 Global : 3333:DB7:2:0:C803:20FF:FE89:0 R3–\u0026gt; FastEthernet 1/0\nR3–\u0026gt; FastEthernet 2/0\nPara los clientes del router 3 configurare SLAAC :\n*En este escenario no es necesario que configuremos rutas IPV4 manualmente ya que con la configuración dada en las tarjetas de red el escenario estará enrodado en IPV4.\n2.Túneles GRE GRE es un protocolo de tunneling de VPN de sitio a sitio básico no seguro que puede encapsular una amplia variedad de tipos de paquete de protocolo dentro de túneles IP, lo que permite que una organización entregue otros protocolos mediante una WAN basada en IP.\nEste podrá sobre nuestro paquete IPV6 una cabecera IPV4 para que este pueda viajar por redes IPV4 .\nR1 –\u0026gt; R3\nCrearemos una interfaz de tunnel :\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una IPV4 a nuestro túnel:\nEstablecemos la dirección WAN de nuestro router , FastEthernet 1/0:\nEstablecemos la dirección WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico :\nEste comando agrega a la red del túnel a OSPF:\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router 2002:0A00:0001::1/64 :\nCreamos la ruta para llegar a la red :\nCrearemos una interfaz de tunnel\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una dirección IPV4 a nuestro túnel :\nEstablecemos la dirección WAN de nuestro router , FastEthernet 1/0.\nEstablecemos la dirección WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico .\nEste comando agrega a la red del túnel a OSPF\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router 2002:0A00:0002::1/64 :\nCreamos la ruta para llegar a la red :\nCrearemos una interfaz de tunnel\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una direccion IPV4 a nuestro túnel :\nEstablecemos la direccion WAN de nuestro router , FastEthernet 1/0.\nEstablecemos la direccion WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico .\nEste comando agrega a la red del túnel a OSPF\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router 2002:1400:0001 :\nCreamos la ruta para llegar a la red :\nR3 –\u0026gt; R1\nCrearemos una interfaz de tunnel\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una dirección IPV4 a nuestro túnel :\nEstablecemos la dirección WAN de nuestro router , FastEthernet 1/0.\nEstablecemos la dirección WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico .\nEste comando agrega a la red del túnel a OSPF\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router 2002:1400:0002::1/64 :\nCreamos la ruta para llegar a la red :\nR3 –\u0026gt; R2\nCrearemos una interfaz de tunnel\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una dirección IPV4 a nuestro túnel :\nEstablecemos la dirección WAN de nuestro router , FastEthernet 1/0.\nEstablecemos la dirección WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico .\nEste comando agrega a la red del túnel a OSPF\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router:\n30.0.0.2 –\u0026gt; 2002:1e00:0002::1/64\nCreamos la ruta para llegar a la red :\nR2–\u0026gt; R3\nCrearemos una interfaz de tunnel\nEstablecemos el modo del túnel a GRE con IP que encapsulara nuestros paquetes IPV6 dentro de IPV4:\nLe damos una dirección IPV4 a nuestro túnel :\nEstablecemos la dirección WAN de nuestro router , FastEthernet 1/0.\nEstablecemos la dirección WAN del extremo del túnel (R2) :\nHabilitamos OSPF que es un protocolo de enrutamiento dinámico .\nEste comando agrega a la red del túnel a OSPF\nLe daremos una IPV6 a nuestro tunnel , con el prefijo de red 2002 a partir de la IPV4 del router 30.0.0.1 –\u0026gt; 2002:1e00:0001::1/64 :\nCreamos la ruta para llegar a la red :\n3.Comprobaciones de funcionamiento Vamos a comprobar que se ha creado los túneles para ello introduciremos el siguiente comando en los tres routers de nuestro escenario :\nEsto aparecerá una vez ambos extremos del túnel se han creado si no nos aparecerá nada . En nuestro caso podemos ver que se ha creado exitosamente los túneles .\nPing Comprobaremos el funcionamiento de los túneles haciendo un ping .\nPC1-→3333:db7::e60:ddff:fea6:0 PC2-→ 3333:db7:1:0:e2e:3bff:fe83:0 PC3 –\u0026gt; 3333:db7:2:0:e62:5dff:fedf:0 PC1 –\u0026gt; PC2\nPC1 –\u0026gt; PC3\nPC2 –\u0026gt; PC1\nPC2-→ PC3\nPC3 –\u0026gt; PC1\nPC3→ PC2\nVemos que tenemos conectividad entre todas nuestras maquinas del escenario con IPV6 aunque tengamos que atravesar redes IPV4 .\nTraceroute Vamos a comprobar la trayectoria que siguen los paquetes . Trayectoria que sigue un paquete PC1 a PC2 :\nTrayectoria que sigue un paquete PC1 a PC3 :\nTrayectoria que sigue un paquete PC2 a PC1 :\nTrayectoria que sigue un paquete PC2 a PC3 :\nTrayectoria que sigue un paquete PC3 a PC1 :\nTrayectoria que sigue un paquete PC3 a PC2 :\n4.Estudio de un paquete encapsulado Antes de pasar por el túnel\nPaquete que viaja de PC1 a PC2.\nVemos que al no haber atravesado el túnel aun no tiene las cabeceras IPV4 , solo tiene las IPV6. Podemos ver que el origen es PC1 y el destino es PC3\nVeremos como en el siguiente tramo una vez atraviese el túnel el router le pondrá una cabecera IPV4 para que pueda atravesar ese tramo .\nDespués de atravesar el túnel\nSi nos fijamos en un paquete que tiene que ha atravesado un túnel podemos ver que tiene “2 niveles de red ” :\nSi nos fijamos en el nivel de red , vemos que las IPs de origen y destino son las de los extremos del túnel . Además vemos que utiliza el protocolo 47 que significa que ha travesado un túnel GRE .\nYa por ultimo podemos ver en la cabecera IPV6 , que no se distingue de una que no ha atravesado un túnel .\nUna vez llega a la red de destino\nVemos que una vez llega al destino es decir , una vez ya ha recorrido el tramo IPV4 y vuelve a entrar a la red IPV6 el router eliminara la cabecera correspondiente a IPV4 y dejara la de IPV6 para que el paquete llegue a su destino .\nVemos que la cabecera IPV6 sigue intacta , es la misma durante todo el trayecto del paquete :\nTúneles 6to4 en Linux 1.Configuración de las interfaces de red Voy a respetar las direcciones IPV4 del escenario con cisco .\nR1\nPara aplicar la configuración haremos un sudo systemctl restart networking.service\nVoy a configurar SLAAC para configurar los clientes de nuestra red IPV6 , previamente tendremos que tener instalado el paquete radvd con sudo apt install radvd.\nUna configurado el servicio reiniciaremos radvd y nuestros clientes se configuraran automáticamente con el prefijo indicado .\nR2\nPara aplicar la configuración haremos un sudo systemctl restart networking.service\nVoy a configurar SLAAC para configurar los clientes de nuestra red IPV6 , previamente tendremos que tener instalado el paquete radvd con sudo apt install radvd.\nUna configurado el servicio reiniciaremos radvd y nuestros clientes se configuraran automáticamente con el prefijo indicado .\nR3\nPara aplicar la configuración haremos un sudo systemctl restart networking.service\nVoy a configurar SLAAC para configurar los clientes de nuestra red IPV6 , previamente tendremos que tener instalado el paquete radvd con sudo apt install radvd.\nUna configurado el servicio reiniciaremos radvd y nuestros clientes se configuraran automáticamente con el prefijo indicado .\nEn este escenario no es necesario que configuremos rutas IPV4 manualmente ya que con la configuración dada en las tarjetas de red el escenario estará enrodado en IPV4.\nSin embargo sera necesario para todos los routers que habilitemos el bit de forwarding tanto para IPV4 como para IPV6.\nPara ello editamos el fichero sudo nano /etc/sysctl.conf y descomentamos las siguientes lineas :\nEsto mismo lo repetiremos para los cada uno de nuestros routers y reiniciaremos para que se apliquen los cambios .\n2.Configuración de los túneles SIT El funcionamiento es similar a los túneles GRE en cisco este cojera nuestros paquetes y a través de una interfaz tipo túnel le añadirá una cabecera IPV4 para que pueda atravesar redes IPV4 .\nUna vez el túnel este levantado le diremos al router que para llegar al prefijo de la red X tendrá que utilizar este para que le añada la cabecera a nuestros paquetes .\nPara mayor comodidad he creado un pequeño script en cada router con los comandos necesarios para que el tunnel funcione .\nConsta de 4 comandos :\nCreara la interfaz de tunnel con el destino y a continuación el origen de este . Levantara la tarjeta de red Le asignara la IPV6 al túnel a partir de la dirección IPV4 de origen del mismo . Crearemos la ruta del trafico que utilizara el tunnel . Podemos ponerle al túnel el nombre que deseemos en mi caso he puesto tunnel seguido de un numero para poder identificarlos\nTúneles de R2\nAsí quedaría el “script” de los túneles de R2\nUna vez creado el script le daremos permiso y lo ejecutaremos :\nComprobaremos que las interfaces se han creado correctamente :\nUna vez creado el script le daremos permiso y lo ejecutaremos :\nComprobaremos que las interfaces se han creado correctamente :\nTúneles de R3\nAsí quedaría el “script” de los túneles de R3\nUna vez creado el script le daremos permiso y lo ejecutaremos :\nComprobaremos que las interfaces se han creado correctamente :\n3.Comprobación de funcionamiento PC1 –\u0026gt; 3333:db7::e47:bfff:fe86:0 PC2 –\u0026gt; 2222:db7::ebc:f6ff:fe7d:0 PC3 –\u0026gt; 4444:db7::e43:78ff:fec6:0\nPing PC1 –\u0026gt; PC2\nPC1 –\u0026gt; PC3\nPC2 –\u0026gt; PC1\nPC2 –\u0026gt; PC3\nPC3 –\u0026gt; PC1\nPC3 –\u0026gt; PC2\nTraceroute Una vez que hemos comprobado que tenemos conectividad vamos a ver si los paquetes utilizan los túneles .\nPC1 –\u0026gt; PC2\nPC1 –\u0026gt; PC3\nPC2 –\u0026gt; PC1\nPC2 –\u0026gt; PC3\nPC3 –\u0026gt; PC1\nPC3 –\u0026gt; PC2\n4.Estudio de un paquete encapsulado Antes de pasar por el túnel\nPaquete que viaja de PC1 a PC2.\nVemos que al no haber atravesado el túnel aun no tiene las cabeceras IPV4 , solo tiene las IPV6. Podemos ver que el origen es PC1 y el destino es PC3\nVeremos como en el siguiente tramo una vez atraviese el túnel el router le pondrá una cabecera IPV4 para que pueda atravesar ese tramo .\nDespués de atravesar el túnel\nSi nos fijamos en un paquete que tiene que ha atravesado un túnel podemos ver que tiene “2 niveles de red ” .\nSi nos fijamos en el nivel de red , vemos que las IPs de origen y destino son las de los extremos del túnel . Además vemos que utiliza el protocolo 47 que significa que ha travesado un túnel GRE .\nYa por ultimo podemos ver en la cabecera IPV6 , que no se distingue de una que no ha atravesado un túnel .\nUna vez llega a la red de destino\nVemos que una vez llega al destino es decir , una vez ya ha recorrido el tramo IPV4 y vuelve a entrar a la red IPV6 el router eliminara la cabecera correspondiente a IPV4 y dejara la de IPV6 para que el paquete llegue a su destino .\nVemos que la cabecera IPV6 sigue intacta , es la misma durante todo el trayecto del paquete :\nBibliografía Túneles automáticos 6to4 Túneles Automáticos Para Ipv6 Túneles GRE Túneles SIT 6to4 Linux ","date":"September 8, 2023","hero":"/images/redes/tuneles_ipv6/portada.png","permalink":"https://www.javiercd.es/posts/redes/tuneles_ipv6/tuneles_ipv6/","summary":"En este post detallado, exploramos el proceso de configuración de túneles IPv6 a IPv4 y viceversa en entornos Linux y Cisco. A medida que la migración hacia IPv6 gana importancia, la capacidad de establecer comunicaciones entre redes IPv4 e IPv6 se vuelve fundamental. Cubriremos los conceptos básicos de la configuración de túneles, incluyendo los tipos de túneles más comunes, como 6to4 y Teredo. Además, proporcionaremos instrucciones paso a paso para la configuración tanto en sistemas Linux como en dispositivos Cisco","tags":["Redes","IPV6","IPV4","Cisco","Linux"],"title":"Túneles IPV6"},{"categories":null,"contents":"\rIntroducción Vives en UNDERWORLD. En tu mundo, se presentan diferentes tipos de especies con un único fin, “cruzarse” entre sí. Estas criaturas son:\nVAMPIROS\nLICÁNTROPOS: hombres lobo con la capacidad de regresar a su estado humano.\nHOMBRES LOBO: hombres lobo que tras su primera conversión a lobo, no pudieron regresar a su estado humano.\nHUMANOS: unos mierdecillas.\nTÚ: un guerrero informático con superpoderes como darse la vuelta a un juego que todavía no ha salido al mercado o poseer la facultad de volverse invisible cuando sale de fiesta y trata de cortejar a una fémina diciéndole frases del tipo: ¿quieres que te compile el kernel nena?\nEl aspecto de UNDERWORLD es el siguiente:\n1.Enturar el escenario Tablas de enrutamiento a “papel” ROUTER HUMANO 192.168.1.0/24 0.0.0.0 F0/0 192.168.2.0/24 0.0.0.0 F1/0 192.168.3.0/24 192.168.2.2 F1/0 192.168.4.0/24 192.168.2.2 F1/0 192.168.5.0/24 192.168.2.2 F1/0 192.168.6.0/24 192.168.2.2 F1/0 192.168.7.0/24 192.168.2.2 F1/0 0.0.0.0/0 192.168.2.2 F1/0 ROUTER VAMPIROS 192.168.1.0/24 192.168.2.1 F1/0 192.168.2.0/24 0.0.0.0 F1/0 192.168.3.0/24 0.0.0.0 F0/0 192.168.4.0/24 0.0.0.0 F2/0 192.168.5.0/24 192.168.4.2 F2/0 192.168.6.0/24 192.168.4.2 F2/0 192.168.7.0/24 192.168.4.2 F2/0 0.0.0.0/0 192.168.4.2 F2/0 ROUTER LICÁNTROPOS 192.168.1.0/24 192.168.4.1 F2/0 192.168.2.0/24 192.168.4.1 F2/0 192.168.3.0/24 192.168.4.1 F2/0 192.168.4.0/24 0.0.0.0 F2/0 192.168.5.0/24 0.0.0.0 F0/0 192.168.6.0/24 0.0.0.0 F1/0 192.168.7.0/24 192.168.6.2 F1/0 0.0.0.0/0 192.168.4.1 F1/0 ROUTER HOMBRE LOBO 192.168.1.0/24 192.168.6.1 F1/0 192.168.2.0/24 192.168.6.1 F1/0 192.168.3.0/24 192.168.6.1 F1/0 192.168.4.0/24 192.168.6.1 F1/0 192.168.5.0/24 192.168.6.1 F1/0 192.168.6.0/24 0.0.0.0 F1/0 192.168.7.0/24 0.0.0.0 F0/0 0.0.0.0/0 192.168.6.1 F1/0 2.Configuración direcciones Ips interfaces Router humanos Guardamos la configuración :\nRouter vampiros Guardamos la configuración :\nRouter licántropos Guardamos la configuración :\nRouter vampiros Guardamos la configuración :\n3. Añadiendo la tabla de enrutamiento a los routers Router humanos Nos creara por defecto las rutas a las redes que estamos conectados solo necesitaremos añadir la ruta por defecto :\nNos quedaría la tabla de enrutamiento :\nGuardamos la configuración :\nRouter vampiros Añadiremos las siguientes rutas :\nAsí quedaría la tabla de enrutamiento :\nGuardamos la configuración :\nRouter licántropos Añadimos las siguientes rutas :\nAsí quedaría nuestra tabla de enrutamiento :\nGuardamos la configuración :\nRouter hombres lobo Añadimos las siguientes rutas :\nAsí quedaría nuestra tabla de enrutamiento :\nGuardamos la configuración :\n4.Prueba de enrutamiento Para no hacer muy extenso este apartado comprobare que desde PC1 llego a todos los PCs:\n5.Configuración ACLs Todo el mundo utiliza la red para mandarse mensajitos y ligar (por lo que deberás configurar la red para que esto sea posible en un principio, es decir, que todos los equipos tengan conexión entre sí). Tú, que ya estás hasta la *#%?! de tanto bicho raro como consecuencia de los cruces que se producen cuando un vampiro se cruza por ejemplo con un licántropo y el hijo de éstos con un hombre lobo y así sucesivamente, decides ponerle fin a la historia haciendo lo siguiente, metiéndole unas cuantas ACLs a los routers que los comunican:\nLos VAMPIROS no podrán comunicarse con el resto de especies. Creamos la regla para denegar el trafico de la red 192.168.3.0:\nLa aplicamos a la interfaz FastEthernet 0/0(192.168.3.1) y la aplicamos a la salida de esta :\nComprobaremos que los PCs de la red de Vampiros no pueden comunicarse con el resto , nos dice que hay una ACL cortándonos el paso :\nSi desde cualquier otro reino nos comunicamos con ellos los mensajes serán capaces de llegar a ellos sin embargo la respuesta no llegaran ya que la ACL lo impide , la respuesta es cortada ya que sale de la red de los vampiros :\nLos HOMBRES LOBO y los LICÁNTROPOS, dado que no son tan repulsivos cuando se cruzan, podrán comunicarse entre sí. Con el resto de especies no tendrán comunicación. Este apartado podemos darle diferentes soluciones , yo he optado por poner una ACL , en la interfaz F2/0 del router de licántropos .\nCreamos la ACL :\nY la aplicamos de salida de la interfaz F2/0 de salida :\nComprobaremos que la ACL funciona , haciendo pings entre las maquinas.\nDesde PC7 vemos que no nos permite salir del router de licántropos , este nos corta la comunicación pero sin embargo podemos llegar a las demás redes :\nDesde PC5 podemos observar el mismo resultado :\nDesde PC1 vemos que no obtenemos respuesta ya que solo estamos cortando el trafico de salida impidiendo que las maquinas de “dentro” se comuniquen con las de fuera .\nHUMANOS tampoco podrán comunicarse con el resto de especies\nCon el esquema actual de ACLs no seria necesario implementar una nueva regla en ya que con el esquema actual no es posible la comunicación con ellos . Aunque los mensajes que PC1 realice lleguen a su destino este no recibirá ninguna respuesta .\nPero si aun así queremos impedir que los humanos puedan enviar mensajes a los demás desde su red implementaremos la siguiente regla en su router :\nAhora estamos cortando los mensajes de los humanos desde el Router 1:\n6.Servidor DHCP Al final decides hacer negocio con las especies raras porque no tienen ni pajolera idea de informática y eres contratado por estos entes malignos para que lleves a cabo las siguientes tareas:\nHombres lobo\nLos hombres lobo que son bastante burros metiendo direcciones IP a sus máquinas, te piden que les configures el servicio DHCP para que todas sus máquinas reciban automáticamente una IP libre:\nTendremos que hacer los siguientes pasos :\nEl comando ip dhcp excluded-address 192.168.7.1 –\u0026gt; Señalamos las direcciones que no queremos que se repartan por DHCP , es decir las exclusiones . El comando ip dhcp pool HOMBRES_LOBO nombramos al rango de direcciones que estamos repartiendo Nos meterá a la configuración del rango, ahora le decimos la red que queremos que reparta las direcciones network 192.168.7.0 255.255.255.0 Ahora le indicaremos que puerta de enlace queremos que asigne default-router 192.168.7.1 Si quisiéramos configurar un servidor DNS , por ejemplo el de google seria así dns-server 8.8.8.8 Podemos ver que el servidor DHCP esta funcionando correctamente con los parámetros que le hemos indicado anteriormente :\nLicántropos\nLos licántropos por su parte, te contratan para que les asignes también por DHCP sus IPs, pero te indican que no pueden recibir las primeras 10 direcciones de su rango (sin contar la de red ni la de la puerta de enlace), ya que éstas, están reservadas para los jefes de su clan que están de viaje y volverán en unos días.\nDeclaramos las ips que vamos a excluir :\nNombramos al rango de direcciones que estamos repartiendo para así poder configurarlo:\nLe decimos la red que queremos que reparta las direcciones :\nAhora le indicaremos que puerta de enlace queremos que asigne :\nComprobaremos que el servidor dhcp esta funcionando :\n7.Modificación ACLs Permitir ligar con las vampiros\nDe tanto hacer negocio con los vampiros, te fijas en un par de vampiritas que están de muy buen ver y te gustaría poder enviarles mensajitos desde el chalet que te acabas de comprar en HUMANLAND con el pastizal que les estás sacando a las pobres “criaturicas”. Tu IP es la 192.168.1.4 y la de SELENE y SONJA son la 192.168.3.4 y 192.168.3.5 respectivamente. Añade una máquina a HUMANLAND para tu equipo denominado IT KNIGHT y 2 máquinas denominadas SELENE y SONJA con las mencionadas IPs en TRANSILVANIA.\nSi queremos realizar esto deberemos de configurar ACLs avanzadas para poder controlar el origen y el destino de los paquetes.\nLa sintaxis es bastante sencilla en este caso :\npermit ip IP_ORIGEN WILDCARD IP_DESTINO WILDCARD Crearemos la ACL para los humanos :\nTambién crearemos la ACL para los vampiros :\nLa aplicaremos a la interfaz de entrada en cada red , ambas son la FastEthernet 0/0 :\n*****Deberemos de haber quitado anteriormente las lista asignada a la interfaz si no dará un error , para quitarla es el mismo comando que para ponerla poniendo un no delante .\nAhora comprobaremos la efectividad de estas reglas que hemos implementado :\nIT KNIGHT –\u0026gt; SELENE y SONJA\nVemos que solo nos permite el trafico hacia estos dos host específicos tal y como hemos indicado en nuestras ACLs\nSELENE –\u0026gt; IT KNIGHT\nVemos que solo nos permite el trafico hacia estos dos host específicos tal y como hemos indicado en nuestras ACLs , si intentamos comunicarnos con otro host cortara el trafico la ACL:\nSONJA–\u0026gt; IT KNIGHT\nVemos que solo nos permite el trafico hacia estos dos host específicos tal y como hemos indicado en nuestras ACLs , si intentamos comunicarnos con otro host cortara el trafico la ACL:\nTambién podemos ver las estadísticas de la ACL en el router fijándonos en los hits de la regla para ver si están funcionando :\nAunque en ninguna de las listas hemos especificado en deny any , no seria necesario ya que esta implícito , es decir por defecto al no cumplirse ninguna regla desechara el trafico .\n8. Servidor web Desde que no se puede ligar en UNDERWORLD, están todos más aburridos que un ajo, así que decides ponerles un servidor WEB interno a UNDERWORLD. Añade al router PUENTE 1, un servidor denominado FICHEROS que tendrá la IP 192.168.8.2/24, creando las ACLs necesarias para que la comunidad entera de UNDERWORLD, pueda entretenerse viendo algunas web chulas.\nLo primero sera configurar la nueva interfaz del router de los HUMANOS:\nLo siguiente sera configurar para nuestro esquema actual en el router de VAMPIROS la ruta a la nueva red para que se route el escenario correctamente :\nYa por ultimo configuraremos la ip de nuestro debian de forma estática con la dirección 192.168.8.2:\nAdemás le instalaremos apache (deberemos hacerlo previamente conectado a la nube NAT ) :\nUna vez ya tenemos el servidor web preparado y enrutado en nuestro escenario , vamos a modificar las distintas ACLs para que solo puedan llegar al servidor web por el puerto 80 .\nEn el router de los humanos añadimos la siguiente regla , la cual permite todo el trafico hacia el host 192.168.8.2 que vaya al puerto 80:\nPara refrescar la lista y que se apliquen los cambios deberemos de volver a asignársela al router :\nAhora haremos lo mismo con el router de los vampiros ya que tiene configuradas ACLs extendidas al igual que los humanos :\nAhora vamos a configurar una ACL avanzada para los licántropos y los hombres lobo :\nVamos a comprobar que NO podemos hacerle ping al servidor desde los VPCs:\nEn resumen hemos mantenido las reglas anteriores pero hemos permitido el trafico al servidor web siempre y cuando venga por el puerto 80 , por eso no podemos hacerle ping .\nVamos a comprobar que podemos acceder al servidor web desde las redes : –\u0026gt;HUMANOS :\n–\u0026gt;VAMPIROS:\n–\u0026gt;LICÁNTROPOS:\n–\u0026gt; HOMBRES LOBO :\n","date":"September 8, 2023","hero":"/images/redes/underworld/portada_underwolrd.webp","permalink":"https://www.javiercd.es/posts/redes/underworld/underworld/","summary":"Introducción Vives en UNDERWORLD. En tu mundo, se presentan diferentes tipos de especies con un único fin, “cruzarse” entre sí. Estas criaturas son:\nVAMPIROS\nLICÁNTROPOS: hombres lobo con la capacidad de regresar a su estado humano.\nHOMBRES LOBO: hombres lobo que tras su primera conversión a lobo, no pudieron regresar a su estado humano.\nHUMANOS: unos mierdecillas.\nTÚ: un guerrero informático con superpoderes como darse la vuelta a un juego que todavía no ha salido al mercado o poseer la facultad de volverse invisible cuando sale de fiesta y trata de cortejar a una fémina diciéndole frases del tipo: ¿quieres que te compile el kernel nena?","tags":["Redes","Wireshark","GNS3","Cisco","Enrutamiento","ACLS"],"title":"Underworld"},{"categories":null,"contents":"\rEl mundo de UNDERWORLD ha evolucionado mucho en los últimos meses, así que debes realizar tareas de administración de la red para afrontar la nueva situación.\nPor un lado, se ha descubierto Internet en el Inframundo, de forma que cada uno de los submundos (recuerda: vampiros, licántropos, hombres lobo y humanos) se conecta a un router que, a su vez, les conecta a uno de los dos grandes routers que forman la Internet de Underworld, llamados Marcus (para humanos y vampiros) y Alexander (para hombres lobo y licántropos). Marcus y Alexander están conectados entre sí.\nEl esquema sería el siguiente:\nPor otro lado, los seres del inframundo han descubierto una vulnerabilidad en los routers CISCO que les permite saltarse las listas de control de acceso, volviendo al caos que lograste impedir en su día con las ACL.\nTu tarea consistirá entonces en:\nSustituir en la infraestructura de red los routers CISCO por máquinas Linux siguiendo el esquema de la figura. Configurar adecuadamente las máquinas Linux para que funcionen como routers. Crear las tablas de enrutamiento necesarias para que todas las máquinas se comuniquen con todas en principio, teniendo en cuenta que las redes internas tendrán direcciones privadas y en Internet tendremos direcciones públicas. Configurar los cortafuegos necesarios en los routers para que: Los VAMPIROS no puedan comunicarse con el resto de especies. Los HOMBRES LOBO y los LICÁNTROPOS, dado que no son tan repulsivos cuando se cruzan, podrán comunicarse entre sí. Con el resto de especies no tendrán comunicación. HUMANOS tampoco podrán comunicarse con el resto de especies. Configurar el servicio DHCP que tenían los hombres lobo y los licántropos en las mismas condiciones que tenían cuando se usaban routers CISCO. Configurar en los cortafuegos las reglas necesarias para que, desde HUMANLAND, IT KNIGHT siga comunicándose con sus dos vampiras favoritas (SONJA Y SELENE). Realiza las configuraciones necesarias para montar en HUMANLAND un servidor web accesible desde cualquier parte de UNDERWORLD. Preparación del escenario en Linux Configuración de las tarjetas de red Lo primero que haremos sera añadir las tarjetas de red necesarias a cada router , para ello con la maquina apagada hacemos sobre la misma clic derecho \u0026gt; configuración \u0026gt; network y añadimos los slots que sean necesarios para cada maquina :\nNecesitaremos el siguiente numero de tarjetas de red por cada dispositivo :\nRouter 1 , 2 ,3 y 4 : Necesitaran 2 tarjetas de red MARCUS y ALEXANDER : Necesitaran 3 tarjetas de red PCs : Necesitaran 1 tarjeta de red Una vez hecho esto editaremos el fichero /etc/network/interfaces para realizar nuestra configuración de red .\nPosteriormente reiniciaremos el servicio networking con systemctl restart networking.service para que se aplique la configuración de red que hemos indicado .\nConfiguración de la tarjeta de red Router 1 :\nConfiguración de la tarjeta de red Router 2 :\nConfiguración de la tarjeta de red Router 3 :\nConfiguración de la tarjeta de red Router 4 :\nConfiguración de la tarjeta de red Router MARCUS :\nConfiguración de la tarjeta de red Router ALEXANDER :\nActivar el bit de forwarding Si queremos hacer que una maquina Linux actué como router , es decir que enroute los paquetes que no tienen como destino esta deberemos de activar el bit de forwarding .\nAdemás aprovecharemos para activar el bit de forwarding permanentemente en los routers del escenario para ello editamos el fichero /etc/sysctl.conf y descomentamos esta linea :\nEsto mismo repetiremos para los 6 routers que tenemos en el escenario :\nRouter 1:\nRouter 2:\nRouter 3:\nRouter 4:\nRouter MARCUS:\nRouter ALEXANDER:\nAhora todas nuestras maquinas están configuradas para actuar como routers y encaminaran los paquetes que le lleguen y no sean para esta .\nConfiguración de rutas Aquí te mostrare si he añadido alguna ruta manualmente y las tablas de enrutamiento de los dispositivos .\nRouter MARCUS:\nRouter ALEXANDER:\nRouter 1:\nRouter 2:\nRouter 4:\nTeniendo la configuración de red que tengo en las tarjetas solo he añadido 2 rutas manuales , en los routers de MARCUS y ALEXANDER en el resto no ha sido necesario ya que esta se genera automáticamente con la puerta de enlace que hayamos colocado al configurar las interfaces de red .\nPodría haberme ahorrado escribirlas si les hubiese colocado en las interfaz que esta configurada en la red 100.X.X.X la dirección ip del otro como puerta de enlace .\nPrueba de conectividad Vamos a comprobar que hemos realizado el enrutamiento correctamente así que voy a lanzar un ping desde cada router a cada uno de los extremos del escenario .\nRouter 1 :\nRouter 2 :\nRouter 3:\nRouter 4:\nQueda comprobado que tenemos conectividad entre todos los routers , los PCS no podrán tener “conectividad” hasta que configuremos el SNAT .\nConfiguración DHCP Licántropos Los licántropos por su parte, te contratan para que les asignes también por DHCP sus IPs, pero te indican que no pueden recibir las primeras 10 direcciónes de su rango (sin contar la de red ni la de la puerta de enlace), ya que éstas, están reservadas para los jefes de su clan que están de viaje y volverán en unos días.\nCon la maquina conectada a la nube NAT y la tarjeta que este conectada configurada por DHCP nos descargaremos el servidor DHCP , para esto primero deberemos de hacer un apt update ya que la maquina no trae cargados los repositorios en memoria :\nCuando acabe de instalarse nos dará un error , este es debido a que no esta configurado el servicio y no sabe por que interfaz tiene que repartir direcciónes el servidor :\nPara ello editaremos el fichero /etc/default/isc-dhcp-server y añadiremos el nombre de la tarjeta en la sección de IPV4 :\nAhora configuraremos el ámbito con los requisitos que nos solicitan los licántropos para ello editaremos el fichero /etc/dhcp/dhcpd.conf :\nTendremos que tener en cuenta que la configuración que pongamos aquí sea coherente con la configuración de red que tenemos , tenemos que tener en cuenta que tenemos una /28 así que en este caso solo podremos tener 14 direcciónes asignables .\nPero si seguimos el enunciado las 10 primeras no las quieren por lo que solo podremos asignar 3 a nuestros clientes .\nUna vez hecho esto reiniciaremos el servicio :\nY veremos si esta funcionando , viendo el estado :\nLe asignaremos ip a un PC para comprobar que funciona :\nHombres lobo Los hombres lobo que son bastante burros metiendo direcciónes IP a sus máquinas, te piden que les configures el servicio DHCP para que todas sus máquinas reciban automáticamente una IP libre.\nCon la maquina conectada a la nube NAT y la tarjeta que este conectada configurada por DHCP nos descargaremos el servidor DHCP , para esto primero deberemos de hacer un apt update ya que la maquina no trae cargados los repositorios en memoria :\nCuando acabe de instalarse nos dará un error , este es debido a que no esta configurado el servicio y no sabe por que interfaz tiene que repartir direcciónes el servidor :\nPara ello editaremos el fichero /etc/default/isc-dhcp-server y añadiremos el nombre de la tarjeta en la sección de IPV4 :\nPor suerte los hombres lobo son menos exigentes y ellos quieres que se reparta su rango de direcciónes completo así que para ello editaremos el fichero /etc/dhcp/dhcpd.conf :\nAhora reiniciaremos el servicio :\nComprobaremos el estado del mismo para comprobar que este funcionando correctamente :\nLe asignaremos una dirección a un cliente para asegurarnos que todo funciona correctamente :\nConfiguración SNAT Para acabar la fase de preparación necesitaremos de configurar SNAT para que las distintas razas puedan comunicarse entre si .\nRouter 1 :\nMe he creado un archivo llamado iptables para guardar todas las reglas de la practica :\nPara demostrar que funciona la regla , aquí vemos una captura entre el Router 1 y el PC1 :\nVemos que una vez fuera de la red entre R1 y MARCUS se ha aplicado SNAT :\nRouter 2 :\nMe he creado un archivo llamado iptables para guardar todas las reglas de la practica :\nPara demostrar que funciona la regla , aquí vemos una captura entre el Router 2 y el PC3. Vemos que el origen es una dirección ip privada :\nVemos que una vez fuera de la red entre R2 y MARCUS se ha aplicado SNAT , ya que el origen ahora es una dirección ip publica :\nRouter 3 :\nMe he creado un archivo llamado iptables para guardar todas las reglas de la practica :\nPara demostrar que funciona la regla , aquí vemos una captura entre el Router 3 y el PC5. Vemos que el origen es una dirección ip privada :\nVemos que una vez fuera de la red entre R3 y ALEXANDER se ha aplicado SNAT , ya que el origen ahora es una dirección ip publica :\nRouter 4 :\nMe he creado un archivo llamado iptables para guardar todas las reglas de la practica :\nPara demostrar que funciona la regla , aquí vemos una captura entre el Router 4 y el PC7. Vemos que el origen es una dirección ip privada :\nVemos que una vez fuera de la red entre R4 y ALEXANDER se ha aplicado SNAT , ya que el origen ahora es una dirección ip publica :\nCon el escenario actual cualquier PC es capaz de llegar a todas las direcciónes publicas de nuestra red :\nConfiguración DNAT Para que las maquinas puedan comunicarse entre si se les ha instalado ssh , así que tendremos que configurar el DNAT .\nR1\nPara esta red como tenemos dos clientes le he cambiado el puerto que usa el ssh :\nComprobamos que puedo conectarme a ambos host desde otra red , así vemos que funciona el DNAT.\nSonja:\nSelene:\nR2\nEn esta red solo tenemos un cliente que queremos que se pueda acceder desde el exterior así que solo tendremos una regla de DNAT :\nPara comprobar la regla me meteré desde los vampiros a los humanos :\nR3\nEn esta red al haber un servicio DHCP corriendo para que la regla de DNAT funcione correctamente deberemos de hacerle una reserva a nuestro host o configurarle la tarjeta de manera estática.\nYo haré lo primero por comodidad , para ello nos dirigimos al fichero /etc/dhcp/dhcpd.conf y escribimos lo siguiente:\nhost NombreDeLaReserva { hardware ethernet DIR_MAC_HOST; fixed-address IP_RESERVA;} Una vez hecho esto reiniciamos el servicio :\nY pondré la siguiente regla:\nAhora vamos a comprobar que me puedo conectar a este host:\nR4\nEn esta red también le configuraremos una reserva en el servidor para que nuestras reglas se mantengan activas , en este caso le asignare la dirección 192.168.4.5.\nReiniciaremos el servicio y comprobamos que nuestro host tenga asignada la ip de la reserva , en caso contrario solicitaremos otra con dhclient :\nAhora añadiremos la regla de DNAT para que se pueda llegar al servidor ssh :\nComprobamos que la regla esta funcionando y podemos conectarnos desde otra red :\nConfiguración cortafuegos Los Vampiros no puedan comunicarse con el resto de especies Pondré una política por defecto DROP en la tabla FORWARD para que tire todo el trafico proveniente de la red de los vampiros :\nComprobaremos que los vampiros son incapaces de llegar a las demás redes :\nPodemos ver los hits que ha realizado para ver que esta funcionando la regla :\nPermitir comunicación entre Hombres Lobo y Licántropos Los HOMBRES LOBO y los LICÁNTROPOS, dado que no son tan repulsivos cuando se cruzan, podrán comunicarse entre sí. Con el resto de especies no tendrán comunicación.\nPondré una política por defecto DROP en la tabla FORWARD y a continuación permitiré el trafico que entre por la interfaz ens4 y salga por la ens5 , y la inversa para permitir el trafico entre esta dos redes :\nVemos que entre ellos pueden comunicarse sin embargo no pueden acceder a los Humanos ni a los Vampiros :\nComprobaremos que las reglas tienen hits :\nHUMANOS tampoco podrán comunicarse con el resto de especies Con las reglas que tenemos actualmente la comunicación con otras especies por parte de los humanos no es posible, podemos ver que en R2 sin ninguna regla adicional no podemos conectarnos :\nVemos que no podemos comunicarnos :\nSi queremos prohibir el trafico en nuestro router y no depender de las reglas externas en caso de que estas cambien añadiremos una política por defecto DROP :\nVeremos los hits en la política por defecto :\nConfigurar en los cortafuegos las reglas necesarias para que, desde HUMANLAND, IT KNIGHT siga comunicándose con sus dos vampiros favoritas (SONJA Y SELENE). Las ips de estas maquinas son :\nIT KNIGHT (SSH)–\u0026gt; 192.168.2.3:22 SONJA (SSH) –\u0026gt; 192.168.1.4:22 SELENE (SSH) –\u0026gt; 192.168.1.5:2222 En el router 1 las reglas necesarias para poder permitir esta comunicación son :\nEn el router 2 las reglas necesarias para poder permitir esta comunicación son :\nVamos a ir comprobando acción a acción para asegurarnos de que estas reglas realizan su cometido.\nSELENE –\u0026gt; ITKNIGHT\nEn el router 1 :\nEn el router 2:\nSONJA –\u0026gt; ITKNIGHT\nHacemos ssh :\nVemos los hits del router 1:\nVemos los hits del router 2(Misma regla que el apartado anterior) :\nITKNIGHT –\u0026gt; SONJA\nHacemos ssh :\nVemos los hits del router 1 :\nVemos los hits del router 2 :\nITKNIGHT –\u0026gt; SELENE\nLanzamos el ssh :\nVemos los hits del router 1 :\nVemos los hits del router 2:\nServidor web HUMANLAND Realiza las configuraciones necesarias para montar en HUMANLAND un servidor web accesible desde cualquier parte de UNDERWORLD.\nLe he dado a este la ip 192.168.2.10 .\nLo primero que debemos de configurar es el DNAT en el router R2(HUMALAND):\nAhora en el router 2 permitiremos que se reciban peticiones al servidor y sus respuestas :\nEn el router 1 permitimos que puedan hacer peticiones y sus respuestas :\nPara terminar en ALEXANDER permitimos que puedan atravesar peticiones web :\nVamos a comprobar que se pueden acceder desde todas las redes .\nVAMPIROS :\nComprobamos los hits en router 1 :\nHOMBRES LOBO Y LICÁNTROPOS\nHacemos la petición web desde ambas redes :\nComprobamos los hits en router ALEXANDER :\nPor ultimo vemos los hits en el Router 2 (HUMANOS) de la regla DNAT\nEscenario con routers Cisco Configuración de las interfaces R1\nR2\nR3\nR4\nMARCUS\nALEXANDER\nTablas de enrutamiento R1\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de R1:\nR2\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de R2:\nR3\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de R3:\nR4\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de R4:\nMARCUS\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de MARCUS:\nALEXANDER\nAñadimos la ruta por defecto :\nAsí quedaría la tabla de enrutamiento de ALEXANDER:\nPrueba de conectividad Vamos a comprobar que hemos realizado el enrutamiento correctamente así que voy a lanzar un ping desde cada router a cada uno de los extremos del escenario .\nR1 → A los extremos :\nR2 → A los extremos :\nR3 –\u0026gt; a los extremos:\nR4 –\u0026gt; a los extremos\nConfiguración DHCP Licántropos Los licántropos por su parte, te contratan para que les asignes también por DHCP sus IPs, pero te indican que no pueden recibir las primeras 10 direcciónes de su rango (sin contar la de red ni la de la puerta de enlace), ya que éstas, están reservadas para los jefes de su clan que están de viaje y volverán en unos días.\nLo primero que haremos sera establecer el rango de IP´s excluidas del conjunto (pool) direcciónes que podrá asignar el servicio indicando la ip inicial y final del rango, ambas incluidas:\nPonemos un nombre al rango del servicio DHCP:\nDefinimos la red a la que dará servicio de DHCP:\nIncluimos la puerta de enlace que ofrecerá el servicio :\nCon esto ya tendríamos montado el servidor DHCP , con el siguiente comando podemos ver las estadísticas del servicio para ver si este esta funcionando :\nComprobaremos a demás que se ha realizado la concesión a nuestro host :\nDHCP Hombres lobo Los hombres lobo que son bastante burros metiendo direcciónes IP a sus máquinas, te piden que les configures el servicio DHCP para que todas sus máquinas reciban automáticamente una IP libre.\nEn el apartado anterior detallo cada apartado de la configuración de un servidor DHCP en cisco , aquí te muestro la configuración para la red de los Hombre Lobo :\nComprobaremos que esta funcionando :\nConfiguración SNAT Router 1:\nLo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nActivamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nEl SNAT estaría funcionando , así que vamos a comprobarlo :\nVemos que la regla tiene HITS:\nRouter 2:\nLo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nActivamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nEl SNAT estaría funcionando , así que vamos a comprobarlo viendo si la regla tiene HITS:\nRouter 3:\nLo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nActivamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nEl SNAT estaría funcionando , así que vamos a comprobarlo viendo si la regla tiene HITS:\nRouter 4:\nLo primero que haremos sera crear una acl para permitir el trafico que queremos hacer SNAT :\nLe asignaremos a la interfaz interna de nuestra red esta regla :\nAhora crearemos un pool con las ips publicas , el comando seria este no sale completo en la terminal :\nActivamos el NAT :\nIndicamos que interfaz es de “dentro” :\nIndicamos la interfaz de “fuera”:\nEl SNAT estaría funcionando , así que vamos a comprobarlo viendo si la regla tiene HITS:\nConfiguración de DNAT R1\nComprobación :\nR2\nComprobación :\nR3\nComprobación :\nR4\nComprobación :\nConfiguración cortafuegos Los Vampiros no puedan comunicarse con el resto de especies Para ello vamos a borrar la regla existente que hay en la lista :\nAhora denegaremos el trafico saliente de la red de los vampiros :\nComprobamos que no pueden comunicarse :\nMiramos los hits de las reglas :\nPermitir comunicación entre Hombres Lobo y Licántropos Los HOMBRES LOBO y los LICÁNTROPOS, dado que no son tan repulsivos cuando se cruzan, podrán comunicarse entre sí. Con el resto de especies no tendrán comunicación.\nCon estas dos reglas permitimos a cualquier host de nuestra redes locales salir cuando el destino es los hombres lobos o los licántropos :\nR3-→ 180.0.0.1 R4 –\u0026gt; 190.0.0.1 Vemos que nos tira los paquetes que no van desde HL a LC o de LC a HL :\nHUMANOS tampoco podrán comunicarse con el resto de especies Con las reglas que tenemos actualmente la comunicación con otras especies por parte de los humanos no es posible, podemos ver que en R2 sin ninguna regla adicional no podemos conectarnos ya que nuestros paquetes llegaran a las redes .\nPara que verdaderamente los humanos no puedan comunicarse sin depender de las reglas de los demos reinos , vamos a impedir que estos salgan del reino :\nSi lo comprobamos ahora ellos no podrán salir del reino :\nMiramos los hits :\nConfigurar en los cortafuegos las reglas necesarias para que, desde HUMANLAND, IT KNIGHT siga comunicándose con sus dos vampiros favoritas (SONJA Y SELENE). Las ips de estas maquinas son :\nIT KNIGHT (SSH) -–\u0026gt; 192.168.2.3:22 SONJA (SSH) -–\u0026gt; 192.168.1.4:22 SELENE (SSH) -–\u0026gt; 192.168.1.5:2222 Para permitir que los vampiros puedan salir a comunicarse con los humanos :\nPermitimos los mensajes de salida a la publica de los vampiros cuando el puerto sea el 22 y 2222:\nAhora vamos a permitir que los vampiros puedan conectarse a los humanos usando el puerto 22 :\nNo se porque no funciona .. solo va si no coloco ninguna regla incluso permitiendo TODO el trafico ssh tampoco … También he permitido todo el ICMP pero nada sigue ocurriendo lo mismo .\nEl nat y el SNAT están funcionando bien pero a la hora de hacer las reglas ssh pasa lo siguiente en la red local al ser mandados de vuelta el router los corta a pesar de que el trafico esta permitido\n","date":"September 8, 2023","hero":"/images/redes/underworld_evolution/portada.jpeg","permalink":"https://www.javiercd.es/posts/redes/underworld_evolution/underworld_evolution/","summary":"El mundo de UNDERWORLD ha evolucionado mucho en los últimos meses, así que debes realizar tareas de administración de la red para afrontar la nueva situación.\nPor un lado, se ha descubierto Internet en el Inframundo, de forma que cada uno de los submundos (recuerda: vampiros, licántropos, hombres lobo y humanos) se conecta a un router que, a su vez, les conecta a uno de los dos grandes routers que forman la Internet de Underworld, llamados Marcus (para humanos y vampiros) y Alexander (para hombres lobo y licántropos).","tags":["Redes","SNAT","DNAT","Cisco","Linux"],"title":"Underworld evolution"}]